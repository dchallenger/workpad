/*
SQLyog Professional v12.09 (64 bit)
MySQL - 5.1.41 : Database - ortigas
*********************************************************************
*/ 
/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
/* Trigger structure for table `ww_approver_class_company` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `approver_class_company_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `approver_class_company_insert_before` BEFORE INSERT ON `ww_approver_class_company` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-18 initial
                        2014-07-18 
        */ 
        SET NEW.`alias` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`approver_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_approver_class_company` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `approver_class_company_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `approver_class_company_update_before` BEFORE UPDATE ON `ww_approver_class_company` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-18 initial
                        2014-07-18 
        */ 
        SET NEW.`alias` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`approver_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_approver_class_department` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `approver_class_depatment_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `approver_class_depatment_insert_before` BEFORE INSERT ON `ww_approver_class_department` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-18 initial
                        2014-07-18 
        */ 
        SET NEW.`alias` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`approver_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_approver_class_department` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `approver_class_department_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `approver_class_department_update_before` BEFORE UPDATE ON `ww_approver_class_department` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-18 initial
                        2014-07-18 
        */ 
        SET NEW.`alias` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`approver_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_approver_class_position` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `approver_class_position_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `approver_class_position_insert_before` BEFORE INSERT ON `ww_approver_class_position` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-18 initial
                        2014-07-18 
        */
         
        SET NEW.`alias` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`approver_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_approver_class_position` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `approver_class_position_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `approver_class_position_update_before` BEFORE UPDATE ON `ww_approver_class_position` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-18 initial
                        2014-07-18 
        */ 
        SET NEW.`alias` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`approver_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_approver_class_user` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `approver_class_user_before_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `approver_class_user_before_insert` BEFORE INSERT ON `ww_approver_class_user` FOR EACH ROW BEGIN
	SET NEW.`alias` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`approver_id` LIMIT 1);
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_approver_class_user` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `approver_class_user_before_update` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `approver_class_user_before_update` BEFORE UPDATE ON `ww_approver_class_user` FOR EACH ROW BEGIN
	SET NEW.`alias` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`approver_id` LIMIT 1);
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_audit_log_trail` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `audit_log_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `audit_log_insert_before` BEFORE INSERT ON `ww_audit_log_trail` FOR EACH ROW 
      BEGIN
	
	/* for signatories */
	if NEW.item_name = 'class_id' then
		if NEW.original_value != '' then
			SET NEW.`original_value` = (SELECT IFNULL(class,'*') FROM ww_approver_class WHERE class_id=NEW.`original_value` LIMIT 1);
		end if;
		IF NEW.new_value != '' THEN
			SET NEW.`new_value` = (SELECT IFNULL(class,'*') FROM ww_approver_class WHERE class_id=NEW.`new_value` LIMIT 1);
		END IF;		
		set NEW.item_name = 'module';
	end if;
	IF NEW.item_name = 'approver' AND NEW.modules = 'signatories' THEN
		set NEW.item_name = 'signatory';
		
		if NEW.original_value != '' then
			if NEW.original_value = 1 then
				set NEW.original_value = 'Yes';
			else
				SET NEW.original_value = 'No';
			end if;
		end if;
		
		IF NEW.new_value !=  '' then
			if NEW.new_value = 1 then
				SET NEW.new_value = 'Yes';
			ELSE
				SET NEW.new_value = 'No';
			END if;
		END IF;		
	END IF;
		
	if NEW.item_name = 'alias' and NEW.modules = 'signatories' then
		SET NEW.item_name = 'approver';
	end if;
	IF NEW.item_name = 'email' AND NEW.modules = 'signatories' THEN
		IF NEW.original_value != '' THEN
			IF NEW.original_value = 1 THEN
				SET NEW.original_value = 'Yes';
			ELSE
				SET NEW.original_value = 'No';
			END IF;
		END IF;
		
		IF NEW.new_value !=  '' THEN
			IF NEW.new_value = 1 THEN
				SET NEW.new_value = 'Yes';
			ELSE
				SET NEW.new_value = 'No';
			END IF;
		END IF;	
	END IF;	
	IF NEW.item_name = 'employee' AND NEW.modules = 'signatories' THEN
		IF NEW.original_value != '' THEN
			SET NEW.`original_value` = (SELECT IFNULL(display_name,'*') FROM users WHERE user_id=NEW.`original_value` LIMIT 1);
		end if;
		IF NEW.new_value != '' THEN
			SET NEW.`new_value` = (SELECT IFNULL(display_name,'*') FROM users WHERE user_id=NEW.`new_value` LIMIT 1);
		END IF;		
	end if;
	
	/* for memo */
	IF NEW.item_name = 'email' AND (NEW.modules = 'memo' OR NEW.modules = 'memo_manage') THEN
		IF NEW.original_value != '' THEN
			IF NEW.original_value = 1 THEN
				SET NEW.original_value = 'Yes';
			ELSE
				SET NEW.original_value = 'No';
			END IF;
		END IF;
		
		IF NEW.new_value !=  '' THEN
			IF NEW.new_value = 1 THEN
				SET NEW.new_value = 'Yes';
			ELSE
				SET NEW.new_value = 'No';
			END IF;
		END IF;	
	END IF;	
				
	IF NEW.item_name = 'publish' AND (NEW.modules = 'memo' or NEW.modules = 'memo_manage') THEN
		IF NEW.original_value != '' THEN
			IF NEW.original_value = 1 THEN
				SET NEW.original_value = 'Yes';
			ELSE
				SET NEW.original_value = 'No';
			END IF;
		END IF;
		
		IF NEW.new_value !=  '' THEN
			IF NEW.new_value = 1 THEN
				SET NEW.new_value = 'Yes';
			ELSE
				SET NEW.new_value = 'No';
			END IF;
		END IF;	
	END IF;	
	IF NEW.item_name = 'comments' AND (NEW.modules = 'memo' OR NEW.modules = 'memo_manage') THEN
		IF NEW.original_value != '' THEN
			IF NEW.original_value = 1 THEN
				SET NEW.original_value = 'Yes';
			ELSE
				SET NEW.original_value = 'No';
			END IF;
		END IF;
		
		IF NEW.new_value !=  '' THEN
			IF NEW.new_value = 1 THEN
				SET NEW.new_value = 'Yes';
			ELSE
				SET NEW.new_value = 'No';
			END IF;
		END IF;	
	END IF;
						
      END */$$


DELIMITER ;

/* Trigger structure for table `ww_memo` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `memo_update_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `memo_update_after` AFTER UPDATE ON `ww_memo` FOR EACH ROW BEGIN
        
        /* This will update system feeds on unpublish/deleted content
           last change: 2016-04-01 initial
                        2016-04-01 
        */ 
        IF NEW.`deleted` = 1 THEN
           UPDATE `ww_system_feeds` SET `deleted`=1 WHERE `record_id`=NEW.`memo_id`;
        END IF;
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_menu` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `menu_to_insert_on_profile_menu` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `menu_to_insert_on_profile_menu` BEFORE INSERT ON `ww_menu` FOR EACH ROW BEGIN
        /* 
           - to insert this so that admin profile always has the rights on newly created menu
           - to update/delete on profile to sync records
           
           INSERT INTO www_profile_menu 
           profile_id = 1
        */
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_partners` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `partners_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `partners_insert_before` BEFORE INSERT ON `ww_partners` FOR EACH ROW 
BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-04-16 initial
                        2014-04-16 
        */ 
        
        IF NEW.`deleted` = 0 THEN
           SET @coid = (SELECT company_id FROM users_profile WHERE user_id=NEW.`user_id` LIMIT 1);
           INSERT INTO `ww_payroll_partners` (`user_id`,`company_id`,`salary`) VALUES (NEW.`user_id`,@coid,NEW.`salary`)
           ON DUPLICATE KEY UPDATE company_id=IFNULL(company_id,@coid),`modified_on`=NOW(),`deleted`=0;
        END IF;
                
        SET NEW.`alias` = (SELECT IFNULL(display_name,'*') FROM users WHERE user_id=NEW.`user_id` LIMIT 1);
        SET NEW.`shift` = (SELECT IFNULL(`shift`,'*') FROM `ww_time_shift` WHERE `shift_id`=NEW.shift_id LIMIT 1);
        SET NEW.`calendar` = (SELECT IFNULL(`calendar`,'*') FROM `ww_time_shift_weekly` WHERE `calendar_id`=NEW.calendar_id LIMIT 1);
        SET NEW.`status` = (SELECT IFNULL(`employment_status`,'*') FROM `ww_partners_employment_status` WHERE `employment_status_id`=NEW.status_id LIMIT 1);
        SET NEW.`employment_type` = (SELECT IFNULL(`employment_type`,'*') FROM `ww_partners_employment_type` WHERE `employment_type_id`=NEW.employment_type_id LIMIT 1);        
        SET NEW.`v_job_grade` = (SELECT IFNULL(`job_level`,'*') FROM `ww_users_job_grade_level` WHERE `job_grade_id`=NEW.job_grade_id LIMIT 1);
        SET NEW.`classification` = (SELECT IFNULL(`classification`,'*') FROM `ww_partners_classification` WHERE `classification_id`=NEW.classification_id LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_partners` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `partners_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `partners_insert_after` AFTER INSERT ON `ww_partners` FOR EACH ROW 
BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2015-09-15 initial
                        0000-00-00 
        */ 
        
       IF NEW.`deleted` <> 1 THEN
           SET @p1 = NEW.`effectivity_date`;
           SET @p2 = @p1 + INTERVAL 30 DAY;
           SET @p3 = NEW.`user_id`;
           -- CALL sp_time_period_populate_user(@p1, @p2, @p3);
        END IF;
              
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_partners` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `partners_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `partners_update_before` BEFORE UPDATE ON `ww_partners` FOR EACH ROW 
BEGIN
       
       /* This will insert-update display names accross all modules 
          last change: 2014-04-16 initial
                       2015-09-14 company for payroll 
       */ 
       IF NEW.`deleted` = 0 THEN
          SET @coid = (SELECT company_id FROM ww_users_profile WHERE user_id=NEW.`user_id` LIMIT 1);
          INSERT INTO `ww_payroll_partners` (`user_id`,`company_id`,`salary`) VALUES (NEW.`user_id`,@coid,NEW.`salary`)
          ON DUPLICATE KEY UPDATE company_id=IFNULL(company_id,@coid),`modified_on`=NOW(),`deleted`=0;
       END IF;
       
       SET NEW.`alias` = (SELECT IFNULL(display_name,'*') FROM ww_users WHERE user_id=NEW.`user_id` LIMIT 1);
       SET NEW.`shift` = (SELECT IFNULL(`shift`,'*') FROM `ww_time_shift` WHERE `shift_id`=NEW.shift_id LIMIT 1);
       SET NEW.`calendar` = (SELECT IFNULL(`calendar`,'*') FROM `ww_time_shift_weekly` WHERE `calendar_id`=NEW.calendar_id LIMIT 1);
       SET NEW.`status` = (SELECT IFNULL(`employment_status`,'*') FROM `ww_partners_employment_status` WHERE `employment_status_id`=NEW.status_id LIMIT 1);
       SET NEW.`employment_type` = (SELECT IFNULL(`employment_type`,'*') FROM `ww_partners_employment_type` WHERE `employment_type_id`=NEW.employment_type_id LIMIT 1);        
       SET NEW.`v_job_grade` = (SELECT IFNULL(`job_level`,'*') FROM `ww_users_job_grade_level` WHERE `job_grade_id`=NEW.job_grade_id LIMIT 1);
       SET NEW.`classification` = (SELECT IFNULL(`classification`,'*') FROM `ww_partners_classification` WHERE `classification_id`=NEW.classification_id LIMIT 1);       
       
       SET NEW.`modified_on` = NOW();
       
   END */$$


DELIMITER ;

/* Trigger structure for table `ww_partners` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `partners_update_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `partners_update_after` AFTER UPDATE ON `ww_partners` FOR EACH ROW 
BEGIN
        
        /* This will update partner schedule from this date onwards
           last change: 2015-07-16 initial
                        2015-09-09 update users 
                        2017-03-18 change shift_id to calendar_id
        */ 
        
        IF NEW.`calendar_id` <> OLD.`calendar_id` AND IFNULL(NEW.`resigned_date`,'0000-00-00')='0000-00-00' THEN
           SET @p1 = CURDATE();
           SET @p2 = CONCAT(YEAR(CURDATE()),'-12-31');
           SET @p3 = NEW.`user_id`;
           CALL sp_time_period_populate_user(@p1, @p2, @p3);
        END IF;
        
        IF IFNULL(NEW.`resigned_date`,'0000-00-00') <> '0000-00-00' THEN
           IF NEW.`resigned_date` <= CURDATE() THEN
              UPDATE `ww_users` SET active=0 WHERE `user_id`=NEW.`user_id` LIMIT 1;
           END IF;
        END IF;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_partners_loan_application` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `partners_loan_application_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `partners_loan_application_insert_after` AFTER INSERT ON `ww_partners_loan_application` FOR EACH ROW BEGIN
    
       /* This will update necessary master table
          last change: 2014-04-25: initial
                       2014-04-26: populate approver/s
       */
       IF NEW.`loan_application_status_id`=2 THEN
          INSERT INTO `logtable` (`log`) VALUES (CONCAT(NEW.`loan_application_id`,' ',NEW.`user_id`)); 
          CALL sp_partners_loan_application_populate_approvers(NEW.`loan_application_id`, NEW.`user_id`);   
       END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_partners_loan_application` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `partners_loan_application_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `partners_loan_application_update_before` BEFORE UPDATE ON `ww_partners_loan_application` FOR EACH ROW BEGIN
    
       /* This will insert-update approver/s on application
          last change: 2014-04-26: initial
                       2014-04-26: populate approver/s if set to for approval
       */
       -- 
       SET NEW.`modified_on` = NOW();
       -- 
    
       IF NEW.`loan_application_status_id`=2 THEN
          -- 
          CALL sp_partners_loan_application_populate_approvers(NEW.`loan_application_id`, NEW.`user_id`);  
          --                   
       END IF;
       IF NEW.`loan_application_status_id`=8 THEN
          -- 
          UPDATE `ww_partners_loan_application_approver` SET `loan_application_status_id`=8,`loan_application_status`='Cancelled' WHERE `loan_application_id`=NEW.`loan_application_id`;  
          --                   
       END IF;          
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_partners_loan_application_approver` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `partners_loan_application_approver_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `partners_loan_application_approver_insert_before` BEFORE INSERT ON `ww_partners_loan_application_approver` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-17 initial
                        2014-07-17 
        */ 
        SET NEW.`display_name` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`user_id` LIMIT 1);
        SET NEW.`loan_application_status` = (SELECT IFNULL(`loan_application_status`,'*') FROM `ww_partners_loan_application_status` WHERE `loan_application_status_id`=NEW.`loan_application_status_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_partners_loan_application_approver` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `partners_loan_application_approver_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `partners_loan_application_approver_update_before` BEFORE UPDATE ON `ww_partners_loan_application_approver` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-17 initial
                        2015-05-05 change display name  
        */ 
	SET NEW.`display_name` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`user_id` LIMIT 1);
        SET NEW.`loan_application_status` = (SELECT IFNULL(`loan_application_status`,'*') FROM `ww_partners_loan_application_status` WHERE `loan_application_status_id`=NEW.`loan_application_status_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_partners_movement_action` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `partners_movement_action_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `partners_movement_action_insert_before` BEFORE INSERT ON `ww_partners_movement_action` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-04-16 initial
                        2014-04-18 
        */ 
        SET NEW.`display_name` = (SELECT IFNULL(display_name,'*') FROM users WHERE user_id=NEW.`user_id` LIMIT 1);
        SET NEW.`type` = (SELECT IFNULL(`type`,'*') FROM `ww_partners_movement_type` WHERE `type_id`=NEW.type_id LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_partners_movement_action` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `partners_movement_action_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `partners_movement_action_update_before` BEFORE UPDATE ON `ww_partners_movement_action` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-04-16 initial
                        2014-04-18 
        */ 
        SET NEW.`display_name` = (SELECT IFNULL(display_name,'*') FROM users WHERE user_id=NEW.`user_id` LIMIT 1);
        SET NEW.`type` = (SELECT IFNULL(`type`,'*') FROM `ww_partners_movement_type` WHERE `type_id`=NEW.type_id LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_payroll_bonus` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `payroll_bonus_before_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `payroll_bonus_before_insert` BEFORE INSERT ON `ww_payroll_bonus` FOR EACH ROW BEGIN
	IF NEW.bonus_transaction_code IS NOT NULL THEN
		SET NEW.bonus_transaction_id = (SELECT transaction_id FROM ww_payroll_transaction WHERE transaction_code = NEW.bonus_transaction_code LIMIT 1);
	END IF;
	
	IF NEW.taxable_bonus_transaction_code IS NOT NULL THEN
		SET NEW.taxable_bonus_transaction_id = (SELECT transaction_id FROM ww_payroll_transaction WHERE transaction_code = NEW.taxable_bonus_transaction_code LIMIT 1);
	END IF;
	
	IF NEW.method IS NOT NULL THEN
		SET NEW.transaction_method_id = (SELECT payroll_transaction_method_id FROM ww_payroll_transaction_method WHERE payroll_transaction_method = NEW.method  LIMIT 1);
	END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_payroll_bonus_employee` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `payroll_bonus_employee_before_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `payroll_bonus_employee_before_insert` BEFORE INSERT ON `ww_payroll_bonus_employee` FOR EACH ROW BEGIN
    
	IF IFNULL(NEW.`document_no`,'') <> '' THEN
		SET NEW.`bonus_id` = (SELECT `bonus_id` FROM `ww_payroll_bonus` WHERE `document_no` = NEW.`document_no` LIMIT 1);
	END IF;
    
	IF IFNULL(NEW.`id_number`,'') <> '' THEN
		SET NEW.`employee_id` = (SELECT `user_id` FROM `ww_partners` WHERE `id_number` = NEW.`id_number` LIMIT 1);
	END IF;
    
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_payroll_entry_batch` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `payroll_entry_batch_before_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `payroll_entry_batch_before_insert` BEFORE INSERT ON `ww_payroll_entry_batch` FOR EACH ROW BEGIN
	IF NEW.transaction_code IS NOT NULL THEN
		SET NEW.transaction_id = (SELECT transaction_id FROM ww_payroll_transaction where transaction_code = NEW.transaction_code LIMIT 1);
	END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_payroll_entry_batch_employee` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `payroll_entry_batch_employee` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `payroll_entry_batch_employee` BEFORE INSERT ON `ww_payroll_entry_batch_employee` FOR EACH ROW BEGIN
    
	if NEW.`document_no` is NOT NULL THEN
		SET NEW.`batch_entry_id` = (SELECT `batch_entry_id` FROM `ww_payroll_entry_batch` WHERE `document_no`=NEW.`document_no` LIMIT 1);		
	END IF;
    
	IF IFNULL(NEW.`id_number`,'') <> '' THEN
		SET NEW.`employee_id` = (SELECT `user_id` FROM `ww_partners` WHERE `id_number` = NEW.`id_number` AND deleted = 0 LIMIT 1);	
	END IF;
    
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_payroll_entry_recurring` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `payroll_entry_recurring_before_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `payroll_entry_recurring_before_insert` BEFORE INSERT ON `ww_payroll_entry_recurring` FOR EACH ROW BEGIN
	if NEW.transaction_code is not null then
		set NEW.transaction_id = (Select transaction_id from ww_payroll_transaction where transaction_code = NEW.transaction_code LIMIT 1);
	end if;
	
	IF NEW.transaction_method IS NOT NULL THEN
		SET NEW.transaction_method_id = (SELECT payroll_transaction_method_id FROM ww_payroll_transaction_method WHERE payroll_transaction_method = NEW.transaction_method LIMIT 1);
	END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_payroll_entry_recurring_employee` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `payroll_entry_recurring_employee_before_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `payroll_entry_recurring_employee_before_insert` BEFORE INSERT ON `ww_payroll_entry_recurring_employee` FOR EACH ROW BEGIN
    
	IF IFNULL(NEW.`document_no`,'') <> '' THEN
		SET NEW.`recurring_id` = (select `recurring_id` from `ww_payroll_entry_recurring` where `document_no` = NEW.`document_no` LIMIT 1);
	END IF;
    
	IF IFNULL(NEW.`id_number`,'') <> '' THEN
		SET NEW.`employee_id` = (SELECT `user_id` FROM `ww_partners` WHERE `id_number` = NEW.`id_number` AND deleted = 0 LIMIT 1);
	END IF;
    
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_payroll_partners_loan` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `payroll_partners_loan_before_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `payroll_partners_loan_before_insert` BEFORE INSERT ON `ww_payroll_partners_loan` FOR EACH ROW BEGIN
	if NEW.id_number is not null then
		SET NEW.user_id = (select user_id from ww_partners where id_number = NEW.id_number limit 1);
	end if;
	
	IF NEW.loan_code IS NOT NULL THEN
		SET NEW.loan_id = (SELECT loan_id FROM ww_payroll_loan where loan_code = NEW.loan_code LIMIT 1);
	END IF;
	
	IF NEW.loan_status IS NOT NULL THEN
		SET NEW.loan_status_id = (SELECT loan_status_id FROM ww_payroll_loan_status WHERE loan_status = NEW.loan_status LIMIT 1);
	END IF;
	
	IF NEW.payment_mode IS NOT NULL THEN
		SET NEW.payment_mode_id = (SELECT payment_mode_id FROM ww_payroll_payment_mode WHERE payment_mode = NEW.payment_mode LIMIT 1);
	END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_payroll_period` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `payroll_period_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `payroll_period_insert_before` BEFORE INSERT ON `ww_payroll_period` FOR EACH ROW BEGIN
    
        if NEW.period_processing_type_id = 4 then
		set NEW.bonus_tag = 1;
        end if;
         
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_payroll_period` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `payroll_period_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `payroll_period_insert_after` AFTER INSERT ON `ww_payroll_period` FOR EACH ROW BEGIN
        
        /* This will insert Year on ww_payroll_year */
        set @payYear = year(NEW.payroll_date);
        set @nCount = 0;
        select count(*) into @nCount from ww_payroll_year where payroll_year = @payYear;
        if @nCount = 0 then
		insert into ww_payroll_year(payroll_year) values (@payYear);
        end if;
                
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_appraisal_applicable` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_appraisal_logs_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_appraisal_logs_insert` BEFORE INSERT ON `ww_performance_appraisal_applicable` FOR EACH ROW BEGIN
    
       SET @touser = '';
       
       SELECT IFNULL(`display_name`,'') INTO @touser FROM `users` WHERE `user_id`=NEW.`to_user_id` LIMIT 1;
       
       INSERT INTO `ww_performance_appraisal_logs` 
          (appraisal_id, user_id, status_id, to_user_id, to_user)
       SELECT NEW.`appraisal_id`, NEW.`user_id`, NEW.`status_id`, NEW.`to_user_id`, @touser;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_appraisal_applicable` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_appraisal_applicable_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_appraisal_applicable_update_before` BEFORE UPDATE ON `ww_performance_appraisal_applicable` FOR EACH ROW BEGIN
        
        SET NEW.`modified_date` = NOW();
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_appraisal_applicable` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_appraisal_logs_update` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_appraisal_logs_update` AFTER UPDATE ON `ww_performance_appraisal_applicable` FOR EACH ROW BEGIN
    
       SET @touser = '';
       
       SELECT IFNULL(`display_name`,'') INTO @touser FROM `users` WHERE `user_id`=NEW.`to_user_id` LIMIT 1;
       
       INSERT INTO `ww_performance_appraisal_logs` 
          (appraisal_id, user_id, status_id, to_user_id, to_user)
       SELECT NEW.`appraisal_id`, NEW.`user_id`, NEW.`status_id`, NEW.`to_user_id`, @touser;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_appraisal_applicable_user` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_appraisal_applicable_user_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_appraisal_applicable_user_update_before` BEFORE UPDATE ON `ww_performance_appraisal_applicable_user` FOR EACH ROW BEGIN
        
        SET NEW.`modified_date` = NOW();
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_appraisal_approver` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_appraisal_approver_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_appraisal_approver_insert_before` BEFORE INSERT ON `ww_performance_appraisal_approver` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-17 initial
                        2014-07-17 
        */ 
        SET NEW.`display_name` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`approver_id` LIMIT 1);
        SET NEW.`performance_status` = (SELECT IFNULL(`performance_status`,'*') FROM `ww_performance_status` WHERE `performance_status_id`=NEW.`performance_status_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_appraisal_approver` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_appraisal_approver_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_appraisal_approver_update_before` BEFORE UPDATE ON `ww_performance_appraisal_approver` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-17 initial
                        2014-07-17 
        */ 
        SET NEW.`performance_status` = (SELECT IFNULL(`performance_status`,'*') FROM `ww_performance_status` WHERE `performance_status_id`=NEW.`performance_status_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_appraisal_contributor` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_appraisal_contributor_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_appraisal_contributor_update_before` BEFORE UPDATE ON `ww_performance_appraisal_contributor` FOR EACH ROW BEGIN
        
        SET NEW.`modified_date` = NOW();
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_planning_applicable` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_planning_logs_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_planning_logs_insert` BEFORE INSERT ON `ww_performance_planning_applicable` FOR EACH ROW BEGIN
    
       SET @touser = '';
       
       SELECT IFNULL(`display_name`,'') INTO @touser FROM `users` WHERE `user_id`=NEW.`to_user_id` LIMIT 1;
       
       INSERT INTO `ww_performance_planning_logs` 
          (planning_id, user_id, status_id, to_user_id, to_user)
       SELECT NEW.`planning_id`, NEW.`user_id`, NEW.`status_id`, NEW.`to_user_id`, @touser;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_planning_applicable` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_planning_logs_update` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_planning_logs_update` AFTER UPDATE ON `ww_performance_planning_applicable` FOR EACH ROW BEGIN
    
       SET @touser = '';
       
       SELECT IFNULL(`display_name`,'') INTO @touser FROM `users` WHERE `user_id`=NEW.`to_user_id` LIMIT 1;
       
       INSERT INTO `ww_performance_planning_logs` 
          (planning_id, user_id, status_id, to_user_id, to_user)
       SELECT NEW.`planning_id`, NEW.`user_id`, NEW.`status_id`, NEW.`to_user_id`, @touser;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_planning_approver` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_planning_approver_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_planning_approver_insert_before` BEFORE INSERT ON `ww_performance_planning_approver` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-17 initial
                        2014-07-17 
        */ 
        SET NEW.`display_name` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`approver_id` LIMIT 1);
        SET NEW.`performance_status` = (SELECT IFNULL(`performance_status`,'*') FROM `ww_performance_status` WHERE `performance_status_id`=NEW.`performance_status_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_performance_planning_approver` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `performance_planning_approver_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `performance_planning_approver_update_before` BEFORE UPDATE ON `ww_performance_planning_approver` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-17 initial
                        2014-07-17 
        */ 
        SET NEW.`performance_status` = (SELECT IFNULL(`performance_status`,'*') FROM `ww_performance_status` WHERE `performance_status_id`=NEW.`performance_status_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_recruitment_manpower_plan` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `recruitment_manpower_plan_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `recruitment_manpower_plan_insert_after` AFTER INSERT ON `ww_recruitment_manpower_plan` FOR EACH ROW BEGIN
	IF NEW.`manpower_plan_status_id`=2 THEN
          -- 
          CALL sp_recruitment_manpower_plan_populate_approvers(NEW.`plan_id`, NEW.`user_id`);  
          --                   
       END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_recruitment_manpower_plan` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `recruitment_manpower_plan_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `recruitment_manpower_plan_update_before` BEFORE UPDATE ON `ww_recruitment_manpower_plan` FOR EACH ROW BEGIN
	IF NEW.`manpower_plan_status_id`=2 THEN
          -- 
          CALL sp_recruitment_manpower_plan_populate_approvers(NEW.`plan_id`, NEW.`user_id`);  
          --                   
       END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_recruitment_manpower_plan` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `recruitment_manpower_plan_update_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `recruitment_manpower_plan_update_after` AFTER UPDATE ON `ww_recruitment_manpower_plan` FOR EACH ROW BEGIN
	IF NEW.`manpower_plan_status_id`=2 THEN
          -- 
          CALL sp_recruitment_manpower_plan_populate_approvers(NEW.`plan_id`, NEW.`user_id`);  
          --                   
       END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_recruitment_manpower_plan_position_new` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_position_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_position_insert_after` AFTER INSERT ON `ww_recruitment_manpower_plan_position_new` FOR EACH ROW BEGIN
        
        /* This will insert Year on ww_payroll_year */
        set @sPosition = '';
        set @iID = '';
        SET @sPosition = NEW.position;
        SET @iID = NEW.id;
        SET @nCount = 0;
        set @sPositionCode = '';
        SELECT COUNT(*) INTO @nCount FROM ww_users_position WHERE `amp_position_id` = @iID;        
        IF @sPosition IS NOT NULL AND @nCount = 0 THEN
		INSERT INTO ww_users_position (position_code,`position`,amp_position_id,status_id) VALUES (@sPositionCode,@sPosition,@iID,1);
        END IF;
                
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_recruitment_request` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `recruitment_request_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `recruitment_request_insert` BEFORE INSERT ON `ww_recruitment_request` FOR EACH ROW BEGIN
	IF NEW.`status_id`=2 THEN
          -- 
          CALL sp_recruitment_request_populate_approvers(NEW.`request_id`, NEW.`user_id`);  
          --                   
       END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_recruitment_request` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `recruitment_request_update` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `recruitment_request_update` BEFORE UPDATE ON `ww_recruitment_request` FOR EACH ROW BEGIN
	IF NEW.`status_id`=2 THEN
          -- 
          CALL sp_recruitment_request_populate_approvers(NEW.`request_id`, NEW.`user_id`);  
          --                   
       END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_system_chat` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `system_chat_before_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `system_chat_before_insert` BEFORE INSERT ON `ww_system_chat` FOR EACH ROW BEGIN
	SET NEW.`from_name` = (SELECT CONCAT(ww_users_profile.`lastname`,', ',ww_users_profile.`firstname`) FROM `ww_users_profile` WHERE `user_id`=NEW.from LIMIT 1);
	SET NEW.`to_name` = (SELECT CONCAT(ww_users_profile.`lastname`,', ',ww_users_profile.`firstname`) FROM `ww_users_profile` WHERE `user_id`=NEW.to LIMIT 1);        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_system_feeds` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `system_feeds_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `system_feeds_insert_before` BEFORE INSERT ON `ww_system_feeds` FOR EACH ROW BEGIN
        
        /* This will update header feeds table
           last change: 2015-08-10 initial, just update modification date
                        2015-08-10 
        */ 
        
        SET NEW.`display_name` = (SELECT IFNULL(`display_name`,'*') FROM `users_profile` WHERE `user_id`=NEW.`user_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_system_feeds` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `system_feeds_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `system_feeds_update_before` BEFORE UPDATE ON `ww_system_feeds` FOR EACH ROW BEGIN
        
        /* This will update header feeds table
           last change: 2015-08-10 initial, just update modification date
                        2015-08-10 
        */ 
        
        SET NEW.`display_name` = (SELECT IFNULL(`display_name`,'*') FROM `users_profile` WHERE `user_id`=NEW.`user_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_system_feeds_comments` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `system_feeds_comments_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `system_feeds_comments_insert_after` AFTER INSERT ON `ww_system_feeds_comments` FOR EACH ROW BEGIN
        
        /* This will update header feeds table
           last change: 2014-08-15 initial, just update modification date
                        2014-08-15 
        */ 
        UPDATE `ww_system_feeds` SET `modifiedon` = NOW()
        WHERE `id` = NEW.`id` LIMIT 1;
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_system_feeds_comments` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `system_feeds_comments_update_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `system_feeds_comments_update_after` AFTER UPDATE ON `ww_system_feeds_comments` FOR EACH ROW BEGIN
        
        /* This will update header feeds table
           last change: 2014-08-15 initial, just update modification date
                        2014-08-15 
        */ 
        UPDATE `ww_system_feeds` SET `modifiedon` = NOW()
        WHERE `id` = NEW.`id` LIMIT 1;
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_system_password_request` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `system_password_request_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `system_password_request_insert_before` BEFORE INSERT ON `ww_system_password_request` FOR EACH ROW BEGIN
    
       /* This will insert-update password request and email queue
          last change: 2014-04-25: initial
                       2014-04-25: 
       */ 
          
       SET NEW.`expiration` = DATE_ADD(NOW(), INTERVAL 24 HOUR);
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_system_password_request` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `system_password_request_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `system_password_request_insert_after` AFTER INSERT ON `ww_system_password_request` FOR EACH ROW BEGIN
    
       /* This will insert-update password request and email queue
          last change: 2014-04-25: initial
                       2015-09-13: system logo 
       */ 
                 
       SET @email_to = '';
       SET @email_subject = '';
       SET @email_body = '';
       
       -- get template format
       SELECT `subject`,`body` INTO @email_subject, @email_body
       FROM `ww_system_template`
       WHERE `template_id`=1 LIMIT 1;
       
       -- get profile nickname
       SELECT IFNULL(`nickname`,`firstname`) INTO @email_to
       FROM `users_profile`
       WHERE `user_id`=NEW.`user_id` LIMIT 1;
       
       -- {{link}}
       SET @url = get_config('System','URL');
	   IF RIGHT(TRIM(@url),1) <> '/' THEN
	      SET @url = CONCAT(TRIM(@url),'/');
	   END IF;
	   
       -- {{header/email logo}}
       SET @logo = get_config('System','print_logo'); 
	   IF TRIM(@logo) <> '' THEN
	      SET @logo = CONCAT(@url,@logo);
	   ELSE
	      SET @logo = CONCAT(@url,get_config('System','logo'));
	   END IF;
	   
       -- assign variables
       SET @email_body = REPLACE(@email_body, '{{system_url}}', @url);
       SET @email_body = REPLACE(@email_body, '{{system_logo}}', @logo);
       SET @email_body = REPLACE(@email_body, '{{nickname}}', @email_to);
       SET @email_body = REPLACE(@email_body, '{{expiration}}', NEW.`expiration`);
       SET @email_body = REPLACE(@email_body, '{{link}}', CONCAT(NEW.`link`,'&id=',NEW.`id`));
       
       -- insert final format
       INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
       SELECT NEW.`email`, @email_subject, @email_body;
       
       -- remove link for security
       -- UPDATE `ww_system_password_request` SET `link`='forwarded' WHERE `id`=NEW.`id` LIMIT 1;
       
       -- done
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_system_password_request` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `system_password_request_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `system_password_request_update_before` BEFORE UPDATE ON `ww_system_password_request` FOR EACH ROW BEGIN
    
       /* This will insert-update password request and user hash
          last change: 2014-04-25: initial
                       2015-09-13: system logo 
       */ 
       
       IF NEW.`confirmed` = 1 THEN
          
          -- INSERT INTO `ww_system_email_queue`
          SET @email_to = '';
          SET @email_subject = '';
          SET @email_body = '';
       
          -- get template format
          SELECT `subject`,`body` INTO @email_subject, @email_body
          FROM `ww_system_template`
          WHERE `template_id`=2 LIMIT 1;
       
          -- get profile nickname
          SELECT IFNULL(`nickname`,`firstname`) INTO @email_to
          FROM `users_profile`
          WHERE `user_id`=NEW.`user_id` LIMIT 1;
       
          -- {{link}}
          SET @url = get_config('System','URL');
	      IF RIGHT(TRIM(@url),1) <> '/' THEN
	         SET @url = CONCAT(TRIM(@url),'/');
	      END IF;
	      
          -- {{header/email logo}}
          SET @logo = get_config('System','print_logo'); 
	      IF TRIM(@logo) <> '' THEN
	         SET @logo = CONCAT(@url,@logo);
	      ELSE
	         SET @logo = CONCAT(@url,get_config('System','logo'));
	      END IF;
	   
          -- assign variables
          SET @email_body = REPLACE(@email_body, '{{system_url}}', @url);
          SET @email_body = REPLACE(@email_body, '{{system_logo}}', @logo);
          SET @email_body = REPLACE(@email_body, '{{nickname}}', @email_to);
          SET @email_body = REPLACE(@email_body, '{{randomize}}', NEW.`randomized`);
          SET @email_body = REPLACE(@email_body, '{{link}}', @url);
          -- insert final format
          INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
          SELECT NEW.`email`, @email_subject, @email_body;
       
       
       
          -- initialize values for security  
          SET NEW.`hash` = '';
          SET NEW.`link` = 'forwarded';        
          SET NEW.`confirmed` = 0;
          SET NEW.`randomized` = '';
          
       END IF;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_system_support` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `system_support_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `system_support_insert_after` AFTER INSERT ON `ww_system_support` FOR EACH ROW BEGIN
    
       /* This will insert-update time_record
          last change: 2016-02-10 initial
                       2014-02-10 
       */
          
       CALL `sp_system_support_email`(NEW.msg_id);
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_form_balance` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_form_balance_before_ins` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_form_balance_before_ins` BEFORE INSERT ON `ww_time_form_balance` FOR EACH ROW BEGIN
       
       
       -- [1] Compute available credit using accrual table
       SET NEW.`current` = ( SELECT IFNULL(SUM(tfba.`accrual`),0)
                             FROM `ww_time_form_balance_accrual` tfba
                             WHERE tfba.`leave_balance_id` = NEW.`id` AND tfba.`user_id` = NEW.`user_id` AND tfba.`deleted` = 0);
       
       -- SET NEW.`used` = (SELECT IFNULL(SUM(`day`),0) FROM `time_forms` WHERE `form_status_id`=6 AND `form_id`=NEW.`form_id` AND YEAR(`date_from`)=NEW.`year` AND `user_id`=NEW.`user_id`);       
       
       
       -- [2] Compute for the usage
       /*
       SET NEW.`used` = ( SELECT IFNULL(SUM(tfd.`day`),0)
                          FROM `time_forms` AS tf
                          JOIN ww_time_forms_date AS tfd ON tfd.forms_id = tf.forms_id
                          WHERE tf.`form_status_id` = 6 AND
                                tf.`form_id` = NEW.`form_id` AND
                                tf.`user_id`=NEW.`user_id` AND
                                tfd.leave_balance_id = NEW.id ) + 
                        ( SELECT IFNULL(SUM(tfd.`day`),0)
                          FROM `ww_time_forms` AS tf
                          LEFT JOIN ww_time_forms_date AS tfd ON tfd.forms_id = tf.forms_id
                          JOIN ww_time_forms_blanket tfb ON tfb.forms_id = tfd.`forms_id`
                          WHERE tf.`form_status_id` = 6 AND
                                tf.`form_id` = NEW.`form_id` AND
                                tfd.leave_balance_id = NEW.`id` );
       */
       SET NEW.`used` = ( SELECT IFNULL(SUM(tf.`day`),0)
                          FROM `time_forms` AS tf
                          WHERE tf.`form_status_id` = 6 AND
                                tf.`form_id` = NEW.`form_id` AND
                                tf.`user_id`=NEW.`user_id` AND 
                                YEAR(tf.`date_from`) = NEW.`year` ) +
                        ( SELECT IFNULL(SUM(tfd.`day`),0)
                          FROM `ww_time_forms` AS tf
                          LEFT JOIN ww_time_forms_date AS tfd ON tfd.forms_id = tf.forms_id
                          JOIN ww_time_forms_blanket tfb ON tfb.forms_id = tfd.`forms_id`
                          WHERE tf.`form_status_id` = 6 AND
                                tf.`form_id` = NEW.`form_id` AND
                                tfd.leave_balance_id = NEW.`id` );
       
       
        -- [3] Compute for the remaining credits
        SET NEW.`balance` = IF(IFNULL(NEW.`previous`,0) + 
                            IFNULL(NEW.`current`,0) - 
                            IFNULL(NEW.`used`,0) - 
                            IFNULL(NEW.`used_insert`,0) - 
                            IFNULL(NEW.`forfeited`,0) - 
                            IFNULL(NEW.`paid_unit`,0) > 0,IFNULL(NEW.`previous`,0) + 
                            IFNULL(NEW.`current`,0) - 
                            IFNULL(NEW.`used`,0) - 
                            IFNULL(NEW.`used_insert`,0) - 
                            IFNULL(NEW.`forfeited`,0) - 
                            IFNULL(NEW.`paid_unit`,0),0);
        
        
        -- [4] Just checking for the codes
        IF IFNULL(NEW.`form_code`,'') = '' THEN
           SET NEW.`form_code` = (SELECT IFNULL(`form_code`,'*') FROM `ww_time_form` WHERE `form_id`=NEW.`form_id` LIMIT 1);
        END IF;
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_form_balance` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_form_balance_before_upd` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_form_balance_before_upd` BEFORE UPDATE ON `ww_time_form_balance` FOR EACH ROW BEGIN
    
    
       -- [1] Compute available credit using accrual table
       SET NEW.`current` = ( SELECT IFNULL(SUM(tfba.`accrual`),0)
                             FROM `ww_time_form_balance_accrual` tfba
                             WHERE tfba.`leave_balance_id` = NEW.`id` AND tfba.`user_id` = NEW.`user_id` AND tfba.`deleted` = 0);
       
       -- SET NEW.`used` = (SELECT IFNULL(SUM(`day`),0) FROM `time_forms` 
       --                   WHERE `form_status_id`=6 AND `form_id`=NEW.`form_id` AND YEAR(`date_from`)=NEW.`year` AND `user_id`=NEW.`user_id`);       
       
       
       -- [2] Compute for the usage
       SET NEW.`used` = ( SELECT IFNULL(SUM(tf.`day`),0)
                          FROM `time_forms` AS tf
                          WHERE tf.`form_status_id` = 6 AND
                                tf.`form_id` = NEW.`form_id` AND
                                tf.`user_id`=NEW.`user_id` AND 
                                YEAR(tf.`date_from`) = NEW.`year` ) +
                        ( SELECT IFNULL(SUM(tfd.`day`),0)
                          FROM `ww_time_forms` AS tf
                          left JOIN ww_time_forms_date AS tfd ON tfd.forms_id = tf.forms_id
                          JOIN ww_time_forms_blanket tfb ON tfb.forms_id = tfd.`forms_id`
                          WHERE tf.`form_status_id` = 6 AND
                                tf.`form_id` = NEW.`form_id` AND
                                tfd.leave_balance_id = NEW.`id` );
       
              
       /*
       IF NEW.`form_code` = 'ADDL' THEN
          SET NEW.`used` = IFNULL(
              (
              SELECT IF( SUM(used)=0,NULL,SUM(used) ) 
              FROM ww_time_forms_ot_leave_used otleave 
              LEFT JOIN ww_time_forms tfs ON otleave.used_by_form = tfs.forms_id 
              WHERE `user_id`=NEW.`user_id` AND NEW.`form_code` = 'ADDL' AND tfs.form_status_id = 6 OR otleave.used_by_form = -1
              ) + NEW.used_insert  
              , 0);
          SET NEW.`current` = IFNULL(
	      (
              SELECT IF( SUM(otleave.credit)=0,NULL,SUM(otleave.credit) ) 
              FROM ww_time_forms_ot_leave otleave 
              LEFT JOIN ww_time_forms tfs ON otleave.forms_id = tfs.forms_id 
              WHERE `user_id`=NEW.`user_id` AND NEW.`form_code` = 'ADDL' AND tfs.form_status_id = 6
              ), 0);
        END IF;
        */
        
        
        -- [3] Compute for the remaining credits
        SET NEW.`balance` = IF(IFNULL(NEW.`previous`,0) + 
                            IFNULL(NEW.`current`,0) - 
                            IFNULL(NEW.`used`,0) - 
                            IFNULL(NEW.`used_insert`,0) - 
                            IFNULL(NEW.`forfeited`,0) - 
                            IFNULL(NEW.`paid_unit`,0) > 0,IFNULL(NEW.`previous`,0) + 
                            IFNULL(NEW.`current`,0) - 
                            IFNULL(NEW.`used`,0) - 
                            IFNULL(NEW.`used_insert`,0) - 
                            IFNULL(NEW.`forfeited`,0) - 
                            IFNULL(NEW.`paid_unit`,0),0);
        
        
        -- [4] Just checking for the codes
        IF IFNULL(NEW.`form_code`,'') = '' THEN
           SET NEW.`form_code` = (SELECT IFNULL(`form_code`,'*') FROM `ww_time_form` WHERE `form_id`=NEW.`form_id` LIMIT 1);
        END IF;
        
        
        -- [5] Time posting
        SET NEW.`modified_on` = NOW();
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_forms` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_forms_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_forms_insert_before` BEFORE INSERT ON `ww_time_forms` FOR EACH ROW BEGIN
    
       /* This will update necessary master table
          last change: 2014-04-25: initial
                       2014-04-26: populate approver/s
       */
       set NEW.form_code = (select form_code from ww_time_form where form_id = NEW.form_id);
       IF NEW.`form_status_id`=2 THEN
          -- 
          CALL sp_time_forms_populate_approvers(NEW.`forms_id`, NEW.`user_id`);   
          -- 
       END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_forms` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_forms_approval_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_forms_approval_insert` AFTER INSERT ON `ww_time_forms` FOR EACH ROW BEGIN
    
       /* This will insert-update time_forms & time_record_summary
          last change: 2014-02-22: initial
                       2014-02-22: prepare data after approval of application
                       2014-02-22: update leave balance
                       2014-02-22: update record summary
       */
       -- just to push the table's form_balance trigger to update balance field
       if NEW.form_status_id = 6 and NEW.display_name = 'Blanket' then
	update ww_time_form_balance tfb, ww_time_forms tf, ww_time_forms_date tfd
	set tfb.modified_on = now()
	where 	tfb.`year` = year(NEW.date_from) and 
		tfd.forms_id = tf.forms_id and 
		tfd.leave_balance_id = tfb.id and
		tfb.form_id = NEW.form_id;
       end if;
       
  --     UPDATE `ww_time_form_balance` SET modified_on = NOw()
   --    WHERE `year` = YEAR(NEW.`date_from`) AND `user_id`=NEW.`user_id`;
    
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_forms` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_forms_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_forms_update_before` BEFORE UPDATE ON `ww_time_forms` FOR EACH ROW BEGIN
    
       /* This will insert-update approver/s on application
          last change: 2014-04-26: initial
                       2014-04-26: populate approver/s if set to for approval
       */
       -- 
       SET NEW.`modified_on` = NOW();
       set NEw.form_code = (select form_code from ww_time_form where form_id = NEW.form_id);
       -- 
    
       IF NEW.`form_status_id`=2 THEN
          -- 
          CALL sp_time_forms_populate_approvers(NEW.`forms_id`, NEW.`user_id`);  
          --                   
       END IF;
       IF NEW.`form_status_id`=8 THEN
          -- 
          UPDATE `ww_time_forms_approver` SET `form_status_id`=8,`form_status`='Cancelled' WHERE `forms_id`=NEW.`forms_id`;  
          --                   
       END IF;          
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_forms` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_forms_approval` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_forms_approval` AFTER UPDATE ON `ww_time_forms` FOR EACH ROW BEGIN
    
       /* This will insert-update time_forms & time_record_summary
          last change: 2014-02-22: initial
                       2014-02-22: prepare data after approval of application
                       2014-02-22: update leave balance
                       2014-02-22: update record summary
                       2014-07-17: update aux shift and aux in/out
       */
       SET @approved = '';
       SELECT `form_status_id` INTO @approved
       FROM `ww_time_form_status` 
       WHERE `form_status`='Approved' AND `deleted`=0 LIMIT 1;
       
      INSERT INTO `logtable` (`log`) VALUES (CONCAT(NEW.`forms_id`,' ',NEW.`user_id`));
       
       -- [1] Update time record only on approved application
       IF NEW.form_status_id = @approved THEN
          CALL sp_time_forms_aux_shift(NEW.`form_code`, NEW.`user_id`, NEW.`forms_id`);
       END IF;
       
       
       -- [2] Update Leave Balance
       -- just to push the table's form_balance trigger to update balance field
       UPDATE `ww_time_form_balance` tfb, `ww_time_forms_date` tfd 
       SET tfb.modified_on = NOW()
       WHERE tfb.`id` = tfd.leave_balance_id AND tfd.forms_id = NEW.`forms_id` AND tfb.form_code = NEW.form_code AND `user_id`=NEW.`user_id`;
       
       -- YEAR(NEW.`date_from`) AND `user_id`=NEW.`user_id`;
       
       
       -- [3] Insert to Email Queue
       -- IF NEW.form_status_id = @approved THEN
       --    CALL sp_time_forms_email(NEW.`forms_id`);
       -- END IF;
       
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_forms_approver` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_forms_approver_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_forms_approver_insert_before` BEFORE INSERT ON `ww_time_forms_approver` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-17 initial
                        2014-07-17 
        */ 
        SET NEW.`display_name` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`user_id` LIMIT 1);
        SET NEW.`form_status` = (SELECT IFNULL(`form_status`,'*') FROM `ww_time_form_status` WHERE `form_status_id`=NEW.`form_status_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_forms_approver` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_forms_approver_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_forms_approver_update_before` BEFORE UPDATE ON `ww_time_forms_approver` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-07-17 initial
                        2015-05-05 change display name  
        */ 
		SET NEW.`display_name` = (SELECT IFNULL(`display_name`,'*') FROM `users` WHERE `user_id`=NEW.`user_id` LIMIT 1);
        SET NEW.`form_status` = (SELECT IFNULL(`form_status`,'*') FROM `ww_time_form_status` WHERE `form_status_id`=NEW.`form_status_id` LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_forms_approver` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_forms_approver_update_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_forms_approver_update_after` AFTER UPDATE ON `ww_time_forms_approver` FOR EACH ROW BEGIN
	   SET @appCount    = 0;
	   SET @appApproved = 0;
	   SET @appDeclined = 0;
	   
	   SELECT COUNT(*), SUM(IF(`form_status_id`=6,1,0)), SUM(IF(`form_status_id`=7,1,0)) 
	   INTO @appCount, @appApproved, @appDeclined
	   FROM `ww_time_forms_approver`
	   WHERE `forms_id`=NEW.`forms_id`;
	   
	   IF NEW.`form_status_id` != 8 THEN
		   UPDATE `time_forms`
		   SET
		      -- `form_status_id` = IF(@appCount=@appApproved, 6, IF(@appCount=@appDeclined, 7, IF(@appDeclined > 0, 7, IF(@appApproved > 0, 3, `form_status_id`)))),
		      `form_status_id` = IF(@appCount=@appApproved, 6, IF(@appCount=@appDeclined, 7, IF(@appDeclined > 0, 7, `form_status_id`))),
		      `date_approved` = IF(@appCount=@appApproved, NOW(), `date_approved`),
		      `date_declined` = IF(@appDeclined > 0, NOW(), `date_declined`)
		   WHERE 
		      `forms_id` = NEW.`forms_id`;
	   END IF;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_forms_blanket` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_forms_blanket_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_forms_blanket_insert_after` AFTER INSERT ON `ww_time_forms_blanket` FOR EACH ROW BEGIN
	declare formcode varchar(10);
	set formcode = (select form_code from ww_time_forms where forms_id = NEW.forms_id);
	
	if NEW.forms_id <> 0 then
		call sp_time_forms_aux_shift(formcode, NEW.user_id, NEW.forms_id);
	end if;
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_period` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_period_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_period_insert_before` BEFORE INSERT ON `ww_time_period` FOR EACH ROW BEGIN
    
       SET NEW.`period_year` = YEAR(NEW.`payroll_date`);
       SET NEW.`period_month` = MONTH(NEW.`payroll_date`);
       
       /*
       INSERT INTO `ww_time_period_log`
       (`period_id`, `partner_type_id`, `partner_type`, `proc_log`)
       SELECT a.`period_id`, a.`status_id`, a.`employment_status`, a.`proc_log`
       FROM
       (SELECT NEW.`period_id` `period_id`, p.status_id, pes.`employment_status`, COUNT(*) proc_log
       FROM `partners` p, `users_profile` up, `ww_partners_employment_status` pes
       WHERE 
          p.`user_id`=up.`user_id` AND 
          p.`status_id`=pes.`employment_status_id` AND
          up.`company_id`=NEW.`company_id`
       GROUP BY 1,2) a
       ON DUPLICATE KEY UPDATE `partner_type`=a.`employment_status`, `proc_log`=a.`proc_log`;
       */
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_period` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_period_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_period_update_before` BEFORE UPDATE ON `ww_time_period` FOR EACH ROW BEGIN
    
       SET NEW.`period_year` = YEAR(NEW.`payroll_date`);
       SET NEW.`period_month` = MONTH(NEW.`payroll_date`);
    
       IF IFNULL(NEW.`pop_dates`,0) = 1 THEN
          -- IF NEW.`cutoff` <= CURDATE() THEN
             CALL sp_time_period_populate(NEW.`date_from`,NEW.`date_to`,NEW.`company_id`); 
          -- END IF;
       END IF;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_record` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_record_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_record_insert_before` BEFORE INSERT ON `ww_time_record` FOR EACH ROW BEGIN
    
       /* This will insert-update time_record textual
          last change: 2014-02-20 initial
                       2014-02-21 shift name and biometrics
       */
       
       DECLARE shiftname VARCHAR(32) DEFAULT '';
       DECLARE shiftid INT(11) DEFAULT 0;
       DECLARE bio VARCHAR(8) DEFAULT '';
       
       -- [1] Get references
       SELECT `biometric`,`shift_id` INTO bio,shiftid 
       FROM `ww_partners` WHERE `user_id` = NEW.user_id LIMIT 1;
       
       -- [2] Assign values
       IF IFNULL(NEW.shift_id,0) = 0 THEN  -- override assignment if not passed correctly
          SET NEW.shift_id = shiftid;
       END IF;
       
       if NEW.aux_shift_id <> 0 then
	  set NEW.aux_shift = (select shift from ww_time_shift where shift_id = NEW.aux_shift_id);
       end if;
       
       SELECT `shift` INTO shiftname 
       FROM `ww_time_shift` WHERE `shift_id` = NEW.`shift_id` LIMIT 1;
       
       -- [3] Assign values
       SET NEW.shift = shiftname;
       SET NEW.biometric = bio;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_record` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_record_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_record_update_before` BEFORE UPDATE ON `ww_time_record` FOR EACH ROW BEGIN
    
       /* This will insert-update time_record textual
          last change: 2014-02-20 initial
                       2014-02-20 shift name and biometrics
                       2014-07-19 aux shift name
       */       
        
       SET NEW.shift = (SELECT IFNULL(`shift`,'') FROM `ww_time_shift` WHERE `shift_id` = NEW.shift_id LIMIT 1);
       SET NEW.biometric = (SELECT IFNULL(`biometric`,'') FROM `ww_partners` WHERE `user_id` = NEW.user_id LIMIT 1);
       
       IF NEW.aux_shift_id <> 0 THEN
          SET NEW.aux_shift = (SELECT IFNULL(`shift`,'') FROM `ww_time_shift` WHERE `shift_id` = NEW.aux_shift_id LIMIT 1);
       END IF;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_record_raw` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_record_raw_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_record_raw_insert_before` BEFORE INSERT ON `ww_time_record_raw` FOR EACH ROW BEGIN
    
       /* This will insert-update time_record_raw
          last change: 2014-02-21 initial
                       2014-02-22 prepare date if blank, to attend uploading even if with checktime only 
       */
       DECLARE userid INT(11) DEFAULT 0;
       SELECT `user_id` INTO userid FROM `ww_partners` WHERE `biometric`=NEW.`biometric` AND `deleted`=0 LIMIT 1;
       
       IF IFNULL(userid,0) <> 0 THEN
          SET NEW.`user_id` = userid;
          -- SET NEW.`processed` = 1;
       END IF;
       
       IF IFNULL(NEW.`date`,'0000-00-00') = '0000-00-00' THEN
          SET NEW.`date` = DATE(NEW.`checktime`);
       END IF;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_record_raw` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_record_raw_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_record_raw_insert_after` AFTER INSERT ON `ww_time_record_raw` FOR EACH ROW BEGIN
    
       /* This will insert-update time_record
          last change: 2014-02-21 initial
                       2014-05-07 move codes to sp_time_record_raw_process
       */
          
       IF IFNULL(NEW.`processed`,0) = 0 THEN
          IF IFNULL(NEW.`user_id`,0) <> 0 THEN
             SET @news = 1;
             CALL sp_time_record_raw_process(NEW.`user_id`, NEW.`date`, NEW.`checktime`);
          END IF;
       END IF;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_record_raw` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_record_raw_update_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_record_raw_update_after` AFTER UPDATE ON `ww_time_record_raw` FOR EACH ROW BEGIN
    
       /* This will insert-update time_record
          last change: 2015-09-16 run sp_time_record_raw_process
       */
          
       IF IFNULL(NEW.`processed`,0) = 0 THEN
          IF IFNULL(NEW.`user_id`,0) <> 0 THEN
             SET @news = 1;
             CALL sp_time_record_raw_process(NEW.`user_id`, NEW.`date`, NEW.`checktime`);
          END IF;
       END IF;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_record_summary` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_record_summary_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_record_summary_insert_after` AFTER INSERT ON `ww_time_record_summary` FOR EACH ROW BEGIN
    
	UPDATE `ww_time_record` SET `processed`=1 WHERE `user_id`=NEW.`user_id` AND `date`=NEW.`date`;
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_shift` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_shift_class_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_shift_class_insert_before` BEFORE INSERT ON `ww_time_shift` FOR EACH ROW BEGIN
        
	   
          CALL sp_time_shift_class_company(NEW.`shift_id`);
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_shift` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_shift_class_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_shift_class_update_before` BEFORE UPDATE ON `ww_time_shift` FOR EACH ROW BEGIN
        
        /* This will update-update display names accross all modules 
           last change: 2014-07-18 initial
                        2014-07-18 
        */ 
          CALL sp_time_shift_class_company(NEW.`shift_id`);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_shift_apply_to_id` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_shift_apply_to_id_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_shift_apply_to_id_insert_after` AFTER INSERT ON `ww_time_shift_apply_to_id` FOR EACH ROW BEGIN
    
       /* This will insert-update time_record
          last change: 2016-04-21 initial
                       2014-04-21 automatic saving to time-shift-class
       */
      
         IF (NEW.shift_id != '') THEN
           CALL sp_time_shift_process(NEW.`shift_id`);
         END IF;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_shift_class_company_department` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_shift_class_company_department_upd_aft` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_shift_class_company_department_upd_aft` BEFORE UPDATE ON `ww_time_shift_class_company_department` FOR EACH ROW BEGIN
	
	SET NEW.class_code = (SELECT class_code FROM ww_time_shift_class WHERE class_id = NEW.class_id);
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_shift_weekly_calendar` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_shift_weekly_calendar_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_shift_weekly_calendar_insert_before` BEFORE INSERT ON `ww_time_shift_weekly_calendar` FOR EACH ROW BEGIN
    
       SET NEW.`shift` = (SELECT IFNULL(`shift`,'*') FROM `ww_time_shift` WHERE `shift_id`=NEW.shift_id LIMIT 1);
       SET NEW.`week_name` = IF(NEW.`week_no`=1,'Sunday',
                             IF(NEW.`week_no`=2,'Monday',
                             IF(NEW.`week_no`=3,'Tuesday',
                             IF(NEW.`week_no`=4,'Wednesday',
                             IF(NEW.`week_no`=5,'Thursday',
                             IF(NEW.`week_no`=6,'Friday',
                             IF(NEW.`week_no`=7,'Saturday','')))))));
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_time_shift_weekly_calendar` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `time_shift_weekly_calendar_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `time_shift_weekly_calendar_update_before` BEFORE UPDATE ON `ww_time_shift_weekly_calendar` FOR EACH ROW BEGIN
    
       SET NEW.`shift` = (SELECT IFNULL(`shift`,'*') FROM `ww_time_shift` WHERE `shift_id`=NEW.shift_id LIMIT 1);
       SET NEW.`week_name` = IF(NEW.`week_no`=1,'Sunday',
                             IF(NEW.`week_no`=2,'Monday',
                             IF(NEW.`week_no`=3,'Tuesday',
                             IF(NEW.`week_no`=4,'Wednesday',
                             IF(NEW.`week_no`=5,'Thursday',
                             IF(NEW.`week_no`=6,'Friday',
                             IF(NEW.`week_no`=7,'Saturday','')))))));
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_company` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_company_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_company_insert_before` BEFORE INSERT ON `ww_users_company` FOR EACH ROW BEGIN
        
        SET NEW.`city` = (SELECT IFNULL(city,'*') FROM `ww_cities` WHERE city_id=NEW.`city_id` LIMIT 1);
        SET NEW.`country` = (SELECT IFNULL(`short_name`,'*') FROM `ww_countries` WHERE `country_id`=NEW.country_id LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_company` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_company_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_company_update_before` BEFORE UPDATE ON `ww_users_company` FOR EACH ROW BEGIN
        
        SET NEW.`city` = (SELECT IFNULL(city,'*') FROM `ww_cities` WHERE city_id=NEW.`city_id` LIMIT 1);
        SET NEW.`country` = (SELECT IFNULL(`short_name`,'*') FROM `ww_countries` WHERE `country_id`=NEW.country_id LIMIT 1);
        
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_department` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_department_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_department_insert` BEFORE INSERT ON `ww_users_department` FOR EACH ROW BEGIN
    
       SET @immediate = '';
       SET @immediate_position_id = '';
       SET @immediate_position = '';
       SET @division = '';
       
       SELECT IFNULL(`display_name`,'') INTO @immediate FROM `users` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position_id`,'') INTO @immediate_position_id FROM `users_profile` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position`,'') INTO @immediate_position FROM `users_position` WHERE `position_id`=@immediate_position_id LIMIT 1;
       SELECT IFNULL(`division`,'') INTO @division FROM `ww_users_division` WHERE `division_id`=NEW.`division_id` LIMIT 1;
       
       
       SET NEW.`immediate` = @immediate;
       SET NEW.`immediate_position_id` = @immediate_position_id;
       SET NEW.`immediate_position` = @immediate_position;
       SET NEW.`division` = @division;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_department` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_department_update` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_department_update` BEFORE UPDATE ON `ww_users_department` FOR EACH ROW BEGIN
    
       SET @immediate = '';
       SET @immediate_position_id = '';
       SET @immediate_position = '';
       SET @division = '';
       
       SELECT IFNULL(`display_name`,'') INTO @immediate FROM `users` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position_id`,'') INTO @immediate_position_id FROM `users_profile` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position`,'') INTO @immediate_position FROM `users_position` WHERE `position_id`=@immediate_position_id LIMIT 1;
       SELECT IFNULL(`division`,'') INTO @division FROM `ww_users_division` WHERE `division_id`=NEW.`division_id` LIMIT 1;
       
       
       SET NEW.`immediate` = @immediate;
       SET NEW.`immediate_position_id` = @immediate_position_id;
       SET NEW.`immediate_position` = @immediate_position;
       SET NEW.`division` = @division;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_division` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_division_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_division_insert` BEFORE INSERT ON `ww_users_division` FOR EACH ROW BEGIN
    
       SET @immediate = '';
       SET @immediate_position_id = '';
       SET @immediate_position = '';
       SET @division = '';
       
       SELECT IFNULL(`display_name`,'') INTO @immediate FROM `users` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position_id`,'') INTO @immediate_position_id FROM `users_profile` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position`,'') INTO @immediate_position FROM `users_position` WHERE `position_id`=@immediate_position_id LIMIT 1;
       
       
       SET NEW.`immediate` = @immediate;
       SET NEW.`position_id` = @immediate_position_id;
       SET NEW.`position` = @immediate_position;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_division` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_division_update` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_division_update` BEFORE UPDATE ON `ww_users_division` FOR EACH ROW BEGIN
    
       SET @immediate = '';
       SET @immediate_position_id = '';
       SET @immediate_position = '';
       SET @division = '';
       
       SELECT IFNULL(`display_name`,'') INTO @immediate FROM `users` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position_id`,'') INTO @immediate_position_id FROM `users_profile` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position`,'') INTO @immediate_position FROM `users_position` WHERE `position_id`=@immediate_position_id LIMIT 1;
       
       
       SET NEW.`immediate` = @immediate;
       SET NEW.`position_id` = @immediate_position_id;
       SET NEW.`position` = @immediate_position;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_position` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_position_insert` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_position_insert` BEFORE INSERT ON `ww_users_position` FOR EACH ROW BEGIN
    
       SET @immediate = '';
       SET @immediate_position_id = '';
       SET @immediate_position = '';
       
       SELECT IFNULL(`display_name`,'') INTO @immediate FROM `users` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position_id`,'') INTO @immediate_position_id FROM `users_profile` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position`,'') INTO @immediate_position FROM `users_position` WHERE `position_id`=@immediate_position_id LIMIT 1;
       
       
       SET NEW.`immediate` = @immediate;
       SET NEW.`immediate_position_id` = @immediate_position_id;
       SET NEW.`immediate_position` = @immediate_position;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_position` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_position_update` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_position_update` BEFORE UPDATE ON `ww_users_position` FOR EACH ROW BEGIN
    
       SET @immediate = '';
       SET @immediate_position_id = '';
       SET @immediate_position = '';
       
       SELECT IFNULL(`display_name`,'') INTO @immediate FROM `users` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position_id`,'') INTO @immediate_position_id FROM `users_profile` WHERE `user_id`=NEW.`immediate_id` LIMIT 1;
       SELECT IFNULL(`position`,'') INTO @immediate_position FROM `users_position` WHERE `position_id`=@immediate_position_id LIMIT 1;
       
       
       SET NEW.`immediate` = @immediate;
       SET NEW.`immediate_position_id` = @immediate_position_id;
       SET NEW.`immediate_position` = @immediate_position;
       
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_profile` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_profile_insert_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_profile_insert_before` BEFORE INSERT ON `ww_users_profile` FOR EACH ROW BEGIN
        
         
        SET NEW.`company` = (SELECT IFNULL(`company`,'') FROM `ww_users_company` WHERE `company_id`=NEW.company_id LIMIT 1);
        SET NEW.`v_group` = (SELECT IFNULL(`group`,'') FROM `ww_users_group` WHERE `group_id`=NEW.group_id LIMIT 1);
        SET NEW.`v_division` = (SELECT IFNULL(`division`,'') FROM `ww_users_division` WHERE `division_id`=NEW.division_id LIMIT 1);
        SET NEW.`v_department` = (SELECT IFNULL(`department`,'') FROM `ww_users_department` WHERE `department_id`=NEW.department_id LIMIT 1);
        SET NEW.`v_position` = (SELECT IFNULL(`position`,'') FROM `ww_users_position` WHERE `position_id`=NEW.position_id LIMIT 1);
        SET NEW.`v_reports_to` = (SELECT IFNULL(CONCAT(NEW.`lastname`,', ',NEW.`firstname`,' ',IFNULL(NEW.`suffix`,'')),'') FROM `ww_users` WHERE `user_id`=NEW.reports_to_id LIMIT 1);
        SET NEW.`v_project_hr` = (SELECT IFNULL(CONCAT(NEW.`lastname`,', ',NEW.`firstname`,' ',IFNULL(NEW.`suffix`,'')),'') FROM `ww_users` WHERE `user_id`=NEW.project_hr_id LIMIT 1);
	SET NEW.`v_specialization` = (SELECT IFNULL(`specialization`,'') FROM `ww_users_specialization` WHERE `specialization_id`=NEW.specialization_id LIMIT 1);
	SET NEW.`v_location` = (SELECT IFNULL(`location`,'') FROM `ww_users_location` WHERE `location_id`=NEW.location_id LIMIT 1);
	SET NEW.`v_project` = (SELECT IFNULL(`project`,'') FROM `ww_users_project` WHERE `project_id`=NEW.project_id LIMIT 1);
        SET NEW.`v_section` = (SELECT IFNULL(`section`,'') FROM `ww_users_section` WHERE `section_id`=NEW.section_id LIMIT 1);
        SET NEW.`v_branch` = (SELECT IFNULL(`branch`,'') FROM `ww_users_branch` WHERE `branch_id`=NEW.branch_id LIMIT 1);
        SET NEW.`v_credit_setup` = (SELECT IFNULL(`class`,'') FROM `ww_time_form_balance_credit_class` WHERE `class_id`=NEW.credit_setup_id LIMIT 1);
        
        UPDATE `ww_users` 
        SET 
           `company_id` = NEW.company_id,
           `full_name` = CONCAT(NEW.`lastname`,', ',NEW.`firstname`,' ',IFNULL(NEW.`suffix`,'')),
           `display_name` = CONCAT(NEW.`lastname`,', ',NEW.`firstname`)
        WHERE `user_id` = NEW.`user_id`;
        
        UPDATE `ww_partners`
        SET 
           `alias` = CONCAT(NEW.`lastname`,', ',NEW.`firstname`,' ',IFNULL(NEW.`suffix`,''))
        WHERE `user_id` = NEW.`user_id`;
                                                                
    END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_profile` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_profile_insert_after` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_profile_insert_after` AFTER INSERT ON `ww_users_profile` FOR EACH ROW BEGIN 
        
        SET @coid = NEW.`company_id`;
        INSERT INTO ww_payroll_partners (user_id, company_id) VALUES (NEW.user_id, NEW.company_id)
        ON DUPLICATE KEY UPDATE company_id=IFNULL(company_id,@coid),`modified_on`=NOW(),`deleted`=0;
        
   END */$$


DELIMITER ;

/* Trigger structure for table `ww_users_profile` */

DELIMITER $$

/*!50003 DROP TRIGGER*//*!50032 IF EXISTS */ /*!50003 `users_profile_update_before` */$$

/*!50003 CREATE */ /*!50017 DEFINER = 'root'@'localhost' */ /*!50003 TRIGGER `users_profile_update_before` BEFORE UPDATE ON `ww_users_profile` FOR EACH ROW BEGIN
        
        /* This will insert-update display names accross all modules 
           last change: 2014-02-01 initial
                        2014-02-14 based on existing client (Surname, Given Name Suffix)
        */ 
        SET NEW.`company` = (SELECT IFNULL(`company`,'') FROM `ww_users_company` WHERE `company_id`=NEW.company_id LIMIT 1);
        SET NEW.`v_group` = (SELECT IFNULL(`group`,'') FROM `ww_users_group` WHERE `group_id`=NEW.group_id LIMIT 1);
        SET NEW.`v_division` = (SELECT IFNULL(`division`,'') FROM `ww_users_division` WHERE `division_id`=NEW.division_id LIMIT 1);
        SET NEW.`v_department` = (SELECT IFNULL(`department`,'') FROM `ww_users_department` WHERE `department_id`=NEW.department_id LIMIT 1);
        SET NEW.`v_position` = (SELECT IFNULL(`position`,'') FROM `ww_users_position` WHERE `position_id`=NEW.position_id LIMIT 1);
        SET NEW.`v_reports_to` = (SELECT IFNULL(CONCAT(NEW.`lastname`,', ',NEW.`firstname`,' ',IFNULL(NEW.`suffix`,'')),'') FROM `ww_users` WHERE `user_id`=NEW.reports_to_id LIMIT 1);
        SET NEW.`v_project_hr` = (SELECT IFNULL(CONCAT(NEW.`lastname`,', ',NEW.`firstname`,' ',IFNULL(NEW.`suffix`,'')),'') FROM `ww_users` WHERE `user_id`=NEW.project_hr_id LIMIT 1);
	SET NEW.`v_specialization` = (SELECT IFNULL(`specialization`,'') FROM `ww_users_specialization` WHERE `specialization_id`=NEW.specialization_id LIMIT 1);
	SET NEW.`v_location` = (SELECT IFNULL(`location`,'') FROM `ww_users_location` WHERE `location_id`=NEW.location_id LIMIT 1);
	SET NEW.`v_project` = (SELECT IFNULL(`project`,'') FROM `ww_users_project` WHERE `project_id`=NEW.project_id LIMIT 1);
        SET NEW.`v_section` = (SELECT IFNULL(`section`,'') FROM `ww_users_section` WHERE `section_id`=NEW.section_id LIMIT 1);
        SET NEW.`v_branch` = (SELECT IFNULL(`branch`,'') FROM `ww_users_branch` WHERE `branch_id`=NEW.branch_id LIMIT 1);
        SET NEW.`v_credit_setup` = (SELECT IFNULL(`class`,'') FROM `ww_time_form_balance_credit_class` WHERE `class_id`=NEW.credit_setup_id LIMIT 1);
                
        UPDATE `ww_users` 
        SET 
           `company_id` = NEW.company_id,
           `full_name` = CONCAT(NEW.`lastname`,', ',NEW.`firstname`,' ',IFNULL(NEW.`suffix`,'')),
           `display_name` = CONCAT(NEW.`lastname`,', ',NEW.`firstname`)
        WHERE `user_id` = NEW.`user_id`;
        
        /*UPDATE `ww_partners`
        SET 
           `alias` = CONCAT(NEW.`lastname`,', ',NEW.`firstname`,' ',IFNULL(NEW.`suffix`,''))
        WHERE `user_id` = NEW.`user_id`;*/
        
        -- LATER!!!!
        -- UPDATE `ww_partners`
        -- UPDATE `ww_users_division`
        -- UPDATE `ww_users_department`
        -- UPDATE `ww_users_group`
        -- UPDATE `ww_users_position`
        -- UPDATE `ww_time_forms`
        
    END */$$


DELIMITER ;

/*!50106 set global event_scheduler = 1*/;

/* Event structure for event `archive_expired_sessions` */

/*!50106 DROP EVENT IF EXISTS `archive_expired_sessions`*/;

DELIMITER $$

/*!50106 CREATE EVENT `archive_expired_sessions` ON SCHEDULE EVERY 6 HOUR STARTS '2014-02-22 23:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
    SET @expired = 0;
    
    DELETE FROM `ww_sessions` WHERE FROM_UNIXTIME(`last_activity`) < DATE_ADD(NOW(), INTERVAL -6 HOUR);
    DELETE FROM `ww_sessions` WHERE user_data = '';
    -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `archive_system_email` */

/*!50106 DROP EVENT IF EXISTS `archive_system_email`*/;

DELIMITER $$

/*!50106 CREATE EVENT `archive_system_email` ON SCHEDULE EVERY 1 DAY STARTS '2015-05-19 04:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
   
   START TRANSACTION; 
   
   INSERT INTO `ww_ww_system_email_queue`
   SELECT * FROM `ww_system_email_queue` WHERE `status`='sent' AND `sent_on` < CURDATE() - INTERVAL 5 DAY;
   
   DELETE FROM `ww_system_email_queue` WHERE `status`='sent' AND `sent_on` < CURDATE() - INTERVAL 5 DAY;
   
   COMMIT;
   -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `archive_system_feeds` */

/*!50106 DROP EVENT IF EXISTS `archive_system_feeds`*/;

DELIMITER $$

/*!50106 CREATE EVENT `archive_system_feeds` ON SCHEDULE EVERY 1 DAY STARTS '2014-10-31 05:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
   
   START TRANSACTION; 
   
   INSERT INTO `ww_ww_system_feeds`
   SELECT * FROM `ww_system_feeds` WHERE `createdon` < CURDATE() - INTERVAL 1 MONTH;
   
   DELETE FROM `ww_system_feeds` WHERE `createdon` < CURDATE() - INTERVAL 1 MONTH;
   
   COMMIT;
   -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `archive_time_record` */

/*!50106 DROP EVENT IF EXISTS `archive_time_record`*/;

DELIMITER $$

/*!50106 CREATE EVENT `archive_time_record` ON SCHEDULE EVERY 1 DAY STARTS '2015-05-19 04:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
    DECLARE FromDate DATETIME;
    DECLARE ToDate DATETIME;
    
    START TRANSACTION;
    -- [1] Get the range of records to transfer
    SELECT MIN(`raw_id`), MAX(`raw_id`) INTO FromDate, ToDate
    FROM `ww_time_record_raw`
    WHERE `processed`=1;
    
    -- [2] Start the transfer of records
    INSERT INTO `ww_ww_time_record_raw` (
       `raw_id`,
       `user_id`,
       `biometric`,
       `date`,
       `location_id`,
       `device_id`,
       `checktime`,
       `checktype`,
       `processed`,
       `archive`
    )
    SELECT
       `raw_id`,
       `user_id`,
       `biometric`,
       `date`,
       `location_id`,
       `device_id`,
       `checktime`,
       `checktype`,
       `processed`,
       NOW()
    FROM `time_record_raw`
    WHERE `raw_id` BETWEEN FromDate AND ToDate;
    
    -- [3] Cleanup
    DELETE FROM `ww_time_record_raw` WHERE `raw_id` BETWEEN FromDate AND ToDate;
    
    COMMIT;
    -- End of this Event
     
	END */$$
DELIMITER ;

/* Event structure for event `archive_time_record_raw_logs` */

/*!50106 DROP EVENT IF EXISTS `archive_time_record_raw_logs`*/;

DELIMITER $$

/*!50106 CREATE EVENT `archive_time_record_raw_logs` ON SCHEDULE EVERY 1 DAY STARTS '2015-05-19 04:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
    DECLARE FromDate DATETIME;
    DECLARE ToDate DATETIME;
    
    START TRANSACTION;
    -- [1] Get the range of records to transfer
    SELECT MIN(`raw_id`), MAX(`raw_id`) INTO FromDate, ToDate
    FROM `ww_time_record_raw`
    WHERE `processed`=1;
    
    -- [2] Start the transfer of records
    INSERT INTO `ww_ww_time_record_raw` (
       `raw_id`,
       `user_id`,
       `biometric`,
       `date`,
       `location_id`,
       `device_id`,
       `checktime`,
       `checktype`,
       `processed`,
       `archive`
    )
    SELECT
       `raw_id`,
       `user_id`,
       `biometric`,
       `date`,
       `location_id`,
       `device_id`,
       `checktime`,
       `checktype`,
       `processed`,
       NOW()
    FROM `time_record_raw`
    WHERE `raw_id` BETWEEN FromDate AND ToDate;
    
    -- [3] Cleanup
    DELETE FROM `ww_time_record_raw` WHERE `raw_id` BETWEEN FromDate AND ToDate;
    
    COMMIT;
    -- End of this Event
     
	END */$$
DELIMITER ;

/* Event structure for event `process_change_password` */

/*!50106 DROP EVENT IF EXISTS `process_change_password`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_change_password` ON SCHEDULE EVERY 1 WEEK STARTS '2015-08-17 09:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
    CALL sp_partners_change_password();
       
          
	END */$$
DELIMITER ;

/* Event structure for event `process_partners_birthday_reminder` */

/*!50106 DROP EVENT IF EXISTS `process_partners_birthday_reminder`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_partners_birthday_reminder` ON SCHEDULE EVERY 1 DAY STARTS '2014-11-22 09:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
   /* must send email reminder also : pending */
   
   CALL sp_partners_sms_bday(); -- for partners sns sending
   
   CALL sp_partners_email_bday(); -- email sending
   
   -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `process_partners_memo` */

/*!50106 DROP EVENT IF EXISTS `process_partners_memo`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_partners_memo` ON SCHEDULE EVERY 1 DAY STARTS '2014-08-07 07:30:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
   /* populate selected recipients */
   CALL `sp_partners_memo_process`();
   
   -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `process_partners_movement` */

/*!50106 DROP EVENT IF EXISTS `process_partners_movement`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_partners_movement` ON SCHEDULE EVERY 1 DAY STARTS '2015-08-10 07:30:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
   /* POPULATE records of intended recipients */
   
   -- [1] 
   -- 2017-04-04: TEMPORARILY DISABLE
   CALL `sp_partners_movements`();
   
   -- [2]
   CALL `sp_partners_movement_anniversary`();
   
   -- [3]
   -- CALL `sp_partners_email_anniversary`();
   
   -- [4]
   -- CALL `sp_partners_clearance_email_notification`();
   
   -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `process_partners_reminder` */

/*!50106 DROP EVENT IF EXISTS `process_partners_reminder`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_partners_reminder` ON SCHEDULE EVERY 1 DAY STARTS '2015-08-17 08:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
    /* EMAIL REMINDER */
    
    -- [1] Remind user thru Email with default password
    -- 2017-04-04: Temporarily disable    
    -- CALL sp_partners_change_password_reminder();
    
    -- [2] 
    -- CALL sp_partners_sms_bday();
   
    -- [3] 
    -- CALL sp_partners_email_bday();
    
    -- [4] 
    CALL `sp_partners_memo_process`();
    
    -- [5]
    CALL `sp_partners_personal_process()`;
    
	END */$$
DELIMITER ;

/* Event structure for event `process_time_forms_reminder` */

/*!50106 DROP EVENT IF EXISTS `process_time_forms_reminder`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_time_forms_reminder` ON SCHEDULE EVERY 1 DAY STARTS '2014-10-29 09:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
   /* send email reminder */
   CALL `sp_time_forms_reminder`;
   
   -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `process_time_form_balance` */

/*!50106 DROP EVENT IF EXISTS `process_time_form_balance`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_time_form_balance` ON SCHEDULE EVERY 1 DAY STARTS '2016-02-16 02:00:01' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
   
   -- [2017.05.03]
   
   -- [1] EVERY 12MN
   CALL `sp_time_form_balance_process_credit`();
   
   
END */$$
DELIMITER ;

/* Event structure for event `process_time_periods` */

/*!50106 DROP EVENT IF EXISTS `process_time_periods`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_time_periods` ON SCHEDULE EVERY 1 HOUR STARTS '2014-08-20 06:59:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
   -- 
   -- [1] Process time-record every hour
   -- 
   CALL `sp_time_period_process_all`();
   
   -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `process_time_period_populate` */

/*!50106 DROP EVENT IF EXISTS `process_time_period_populate`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_time_period_populate` ON SCHEDULE EVERY 1 DAY STARTS '2014-03-15 06:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
    DECLARE p1 INT(11) DEFAULT 0;    
    
    -- [1] Prepare dates to be executed for new partners
    CALL `sp_time_record_insert_user`();
    -- [2] Prepare dates to be executed for time-record
    SELECT COUNT(`period_id`) INTO p1
    FROM `ww_time_period`
    WHERE `deleted` = 0 AND CURDATE() BETWEEN `date_from` AND `date_to`;
        
    IF p1 > 0 THEN
       CALL sp_time_record_insert(CURDATE());
    END IF;
    
    -- Remove: 2016-06-26
    -- [1]
    -- when trying to enable/disable event
    -- --
    -- SET GLOBAL event_scheduler = 1;
    -- 
    -- [2]
    -- recording this sample of prepare,execute and deallocate
    -- --
    -- PREPARE stpp FROM 'CALL sp_time_period_populate(?,?,?)';
    -- SET @a = '2014-04-16';
    -- SET @b = '2014-04-30';
    -- SET @c = 2;
    -- EXECUTE stpp USING @a, @b, @c;
    -- DEALLOCATE PREPARE stpp;
    -- 
    -- [2]
    -- DECLARE cmd CHAR(255);
    -- DECLARE result CHAR(255);
    -- SET cmd = CONCAT('curl https://pubsub.pubnub.com/publish/demo/demo/0/mysql_triggers/0/%22',p1,',',p2,',',p3,'%22');
    -- SET result = sys_eval(cmd);
          
	END */$$
DELIMITER ;

/* Event structure for event `process_time_period_populate_next` */

/*!50106 DROP EVENT IF EXISTS `process_time_period_populate_next`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_time_period_populate_next` ON SCHEDULE EVERY 1 MONTH STARTS '2014-09-01 04:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
    DECLARE p1 DATE;
    DECLARE p2 DATE;
    
    -- [1] Prepare dates to be executed
    SET p1 = ((CURDATE()) - INTERVAL 1 DAY);
    SET p2 = (CURDATE() + INTERVAL 1 MONTH);
    
    -- [2] Create inclusive dates 
    INSERT INTO `ww_system_messages` (msg_code,msg) VALUES ('EVENT_TIME_PERIOD',CONCAT(p1,'-',p2));
    CALL sp_time_period_populate(p1, p2, 0);
       
          
	END */$$
DELIMITER ;

/* Event structure for event `process_time_period_reminder` */

/*!50106 DROP EVENT IF EXISTS `process_time_period_reminder`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_time_period_reminder` ON SCHEDULE EVERY 1 DAY STARTS '2014-10-28 07:00:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
   /* send email reminder */
   CALL `sp_time_period_reminder`;
   
   -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `process_time_record_reminder` */

/*!50106 DROP EVENT IF EXISTS `process_time_record_reminder`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_time_record_reminder` ON SCHEDULE EVERY 1 DAY STARTS '2015-08-17 07:15:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
   /* SEND REMINDER */
   
   -- For Partners To SMS
   -- CALL `sp_time_record_sms_reminder_all`; 
   
   -- For Partners To Email
   -- request by Joyce to disable: 2016-03-30
   -- CALL sp_time_record_reminder(); 
   
   -- For Technical Partners and Timekeeper
   IF DAYNAME(CURDATE()-INTERVAL 1 DAY) NOT IN ('Saturday','Sunday') THEN
      CALL sp_time_server_reminder(); 
   END IF;
   
   -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `process_time_reminder` */

/*!50106 DROP EVENT IF EXISTS `process_time_reminder`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_time_reminder` ON SCHEDULE EVERY 1 DAY STARTS '2014-10-29 07:15:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
   /* REMINDER */
   
   -- [1] Remind the timekeeper to create a period
   CALL `sp_time_period_reminder`;
   
   -- [2] Remind the approver of pending applications by his/her subordinates
   CALL `sp_time_forms_reminder`;
   
   
   -- [3] For Partners To SMS
   -- CALL `sp_time_record_sms_reminder_all`; 
   
   
   -- End of this Event
     
END */$$
DELIMITER ;

/* Event structure for event `process_time_reminder_user` */

/*!50106 DROP EVENT IF EXISTS `process_time_reminder_user`*/;

DELIMITER $$

/*!50106 CREATE EVENT `process_time_reminder_user` ON SCHEDULE EVERY 1 DAY STARTS '2017-04-28 12:15:00' ON COMPLETION NOT PRESERVE ENABLE DO BEGIN
    
   /* REMINDER */
   
   -- [1] Remind the users of discrepancies on their time-record thru Email
   -- 2017.04.27 Move here due to concern on notif timing     
   CALL sp_time_record_reminder(); -- 2017.05.21: temporary disable
   
   
   -- [2] For Technical Partners and Timekeeper
   IF DAYNAME(CURDATE()-INTERVAL 1 DAY) NOT IN ('Saturday','Sunday') THEN
      CALL sp_time_server_reminder(); 
   END IF;
   
   -- End of this Event
     
END */$$
DELIMITER ;

/* Function  structure for function  `encryption_key` */

/*!50003 DROP FUNCTION IF EXISTS `encryption_key` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `encryption_key`() RETURNS char(255) CHARSET utf8
BEGIN
	RETURN '-t33mw0rxp0w3r--';
    END */$$
DELIMITER ;

/* Function  structure for function  `getabsent` */

/*!50003 DROP FUNCTION IF EXISTS `getabsent` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `getabsent`( paydate DATE, puserid INT(11), tran_code VARCHAR(32) ) RETURNS varchar(32) CHARSET utf8
BEGIN
	SET @absent = '';
	SELECT  GROUP_CONCAT( DATE_FORMAT(`date` , '%m/%d' ) ) INTO @absent
	FROM ww_time_record_process 
	WHERE `payroll_date` = paydate AND `user_id` = puserid AND `transaction_code` = tran_code;
	
	RETURN @absent;
    END */$$
DELIMITER ;

/* Function  structure for function  `getage` */

/*!50003 DROP FUNCTION IF EXISTS `getage` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `getage`(BDAY DATE) RETURNS tinyint(3) unsigned
RETURN YEAR(FROM_DAYS(DATEDIFF(NOW(), BDAY))) */$$
DELIMITER ;

/* Function  structure for function  `getbdaystimeline` */

/*!50003 DROP FUNCTION IF EXISTS `getbdaystimeline` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `getbdaystimeline`(STARTDATE DATE) RETURNS varchar(16) CHARSET utf8
BEGIN
    DECLARE timeline VARCHAR(16) DEFAULT 'Upcoming';
    DECLARE days INT(1) DEFAULT 0;
    SET days = DATEDIFF(STARTDATE, CURDATE());
  
    IF days = 0 THEN 
       SET timeline = 'Today';
    ELSEIF days = 1 THEN 
       SET timeline = 'Tomorrow';
    ELSEIF (days >= 2 AND days <= 7) THEN
       SET timeline = CONCAT(days,' days');
    ELSEIF days >= 8 AND days <= 14 THEN
       SET timeline = CONCAT(days,' days');
    END IF;
    
    RETURN timeline;
  
END */$$
DELIMITER ;

/* Function  structure for function  `getcompany` */

/*!50003 DROP FUNCTION IF EXISTS `getcompany` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `getcompany`(userid INT(11)) RETURNS int(11)
BEGIN
	SET @ID = 0;
	SELECT company_id INTO @ID FROM ww_users_profile WHERE user_id = userid;
	RETURN @ID;
    END */$$
DELIMITER ;

/* Function  structure for function  `getcompany_contact` */

/*!50003 DROP FUNCTION IF EXISTS `getcompany_contact` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `getcompany_contact`( companyid INT(11), contacttype varchar(255) ) RETURNS varchar(255) CHARSET utf8
BEGIN
	SET @contact_no = '';
	SELECT GROUP_CONCAT(DISTINCT NULLIF(`contact_no`,'') SEPARATOR ',') INTO @contact_no
	FROM ww_users_company_contact WHERE company_id = companyid AND contact_type = contacttype AND deleted = 0;
	RETURN @contact_no;
    END */$$
DELIMITER ;

/* Function  structure for function  `getdaystimeline` */

/*!50003 DROP FUNCTION IF EXISTS `getdaystimeline` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `getdaystimeline`(STARTDATE DATE) RETURNS varchar(16) CHARSET utf8
BEGIN
    DECLARE timeline VARCHAR(16) DEFAULT 'Upcoming';
    DECLARE days INT(1) DEFAULT 0;
    SET days = DATEDIFF(STARTDATE, CURDATE());
  
    IF days = 0 THEN 
       SET timeline = 'Today';
    ELSEIF days = 1 THEN 
       SET timeline = 'Tomorrow';
    ELSEIF (days >= 2 AND days <= 7) THEN
       SET timeline = CONCAT(days,' days');
    ELSEIF (days >= 8 AND days <= 14) THEN
       SET timeline = CONCAT(days,' days');
    ELSEIF days < 0 THEN 
       SET timeline = 'Past';
    END IF;
    
    RETURN timeline;
  
END */$$
DELIMITER ;

/* Function  structure for function  `getFirstApprover` */

/*!50003 DROP FUNCTION IF EXISTS `getFirstApprover` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `getFirstApprover`(planningid INT(11), userid INT(11)) RETURNS int(11) unsigned
BEGIN
          -- 
          -- [0] Override from USERS
          -- 
          SET @approverID = 0;
          SET @rec = 0;
          SET @class = '';
          
          SELECT c.`class_code`, COUNT(a.`id`) INTO @class, @rec
          FROM `ww_approver_class_user` a
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE a.`deleted`=0 AND a.`user_id`=userid AND c.`class_code`='PPA';
          
          IF @rec > 0 THEN
             SELECT `approver_id` INTO @approverID
             FROM `ww_approver_class_user` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0 
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`approver_id`<>userid 
             AND a.user_id = 1 AND a.sequence = 1;
          ELSE     
          -- 
          -- [1] Override from POSITION
          -- 
          SET @approverID = 0;
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id`
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE a.`deleted`=0 AND b.`user_id`=userid AND c.`class_code`='PPA';
          
          IF @rec > 0 THEN
             SELECT `approver_id` INTO @approverID
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
             JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
             AND a.department_id = e.department_id AND a.company_id = e.company_id
             AND a.sequence = 1;
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
          SET @approverID = 0;
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
             WHERE a.`deleted`=0 AND b.`user_id`=userid AND c.`class_code`='PPA' AND a.`approver_id`<>userid;
          
             IF @rec > 0 THEN
		        SELECT `approver_id` INTO @approverID
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
		        JOIN `users_profile` e ON e.department_id = a.`department_id` AND e.`user_id`=userid
                WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
                AND a.company_id = e.company_id 
		        AND a.sequence = 1;
             ELSE
                --   
                -- [3] Override from COMPANY
                -- 
                SET @approverID = 0;
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
                WHERE a.`deleted`=0 AND b.`user_id`=userid AND c.`class_code`='PPA';
          
                IF @rec > 0 THEN
		           SELECT `approver_id` INTO @approverID
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
		           AND a.sequence = 1;
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
             
          END IF; -- IF POSITION     
             
          END IF; -- IF USERS     
    
    RETURN @approverID; 
        
    END */$$
DELIMITER ;

/* Function  structure for function  `getholiday` */

/*!50003 DROP FUNCTION IF EXISTS `getholiday` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `getholiday`(dateid DATE, userid INT(11)) RETURNS varchar(15) CHARSET utf8
BEGIN
    SET @daytypes = 'REGULAR';
    SET @usercount = 0;
    SET @recs = 0;
    SET @ids = 0;
    SET @nLocationCnt = 0;
    SET @count = 0;
    
    /*SELECT th.holiday_id, IF(IFNULL(`legal`,-1)=-1,'REGULAR',IF(`legal`=1,'LEGAL','SPECIAL')), th.location_count
    INTO @ids, @daytypes, @nLocationCnt
    FROM `time_holiday` th
    WHERE th.`holiday_date` = dateid;*/
    
    SELECT count(*) into @count
    FROM `ww_time_holiday` th
    WHERE th.`holiday_date` = dateid;
    
    if @count = 2 then
	    SELECT th.holiday_id, IF(IFNULL(`legal`,-1)=-1,'REGULAR',IF(`legal`=1,'LEGAL','SPECIAL')) AS htype, th.location_count
	    INTO @ids, @daytypes, @nLocationCnt
	    FROM `ww_time_holiday` th
	    WHERE th.`holiday_date` = dateid AND legal = 0 AND
		  IF(IF(IFNULL(`legal`,-1)=-1,'REGULAR',IF(`legal`=1,'LEGAL','SPECIAL')) = 'LEGAL', 1, 
			IF(IFNULL(th.locations,'') = '',
				1,
				FIND_IN_SET((SELECT location_id FROM ww_users_profile WHERE user_id = userid),th.locations))) AND th.deleted = 0 GROUP BY th.holiday_date;    
    else
	    SELECT th.holiday_id, IF(IFNULL(`legal`,-1)=-1,'REGULAR',IF(`legal`=1,'LEGAL','SPECIAL')) AS htype, th.location_count
	    INTO @ids, @daytypes, @nLocationCnt
	    FROM `ww_time_holiday` th
	    WHERE th.`holiday_date` = dateid AND
		  IF(IF(IFNULL(`legal`,-1)=-1,'REGULAR',IF(`legal`=1,'LEGAL','SPECIAL')) = 'LEGAL', 1, 
			IF(IFNULL(th.locations,'') = '',
				1,
				FIND_IN_SET((SELECT location_id FROM ww_users_profile WHERE user_id = userid),th.locations))) AND th.deleted = 0 GROUP BY th.holiday_date;    
    end if;
    
    IF @daytypes = 'SPECIAL' THEN
       -- exemption if special holiday is set to selected partners or location
       -- if the query returns more than 0 then check for the existence of partner id if not he/she if not included in this special holiday
       -- IF @usercount > 0 THEN
       
       -- SELECT COUNT(*) INTO @recs FROM `ww_time_holiday_location`;
       
       SELECT COUNT(*) INTO @recs
       FROM `ww_time_holiday_location` thl
       WHERE thl.holiday_id=@ids AND thl.`user_id`=userid AND thl.`deleted`=0;
       
       -- override, he/she is not included in the selection of partners in this special holiday
       IF @recs = 0 AND @nLocationCnt > 0 THEN
	  IF @count = 2 THEN
		SET @daytypes = 'DOUBLE';
	  ELSE
		SET @daytypes = 'LEGAL';	  
	  END IF;  
       else
	  if @count = 2 then
		set @daytypes = 'DOUBLE';
	  end if;
       END IF;
       -- END IF;
    
    END IF;
    
    RETURN @daytypes;
  
END */$$
DELIMITER ;

/* Function  structure for function  `getrecipients` */

/*!50003 DROP FUNCTION IF EXISTS `getrecipients` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `getrecipients`(ids INT(11), userids INT(11)) RETURNS varchar(255) CHARSET utf8
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE sendto VARCHAR(255) DEFAULT '';
    DECLARE userid INT(11) DEFAULT 0;
    DECLARE username VARCHAR(64) DEFAULT '';
    
    DECLARE recipients CURSOR FOR
       SELECT `user_id`
       FROM `ww_system_feeds_recipient` WHERE `id`=ids;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    -- SET @sendto = '';
    -- SET @userid = 0;
    -- SET @username = '';
    
    OPEN recipients;
    REPEAT
       FETCH recipients INTO userid;
              
       IF NOT done THEN
          
          IF userid <> userids THEN
             SELECT IFNULL(IF(TRIM(`nickname`)='',`firstname`,`nickname`),`firstname`) INTO username 
             FROM `users_profile` WHERE `user_id`=userid;
          
             SET sendto = CONCAT(sendto,', ',username);
          END IF;
          
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE recipients;
           
    RETURN CONCAT('message sent to - ', MID(sendto, 3));
  
END */$$
DELIMITER ;

/* Function  structure for function  `gettimeline` */

/*!50003 DROP FUNCTION IF EXISTS `gettimeline` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `gettimeline`(STARTDATE DATETIME) RETURNS varchar(32) CHARSET utf8
BEGIN
    DECLARE timeline VARCHAR(32) DEFAULT '1min ago';
    DECLARE days INT(1) DEFAULT 0;
    DECLARE mins INT(1) DEFAULT 0;
    
    SET days = DATEDIFF(CURDATE(), STARTDATE);
    SET mins = TIMESTAMPDIFF(MINUTE, STARTDATE, NOW());
  
    IF days = 0 AND mins = 1 THEN
       SET timeline = '1 min ago';
    ELSEIF days = 0 AND mins = 0 THEN
       SET timeline = 'Just now';
    ELSEIF days = 0 AND mins < 60 THEN
       SET timeline = CONCAT(mins,' mins ago');
    ELSEIF days = 0 AND mins = 60 THEN
       SET timeline = '1 hr ago';
    ELSEIF days = 0 AND mins > 60 THEN
       SET timeline = CONCAT(FLOOR(mins/60),' hr  ago');
    ELSEIF days = 1 THEN 
       SET timeline = '1 day  ago';
    /* ELSEIF (days > 1 AND days <= 7) THEN
       SET timeline = '1 week';
    ELSEIF (days > 7 AND days <= 14) THEN
       SET timeline = '2 weeks';
    ELSEIF (days > 14 AND days <= 21) THEN
       SET timeline = '3 weeks';
    ELSEIF (days > 21 AND days <= 29) THEN
       SET timeline = '4 weeks';
    ELSEIF (days > 29 AND days <= 31) THEN
       SET timeline = '1 month';  */  
    ELSE
       IF YEAR(STARTDATE) = YEAR(CURDATE()) THEN
          SET timeline = DATE_FORMAT(STARTDATE,'%M %e at %l:%i%p');   
       ELSE
          SET timeline = DATE_FORMAT(STARTDATE,'%M %e, %Y at %l:%i%p');
       END IF;
    END IF;
    
    RETURN timeline;
  
END */$$
DELIMITER ;

/* Function  structure for function  `get_additional_amount` */

/*!50003 DROP FUNCTION IF EXISTS `get_additional_amount` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_additional_amount`( sCond VARCHAR(235), dtPay DATE, nCompID INT(11), nClosed INT(1) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmount = 0;
	IF nClosed = 1 THEN
		SELECT ROUND(SUM(AES_DECRYPT(amount,encryption_key())),2) INTO @nAmount
		FROM ww_payroll_closed_transaction
		WHERE deleted = 0 AND FIND_IN_SET(transaction_id , sCond)
			AND payroll_date = dtPay AND company_id = nCompID;
	END IF;
	IF nClosed = 0 THEN
		SELECT ROUND(SUM(AES_DECRYPT(amount,encryption_key())),2) INTO @nAmount
		FROM ww_payroll_current_transaction
		WHERE deleted = 0 AND transaction_code IN (sCond)
			AND payroll_date = dtPay AND company_id = nCompID;
	END IF;
	RETURN @nAmount;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_address` */

/*!50003 DROP FUNCTION IF EXISTS `get_address` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_address`( nUserID int(11)) RETURNS varchar(128) CHARSET utf8
BEGIN
	set @sAddress = '';
	SELECT GROUP_CONCAT( key_value SEPARATOR ', ') into @sAddress
	FROM ww_partners_personal pp
	LEFT JOIN ww_partners_key pk ON pp.`key_id` = pk.`key_id`
	WHERE pk.`key_class_id` = 1 AND pk.`key_type_id` = 0 AND `key` != 'zip_code'
	AND partner_id = nUserID;
	
	return @sAddress;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_balance` */

/*!50003 DROP FUNCTION IF EXISTS `get_balance` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_balance`(nUserID INT(11), sFormCode VARCHAR(11), nMonth INT(11), nYear INT(11) ) RETURNS decimal(5,2)
BEGIN
	SET @nUnit = 0;
	SELECT SUM(IF( tfd.credit = 8 , 1, IF(tfd.credit = 4, .5,0)))
	INTO @nUnit 
	FROM ww_time_forms tf
	LEFT JOIN ww_time_form_balance tfb ON tf.`user_id` = tfb.`user_id` AND tf.`form_code` = tfb.`form_code`
	LEFT JOIN ww_time_forms_date tfd ON tf.`forms_id` = tfd.`forms_id` AND tfd.`leave_balance_id` = tfb.`id`
	WHERE tf.user_id = nUserID AND tf.form_code = sFormCode
	AND MONTH(tfd.`date`) = nMonth AND tfb.`year` = nYear
	GROUP BY tf.user_id;
	
	RETURN @nUnit;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_batch_total` */

/*!50003 DROP FUNCTION IF EXISTS `get_batch_total` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_batch_total`( nBatchID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmount = 0;
	SELECT ROUND(SUM(AES_DECRYPT(amount, encryption_key())),2) INTO @nAmount
	FROM ww_payroll_entry_batch_employee
	WHERE deleted = 0
		AND batch_entry_id = nBatchID;	
	RETURN @nAmount;
	
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_allow` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_allow` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_allow`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nAllow DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nAllow
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	LEFT JOIN ww_payroll_transaction_class ptc ON pt.transaction_class_id = ptc.transaction_class_id
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.`is_deminimis` = 0
		AND pt.`is_hazardpay` = 0
		AND pt.`is_representation` = 0
		AND pt.`is_transportation` = 0
		AND pt.`is_cost_living` = 0
		AND pt.`is_fixed_housing` = 0
		AND pt.`is_commission` = 0
		AND pt.`is_profit_sharing` = 0
		AND pt.`is_fees` = 0
		AND pt.transaction_type_id = 1
		AND ptc.transaction_class_code NOT IN ('SALARY','OVERTIME','NIGHT DIFF')
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nAllow;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_benefit` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_benefit` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_benefit`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nBenefit DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nBenefit
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.`is_deminimis` = 0
		AND pt.`is_hazardpay` = 0
		AND pt.`is_representation` = 0
		AND pt.`is_transportation` = 0
		AND pt.`is_cost_living` = 0
		AND pt.`is_fixed_housing` = 0
		AND pt.`is_commission` = 0
		AND pt.`is_profit_sharing` = 0
		AND pt.`is_fees` = 0
		AND pt.transaction_type_id = 2
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nBenefit;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_bonus_nt` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_bonus_nt` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_bonus_nt`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nBOnusNT DECIMAL(12,2);
	SELECT ROUND(SUM(IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nBonusNT
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_type_id = 8
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear ;
	IF nBOnusNT > get_max_bonus() THEN
		SET nBonusNT = get_max_bonus();
	END IF;
	RETURN nBOnusNT;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_bonus_tax` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_bonus_tax` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_bonus_tax`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nBonusTax DECIMAL(12,2);
	SELECT ROUND(SUM(IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nBonusTax
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code = 'BONUS_TAXABLE'
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear ;
	RETURN nBonusTax;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_govt_contri` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_govt_contri` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_govt_contri`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nContri DECIMAL(12,2);
	SELECT ROUND(SUM(IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nContri
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code IN ('SSS_EMP','PHIC_EMP','HDMF_EMP')
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear ;
	RETURN nContri;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_gross_compensation` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_gross_compensation` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_gross_compensation`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nGross DECIMAL(12,2);
	SET nGross = IFNULL(get_bir_total_non_tax( nYear, nUserID ),0) 		+ 
			IFNULL(get_bir_total_taxable( nYear, nUserID ),0)  ;
	RETURN nGross;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_commission` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_commission` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_commission`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nComm DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nComm
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_commission` = 1
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nComm;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_cost_living` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_cost_living` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_cost_living`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nCost DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nCost
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_cost_living` = 1
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nCost;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_deminimis` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_deminimis` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_deminimis`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nDeminimis DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nDeminimis
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_deminimis` = 1
		AND pct.employee_id = nUserID 
		AND pt.transaction_type_id IN (2)
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nDeminimis;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_fees` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_fees` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_fees`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nFees DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nFees
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_fees` = 1
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nFees;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_fixed_housing` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_fixed_housing` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_fixed_housing`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nFixedHouse DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nFixedHouse
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_fixed_housing` = 1
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nFixedHouse;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_hazardpay` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_hazardpay` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_hazardpay`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nHazPay DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nHazPay
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_hazardpay` = 1
		AND pct.employee_id = nUserID 
		AND pct.minwageflag = 0
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nHazPay;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_holidaypay` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_holidaypay` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_holidaypay`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nHolPay DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nHolPay
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_holidaypay` = 1
		AND pct.employee_id = nUserID 
		AND minwageflag = 0
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nHolPay;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_profit_sharing` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_profit_sharing` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_profit_sharing`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nProf DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nProf
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_profit_sharing` = 1
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nProf;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_representation` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_representation` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_representation`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nReps DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nReps
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_representation` = 1
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nReps;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_service_allowance` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_service_allowance` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_service_allowance`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nCost DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nCost
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`transaction_code` in ('SERVICEALLOW','SERVICEALLOW2')
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nCost;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_tempo_allowance` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_tempo_allowance` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_tempo_allowance`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nCost DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nCost
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`transaction_code` in ('Tempo','TEMPOALLOWRETRO','TEMPO ALLOWRETRO','OTHALLOW','OTHERALLOWRETRO','TRANSPO','TRANSPOALLOWRETRO','COMMISSION')
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nCost;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_is_transportation` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_is_transportation` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_is_transportation`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nTrans DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nTrans
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_transportation` = 1
		AND pct.employee_id = nUserID 
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nTrans;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_min_basic` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_min_basic` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_min_basic`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nMinBasic DECIMAL(12,2);
	SELECT ROUND(SUM( 
		( CASE WHEN pt.transaction_code = 'SALARY' THEN 1 
			WHEN pt.transaction_code IN ( 'ABSENCES','ABSENCES_ADJ','LWOP','LWOP_ADJ', 'DEDUCTION_LATE','DEDUCTION_LATE_ADJ','DEDUCTION_UNDERTIME','DEDUCTION_UNDERTIME_ADJ') THEN -1
			ELSE 0 END ) * 
			IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),
		2 )
	INTO nMinBasic
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code IN (
			'SALARY','ABSENCES','ABSENCES_ADJ','LWOP','LWOP_ADJ',
			'DEDUCTION_LATE','DEDUCTION_LATE_ADJ','DEDUCTION_UNDERTIME','DEDUCTION_UNDERTIME_ADJ')
		AND pct.employee_id = nUserID 
		AND minwageflag = 1
		AND YEAR( pct.payroll_date ) = nYear ;
	RETURN nMinBasic - IFNULL(get_bir_govt_contri( nYear, nUserID ),0);
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_min_hazardpay` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_min_hazardpay` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_min_hazardpay`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nHazard DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nHazard
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_hazardpay` = 1
		AND pct.employee_id = nUserID 
		AND pct.minwageflag = 1
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nHazard;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_min_holidaypay` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_min_holidaypay` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_min_holidaypay`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nHol DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nHol
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 AND pt.`is_holidaypay` = 1
		AND pct.employee_id = nUserID 
		AND minwageflag = 1
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nHol;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_min_ndiff` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_min_ndiff` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_min_ndiff`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nDiff DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nDiff
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	LEFT JOIN ww_payroll_transaction_class ptc ON pt.transaction_class_id = ptc.transaction_class_id
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code = 'REGND'
		AND pt.is_holidaypay = 0
		AND pct.employee_id = nUserID 
		AND minwageflag = 1
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nDiff;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_min_overtime` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_min_overtime` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_min_overtime`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nMinOvertime DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nMinOvertime
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	LEFT JOIN ww_payroll_transaction_class ptc ON pt.transaction_class_id = ptc.transaction_class_id
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND ptc.transaction_class_code = 'OVERTIME'
		AND pt.is_holidaypay = 0
		AND pct.employee_id = nUserID 
		AND minwageflag = 1
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nMinOvertime;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_net_taxable` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_net_taxable` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_net_taxable`( nYear INT(4), nUserID INT(11), nExempt DECIMAL(12,2) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nNet DECIMAL(12,2);
	SET nNet = IFNULL(get_bir_total_taxable( nYear, nUserID ),0) - IFNULL(nExempt, 0)  ;
	RETURN nNet;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_overtime` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_overtime` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_overtime`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nOvertime DECIMAL(12,2);
	SELECT ROUND(IFNULL(SUM(AES_DECRYPT(amount, encryption_key())),0),2)
	INTO nOvertime
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	LEFT JOIN ww_payroll_transaction_class ptc ON pt.transaction_class_id = ptc.transaction_class_id
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND (ptc.transaction_class_code = 'OVERTIME' OR pt.transaction_code IN ('REGND','OTADJ'))
		AND pt.is_holidaypay = 0
		AND pct.employee_id = nUserID 
		AND minwageflag = 0
		AND YEAR( pct.payroll_date ) = nYear;
	RETURN nOvertime;
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_tax_basic` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_tax_basic` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_tax_basic`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nTaxBasic DECIMAL(12,2);
	SELECT ROUND(SUM( 
		( CASE WHEN pt.transaction_code IN ('SALARY','SALADJ','REF_ABS','CreditCard') THEN 1 
			WHEN pt.transaction_code IN ( 'ABSENCES','ABSENCES_ADJ','LWOP','LWOP_ADJ', 'DEDUCTION_LATE','DEDUCTION_LATE_ADJ','DEDUCTION_UNDERTIME','DEDUCTION_UNDERTIME_ADJ') THEN -1
			ELSE 0 END ) * 
			IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),
		2 )
	INTO nTaxBasic
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code IN (
			'SALARY','SALADJ','REF_ABS','CreditCard','ABSENCES','ABSENCES_ADJ','LWOP','LWOP_ADJ',
			'DEDUCTION_LATE','DEDUCTION_LATE_ADJ','DEDUCTION_UNDERTIME','DEDUCTION_UNDERTIME_ADJ')
		AND pct.employee_id = nUserID 
		-- AND minwageflag = 0
		AND YEAR( pct.payroll_date ) = nYear ;
	RETURN nTaxBasic - ROUND(IFNULL(get_bir_govt_contri( nYear, nUserID ),0),2);
END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_total_non_tax` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_total_non_tax` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_total_non_tax`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nTotalNonTaxable DECIMAL(12,2);
	SET nTotalNonTaxable = IFNULL(get_bir_bonus_nt( nYear, nUserID ),0) 	     + 
		  IFNULL(get_bir_is_deminimis( nYear, nUserID ),0)   +
		  IFNULL(get_bir_govt_contri( nYear, nUserID ),0)    +
		  IFNULL(get_bir_benefit( nYear, nUserID ),0)	     +
		  IFNULL(get_bir_min_basic( nYear, nUserID ),0)	     + 
		  IFNULL(get_bir_min_holidaypay( nYear, nUserID ),0) + 
		  IFNULL(get_bir_min_overtime( nYear, nUserID ),0)   + 
		  IFNULL(get_bir_min_ndiff( nYear, nUserID ),0)	     +
		  IFNULL(get_bir_min_hazardpay( nYear, nUserID ),0) ;
	RETURN nTotalNonTaxable;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bir_total_taxable` */

/*!50003 DROP FUNCTION IF EXISTS `get_bir_total_taxable` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bir_total_taxable`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nTotalTaxable DECIMAL(12,2);
	SET nTotalTaxable = IFNULL(get_bir_tax_basic( nYear, nUserID ),0)		+
			IFNULL(get_bir_bonus_tax( nYear, nUserID ),0)		+
			IFNULL(get_bir_overtime( nYear, nUserID ),0)		+
			-- IFNULL(get_bir_allow( nYear, nUserID ),0)		+
			IFNULL(get_bir_is_representation( nYear, nUserID ),0)	+
			IFNULL(get_bir_is_transportation( nYear, nUserID ),0)	+
			IFNULL(get_bir_is_cost_living( nYear, nUserID ),0)	+
			IFNULL(get_bir_is_fixed_housing( nYear, nUserID ),0)	+
			IFNULL(get_bir_is_tempo_allowance( nYear, nUserID ),0)	+
			IFNULL(get_bir_is_service_allowance( nYear, nUserID ),0)+
			IFNULL(get_bir_is_commission( nYear, nUserID ),0)	+
			IFNULL(get_bir_is_profit_sharing( nYear, nUserID ),0)	+
			IFNULL(get_bir_is_fees( nYear, nUserID ),0)		+
			IFNULL(get_bir_is_hazardpay( nYear, nUserID ),0) ;
	RETURN nTotalTaxable;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bonus_divisor` */

/*!50003 DROP FUNCTION IF EXISTS `get_bonus_divisor` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bonus_divisor`( dtFrom DATE, dtTo DATE ) RETURNS decimal(5,2)
BEGIN
	SET @nDivisor = 0;
	SET @nDivisor =
	  TIMESTAMPDIFF(MONTH, dtFrom, dtTo) +
	  DATEDIFF(
	    dtTo,
	    dtFrom + INTERVAL
	      TIMESTAMPDIFF(MONTH, dtFrom, dtTo)
	    MONTH
	  ) /
	  DATEDIFF(
	    dtFrom + INTERVAL
	      TIMESTAMPDIFF(MONTH, dtFrom, dtTo) + 1
	    MONTH,
	    dtFrom + INTERVAL
	      TIMESTAMPDIFF(MONTH, dtFrom, dtTo)
	    MONTH
	  );
	  
	  RETURN ROUND(@nDivisor);
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bonus_nt` */

/*!50003 DROP FUNCTION IF EXISTS `get_bonus_nt` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bonus_nt`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmt = 0;
	SELECT AES_DECRYPT( ytd, encryption_key() ) INTO @nAmt
	FROM ww_payroll_closed_summary 
	WHERE user_id = nUserID AND `year` = nYear
		AND summary_code = 'BONUS' AND deleted = 0;
	
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bonus_other_income` */

/*!50003 DROP FUNCTION IF EXISTS `get_bonus_other_income` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bonus_other_income`( dtFrom date, dtEnd date, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmt = 0;
	SELECT ROUND(ifnull( SUM( (CASE ptt.`operation` WHEN '+' THEN 1 ELSE -1 END) * AES_DECRYPT( pct.amount, encryption_key() ) ), 0 ),2) 
	into @nAmt
	FROM ww_payroll_closed_transaction pct
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	LEFT JOIN ww_payroll_transaction_type ptt ON pt.`transaction_type_id` = ptt.`transaction_type_id`
	WHERE pct.deleted = 0 AND pt.deleted = 0 AND pt.is_bonus = 1
		AND pct.employee_id = nUserID and pct.payroll_date between dtFrom and dtEnd;
	
	
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_bonus_tax` */

/*!50003 DROP FUNCTION IF EXISTS `get_bonus_tax` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_bonus_tax`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmt = 0;
	SELECT AES_DECRYPT( ytd, encryption_key() ) INTO @nAmt
	FROM ww_payroll_closed_summary 
	WHERE user_id = nUserID AND `year` = nYear
		AND summary_code = 'BONUS_TAXABLE' AND deleted = 0;
	
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_civil_status` */

/*!50003 DROP FUNCTION IF EXISTS `get_civil_status` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_civil_status`(nUserID INT(11) ) RETURNS int(11)
BEGIN
	SET @nCivilID = 0;
	SET @sKey = '';
	
	SELECT key_value INTO @sKey
	FROM ww_partners_personal pp 
	LEFT JOIN ww_partners p ON pp.`partner_id` = p.`partner_id`
	WHERE p.`user_id` = nUserID AND `key` = 'civil_status';
	
	SELECT civil_status_id INTO @nCivilID FROM ww_partners_civil_status WHERE civil_status = @sKey;
	
	RETURN @nCivilID;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_cola` */

/*!50003 DROP FUNCTION IF EXISTS `get_cola` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_cola`( nUserID INT(11), dtPay DATE) RETURNS decimal(12,2)
BEGIN
	SET @cola = 0;
	SELECT IFNULL(AES_DECRYPT(re.amount, encryption_key() ),0) * 2 INTO @cola
	FROM ww_payroll_entry_recurring r
	LEFT JOIN ww_payroll_entry_recurring_employee re ON r.`recurring_id` = re.`recurring_id`
	LEFT JOIN ww_payroll_transaction p ON p.`transaction_id` = r.`transaction_id`
	WHERE p.transaction_code = 'ECOLA' AND re.employee_id = nUserID 
		AND dtPay BETWEEN r.date_from AND r.date_to AND r.deleted = 0 AND p.deleted = 0;
		
	RETURN @cola;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_config` */

/*!50003 DROP FUNCTION IF EXISTS `get_config` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_config`( configgroup VARCHAR(32), config_key VARCHAR(32) ) RETURNS varchar(255) CHARSET utf8
BEGIN
	SET @val = '';
	
	SELECT c.`value` INTO @val 
	FROM `ww_config_group` g
	JOIN `ww_config` c ON g.`config_group_id` = c.`config_group_id`
	WHERE g.`deleted` = 0 AND c.`deleted` = 0 AND g.`module_group` = configgroup AND `key` = config_key;
	
	RETURN @val;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_current_balance` */

/*!50003 DROP FUNCTION IF EXISTS `get_current_balance` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_current_balance`(nUserID INT(11), sFormCode VARCHAR(11), nYear INT(11) ) RETURNS decimal(5,2)
BEGIN
	SET @nUnit = 0;
	SELECT current
	INTO @nUnit
	FROM ww_time_form_balance
	where user_id = nUserID and form_code = sFormCode and `year` = nYear;
	RETURN @nUnit;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_dailyrate` */

/*!50003 DROP FUNCTION IF EXISTS `get_dailyrate` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_dailyrate`( nUserID int(11) ) RETURNS decimal(12,2)
BEGIN
	set @nDaily = 0;
	set @nPayrate = 0;
	set @nSalary = 0;
	set @nDays = 0;
	
	SELECT AES_DECRYPT(salary, encryption_key()) , payroll_rate_type_id, total_year_days
	into @nSalary, @nPayrate, @nDays
	FROM ww_payroll_partners
	where user_id = nUserID;
	
	IF @nPayrate = 2 THEN
		SET @nDaily = @nSalary / ( @nDays / 12 );
	-- weekly
	ELSEIF @nPayrate = 6 THEN
		SET @nDaily = @nSalary;
	END IF;
	
	return @nDaily;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_day_remain` */

/*!50003 DROP FUNCTION IF EXISTS `get_day_remain` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_day_remain`( dtDate date) RETURNS int(3)
BEGIN
	set @nCount = 0;
	set @nCount = DAY(LAST_DAY(dtDate)) - DAY(dtDate);
	
	return @nCount;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_employmentType` */

/*!50003 DROP FUNCTION IF EXISTS `get_employmentType` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_employmentType`(nUserId INT(11) ) RETURNS int(11)
BEGIN
	DECLARE empTypeID INT(11);
	
	SELECT IFNULL(pet.employment_type_id,0) INTO empTypeID
	FROM ww_partners_employment_type pet, ww_partners p
	WHERE 	p.employment_type_id = pet.employment_type_id AND
		p.user_id = nUserId;
	
	RETURN empTypeID ;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_fiscaldate_end` */

/*!50003 DROP FUNCTION IF EXISTS `get_fiscaldate_end` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_fiscaldate_end`( dtDate DATE) RETURNS date
BEGIN
	SET @may31 = IF(MONTH(dtDate) BETWEEN '01' AND '05',CONCAT(YEAR(dtDate),'-05-31'),CONCAT(YEAR(dtDate + INTERVAL 1 YEAR),'-05-31'));
	SET @fiscaldate = @may31; -- IF(dtDate > @may31 , CONCAT(YEAR(DATE_SUB(@may31,INTERVAL 1 YEAR)),'-05-31'), @may31 );
	  
	RETURN @fiscaldate;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_fiscaldate_start` */

/*!50003 DROP FUNCTION IF EXISTS `get_fiscaldate_start` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_fiscaldate_start`( dtDate DATE) RETURNS date
BEGIN
	SET @june1 = CONCAT(YEAR(dtDate),'-06-01');
	SET @fiscaldate = IF(dtDate >= @june1 , @june1 ,CONCAT(YEAR(DATE_SUB(@june1,INTERVAL 1 YEAR)),'-06-01'));
	  
	RETURN @fiscaldate;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_focus_date` */

/*!50003 DROP FUNCTION IF EXISTS `get_focus_date` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_focus_date`( formsid int(11) ) RETURNS date
BEGIN
	set @dates = '0000-00-00';
	select `date` into @dates from ww_time_forms_date WHERE `forms_id` = formsid;
	
	return @dates;
	
    END */$$
DELIMITER ;

/* Function  structure for function  `get_govt_contri` */

/*!50003 DROP FUNCTION IF EXISTS `get_govt_contri` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_govt_contri`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmt = 0;
	SELECT AES_DECRYPT( ytd, encryption_key() ) INTO @nAmt
	FROM ww_payroll_closed_summary 
	WHERE user_id = nUserID AND `year` = nYear
		AND summary_code = 'ADDITIONAL_EXCLUSION' AND deleted = 0;
	
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_headcount` */

/*!50003 DROP FUNCTION IF EXISTS `get_headcount` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_headcount`( sMonth varchar(30), nYear INT(4),nDivision int(11), sStatus varchaR(255) ) RETURNS int(11)
BEGIN
	SET @nHeadCount= 0;
	if( sStatus != '' ) then
		SELECT COUNT(p.user_id) INTO @nHeadCount
		FROM ww_partners p
		left join ww_users_profile u on u.user_id = p.user_id
		WHERE MONTH(effectivity_date) IN (sMonth) AND year(effectivity_date) = nYear AND u.division_id = nDivision;
	else
		SELECT COUNT(user_id) INTO @nHeadCount
		FROM ww_partners
		WHERE MONTH(effectivity_date) IN (sMonth) 
			AND YEAR(effectivity_date) = nYear AND u.division_id = nDivision
		AND `status` IN (sStatus);
	end if;
	
	RETURN @nHeadCount;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_headcount_before` */

/*!50003 DROP FUNCTION IF EXISTS `get_headcount_before` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_headcount_before`( nYear INT(4),nCompany int(11), nDivision int(11) ) RETURNS int(11)
BEGIN
	set @headCount = 0;
	SET @ActiveheadCount = 0;
	SET @InactiveheadCount = 0;
	-- head count active
	SELECT COUNT(u.user_id) INTO @ActiveheadCount
	FROM ww_users u
	INNER JOIN ww_partners p ON u.`user_id` = p.`user_id`
	INNER JOIN ww_users_profile up ON u.`user_id` = up.`user_id` 
	WHERE p.deleted = 0 AND u.`deleted` = 0
		AND up.company_id = nCompany 
		AND up.`division_id` = nDivision
		AND YEAR(p.`effectivity_date`) < nYear;
	
	SELECT COUNT(u.user_id) INTO @InactiveheadCount
	FROM ww_users u
	INNER JOIN ww_partners p ON u.`user_id` = p.`user_id`
	INNER JOIN ww_users_profile up ON u.`user_id` = up.`user_id` 
	WHERE p.deleted = 0 AND u.`deleted` = 0
		AND up.company_id = nCompany 
		AND up.`division_id` = nDivision
		AND YEAR(p.resigned_date) < nYear AND p.resigned_date != '0000-00-00';
		
	RETURN @ActiveheadCount - @InactiveheadCount;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_headcount_per_dept` */

/*!50003 DROP FUNCTION IF EXISTS `get_headcount_per_dept` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_headcount_per_dept`( nDepartment INT(11), nCompanyid INT(11), nBranchid INT(11), sPayrolldate VARCHAR(255) ) RETURNS int(11)
BEGIN
	SET @nHeadCount= 0;
	SELECT COUNT(*) INTO @nHeadCount 
		FROM (SELECT pct.department_id,pct.`payroll_date` from 
			`ww_payroll_closed_transaction` `pct`
			JOIN `ww_users_profile` `up` ON `pct`.`employee_id` = `up`.`user_id` 
			JOIN `ww_users_branch` `ub` ON `up`.`branch_id` = `ub`.`branch_id`
			where pct.department_id = nDepartment and up.branch_id = nBranchid and pct.payroll_date = sPayrolldate and pct.company_id = nCompanyid GROUP BY employee_id) as tmp 
		group by department_id,payroll_date;	
	RETURN @nHeadCount;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_headcount_within_active` */

/*!50003 DROP FUNCTION IF EXISTS `get_headcount_within_active` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_headcount_within_active`( nYear INT(4), nMonth int(11),nCompany INT(11), nDivision INT(11) ) RETURNS int(11)
BEGIN
	SET @headCount = 0;
	SET @activeHeadcount = 0;
	set @activeHeadcount = get_headcount_before(nYear, nCompany, nDivision);
	
	SELECT COUNT(u.user_id) INTO @headCount
	FROM ww_users u
	INNER JOIN ww_partners p ON u.`user_id` = p.`user_id`
	INNER JOIN ww_users_profile up ON u.`user_id` = up.`user_id` 
	WHERE p.deleted = 0 AND u.`deleted` = 0
		AND up.company_id = nCompany 
		AND up.`division_id` = nDivision
		AND YEAR(p.`effectivity_date`) = nYear
		AND MONTH(p.`effectivity_date`) <= nMonth;
	
	SELECT COUNT(u.user_id) INTO @inactiveheadCount
	FROM ww_users u
	INNER JOIN ww_partners p ON u.`user_id` = p.`user_id`
	INNER JOIN ww_users_profile up ON u.`user_id` = up.`user_id` 
	WHERE p.deleted = 0 AND u.`deleted` = 0
		AND up.company_id = nCompany 
		AND up.`division_id` = nDivision
		AND YEAR(p.`resigned_date`) = nYear
		AND MONTH(p.`resigned_date`) < nMonth;
		
	RETURN @headCount + @activeHeadcount - @inactiveheadCount;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_headcount_within_resigned` */

/*!50003 DROP FUNCTION IF EXISTS `get_headcount_within_resigned` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_headcount_within_resigned`( nYear INT(4), nMonth varchar(60), nCompany INT(11), nDivision INT(11), sStatus varchar(255) ) RETURNS int(11)
BEGIN
	SET @headCount = 0;
	SELECT COUNT(u.user_id) INTO @headCount
	FROM ww_users u
	INNER JOIN ww_partners p ON u.`user_id` = p.`user_id`
	INNER JOIN ww_users_profile up ON u.`user_id` = up.`user_id` 
	WHERE p.deleted = 0 AND u.`deleted` = 0
		AND up.company_id = nCompany 
		AND up.`division_id` = nDivision
		AND YEAR(p.`resigned_date`) = nYear
		AND FIND_IN_SET( MONTH(p.`resigned_date`), nMonth  )
		and p.status_id in (sStatus);
	
	-- insert into checkhead
	-- select nYear, nMonth, nCompany, nDivision, sStatus;
	
	RETURN @headCount;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_leave_used_carry_over` */

/*!50003 DROP FUNCTION IF EXISTS `get_leave_used_carry_over` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_leave_used_carry_over`(userid INT(11), nYear int(4)) RETURNS decimal(3,2)
BEGIN
    SET @nLWP = 0.00;
    
    SELECT IFNULL(SUM(tf.`day`),0) INTO @nLWP
    FROM `time_forms` tf
    WHERE 
       tf.`user_id` = userid AND 
       tf.`form_id` = 22 AND
       tf.`form_status_id` = 6 AND
       tf.`date_from` between concat(nYear,'-01-01') and concat(nYear,'-03-31');
           
    RETURN @nLWP;
  
END */$$
DELIMITER ;

/* Function  structure for function  `get_loan_started` */

/*!50003 DROP FUNCTION IF EXISTS `get_loan_started` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_loan_started`( intLoanID int(11)) RETURNS date
BEGIN
	declare dtDate date;
	
	select start_date 
	into dtDate
	from ww_payroll_partners_loan
	where partner_loan_id = intLoanID;
	
	return dtDate;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_manpower_count` */

/*!50003 DROP FUNCTION IF EXISTS `get_manpower_count` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_manpower_count`( intID int(11), intStatus int(11), varType varchar(32), intEmploymentStatus INT(11), varEmploymentType varchar(32), intCompany int(11) ) RETURNS int(11)
BEGIN
	declare intCount int(11);
	
	IF varType = 'Department' THEN 
		SELECT COUNT(u.user_id) 
		INTO intCount
		FROM ww_users u
		INNER JOIN ww_users_profile up ON u.`user_id` = up.`user_id`
		INNER JOIN ww_partners p ON u.user_id = p.user_id
		WHERE u.`deleted` = 0
			AND up.`department_id` = intID
			AND u.`active` = intStatus
			AND p.status_id = intEmploymentStatus
			AND FIND_IN_SET( p.employment_type_id, varEmploymentType )
			and u.company_id = intCompany;
			
	ELSE
		SELECT COUNT(u.user_id) 
		INTO intCount
		FROM ww_users u
		INNER JOIN ww_users_profile up ON u.`user_id` = up.`user_id`
		INNER JOIN ww_partners p ON u.user_id = p.user_id
		WHERE u.`deleted` = 0
			AND up.`project_id` = intID
			AND u.`active` = intStatus
			AND p.status_id = intEmploymentStatus
			AND find_in_set( p.employment_type_id, varEmploymentType )
			AND u.company_id = intCompany;
	END IF;
	return intCount;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_manpower_count_by_rate_type` */

/*!50003 DROP FUNCTION IF EXISTS `get_manpower_count_by_rate_type` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_manpower_count_by_rate_type`(intID INT(11), intStatus INT(11), varType VARCHAR(32), intPayrollRateType int(11), intCompany INT(11)) RETURNS int(11)
BEGIN
	DECLARE intCount INT(11);
	
	IF varType = 'Department' THEN 
		SELECT COUNT(u.user_id) 
		INTO intCount
		FROM ww_users u
		INNER JOIN ww_users_profile up ON u.`user_id` = up.`user_id`
		INNER JOIN ww_partners p ON u.user_id = p.user_id
		inner JOIN `ww_payroll_partners` `pp` ON `pp`.`user_id` = `u`.`user_id` 
		WHERE u.`deleted` = 0
			AND up.`department_id` = intID
			AND u.`active` = intStatus
			AND p.status_id IN (1,4)
			AND pp.payroll_rate_type_id = intPayrollRateType
			AND u.company_id = intCompany;
			
	ELSE
		SELECT COUNT(u.user_id) 
		INTO intCount
		FROM ww_users u
		INNER JOIN ww_users_profile up ON u.`user_id` = up.`user_id`
		INNER JOIN ww_partners p ON u.user_id = p.user_id
		INNER JOIN `ww_payroll_partners` `pp` ON `pp`.`user_id` = `u`.`user_id`
		WHERE u.`deleted` = 0
			AND up.`project_id` = intID
			AND u.`active` = intStatus
			AND p.status_id in (1,4)
			and pp.payroll_rate_type_id = intPayrollRateType
			AND u.company_id = intCompany;
	END IF;
	RETURN intCount;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_max_bonus` */

/*!50003 DROP FUNCTION IF EXISTS `get_max_bonus` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_max_bonus`() RETURNS decimal(12,2)
BEGIN
	set @max_bonus = 0;
	SELECT `value` into @max_bonus FROM ww_config WHERE `key` = 'max_bonus';
	
	return @max_bonus;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_minwage` */

/*!50003 DROP FUNCTION IF EXISTS `get_minwage` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_minwage`( nLoc INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @Amt = 0.00;
	SELECT minimum_wage INTO @Amt FROM ww_cities WHERE city_id = nLoc;
	RETURN @Amt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_min_basic` */

/*!50003 DROP FUNCTION IF EXISTS `get_min_basic` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_min_basic`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmt = 0;
	SELECT AES_DECRYPT( ytd, encryption_key() ) INTO @nAmt
	FROM ww_payroll_closed_summary 
	WHERE user_id = nUserID AND `year` = nYear
		AND summary_code = 'TAXABLE_INCOME' AND deleted = 0;
	
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_min_deminimis` */

/*!50003 DROP FUNCTION IF EXISTS `get_min_deminimis` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_min_deminimis`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmt = 0;
	SELECT ROUND(SUM(AES_DECRYPT( amount, encryption_key() ) ),2) INTO @nAmt
	FROM ww_payroll_closed_transaction pct
	LEFT JOIN ww_payroll_transaction_class ptc ON pct.transaction_class_id = ptc.transaction_class_id
	WHERE employee_id = nUserID AND YEAR(payroll_date) = nYear
		AND transaction_class_code IN ('DE_MINIMIS_BENEFIT_BATCH','DE_MINIMIS_BENEFIT_RECURRING')
		AND pct.deleted = 0;
	
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_min_ndiff` */

/*!50003 DROP FUNCTION IF EXISTS `get_min_ndiff` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_min_ndiff`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmt = 0;
	SELECT ROUND(SUM(AES_DECRYPT( amount, encryption_key() ) ),2) INTO @nAmt
	FROM ww_payroll_closed_transaction
	WHERE employee_id = nUserID AND YEAR(payroll_date) = nYear
		AND transaction_code = 'REGND' AND deleted = 0;
	
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_min_overtime` */

/*!50003 DROP FUNCTION IF EXISTS `get_min_overtime` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_min_overtime`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmt = 0;
	SELECT AES_DECRYPT( ytd, encryption_key() ) INTO @nAmt
	FROM ww_payroll_closed_summary 
	WHERE user_id = nUserID AND `year` = nYear
		AND summary_code = 'OVERTIME' AND deleted = 0;
	
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_ndiff` */

/*!50003 DROP FUNCTION IF EXISTS `get_ndiff` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_ndiff`( nUserID INT(11), dtDate DATE, nCompID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE ShiftID INT(11) DEFAULT 0;
	DECLARE SchedIn DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE SchedOut DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE curStartND DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE curEndND DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE ActualIN DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE ActualOUT DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE TimeStart DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE TimeEnd DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE tStart DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE tEnd DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE unit DECIMAL(5,2) DEFAULT 0.00;
	DECLARE ND DECIMAL(5,2) DEFAULT 0.00;
	DECLARE ShiftStart TIME DEFAULT '00:00:00';
	DECLARE ShiftEnd TIME DEFAULT '00:00:00';
	DECLARE prevStartND DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE prevEndND DATETIME DEFAULT '0000-00-00 00:00:00';
	DECLARE isPremium TINYINT(1) DEFAULT 1;
	-- get shift
	SET ShiftID = time_get_shift(nUserID, dtDate);	
	SET ShiftStart = (SELECT time_start FROM ww_time_shift WHERE shift_id = ShiftID);
	SET ShiftEnd = (SELECT time_end FROM ww_time_shift WHERE shift_id = ShiftID);
	
	-- get sched out
	IF ( time_get_sched_out( ShiftID ) < time_get_sched_in( ShiftID ) ) THEN
		SET SchedOut = CONCAT( ADDDATE( dtDate, 1 ), ' ', time_get_sched_out( ShiftID ) );
	ELSE 
		SET SchedOut = CONCAT(dtDate, ' ', time_get_sched_out( ShiftID ) );
	END IF;
	
	SET SchedIn = CONCAT(dtDate, ' ', time_get_sched_in( ShiftID ) );
	
	-- get current ND set up
	SET curStartND = CONCAT(dtDate, ' ', time_get_nd_start( ShiftID, nCompID ) );
	SET curEndND = CONCAT( ADDDATE( dtDate, 1 ), ' ', time_get_nd_end( ShiftID, nCompID ) );
	
	SET prevStartND = CONCAT(ADDDATE((dtDate), -1), ' ', time_get_nd_start( ShiftID, nCompID));
	SET prevEndND = CONCAT(dtDate, ' ', time_get_nd_end( ShiftID, nCompID ));
	-- get actual time in / out
	SET ActualIN = time_get_time_in( nUserID, dtDate);
	SET ActualOUT = time_get_time_out( nUserID, dtDate);
	SET @EmpType = 0;
	SET @EmpType = get_employmentType(nUserID);
	
	IF @EmpType = 6 THEN
		IF ( ActualIN IS NOT NULL AND ActualOUT IS NOT NULL ) THEN
			IF ShiftStart BETWEEN '00:00:00' AND '05:59:00' THEN
				IF SchedIN <= prevStartND THEN
					SET TimeStart = prevStartND;
				END IF;
				IF SchedIN > prevStartND THEN
					SET TimeStart = SchedIN; -- SET TIME START = SchedIN
				END IF;
			
				SET TimeStart = ActualIN;
			
				IF ActualIN < SchedIN THEN
					SET TimeStart = SchedIN;
				END IF;
			
				SET TimeEnd = prevEndND;
			
				IF SchedOut < prevEndND THEN
					SET TimeEnd = SchedOut;
				END IF;
				
				IF ( TimeStart < TimeEnd ) THEN 
					
					IF (ActualIN <= TimeStart + INTERVAL (time_period_process_shift('GRACE-PERIOD-IN-MINUTES','EMPLOYMENT-TYPE', 
							    nUserID, ShiftID,'0')) MINUTE) THEN
						SET tStart = TimeStart;
					END IF;
					IF (ActualIN > (TimeStart + INTERVAL (time_period_process_shift('GRACE-PERIOD-IN-MINUTES','EMPLOYMENT-TYPE', 
							    nUserID, ShiftID,'0')) MINUTE)) THEN
						SET tStart = ActualIN;
					END IF;
					IF (ActualOUT <= TimeEnd) THEN
						SET tEnd = ActualOUT;
					END IF;
					IF (ActualOUT >= TimeEnd) THEN
						SET tEnd= TimeEnd;
					END IF;
					
					SELECT ActualIN, ActualOUT, TimeStart, TimeEnd, curStartND, curEndND, SchedIN, SchedOUT, tStart, tEnd
					INTO  @ActualIN, @ActualOUT, @TimeStart, @TimeEnd, @curStartND, @curEndND, @SchedIN, @SchedOUT, @tStart, @tEnd;
					
					SET unit = ROUND( ( TIME_TO_SEC( TIMEDIFF( tEnd, tStart ) ) / 3600 ), 2 );
				
				END IF;
				
			ELSE
				SET @Name=0;
				-- check if schedule has ND	
				IF (SchedIn <= curStartND) THEN
					SET TimeStart = curStartND;
				END IF;
				IF (SchedIn >= curStartND) THEN
					SET TimeStart = SchedIn;
				END IF;
				IF (SchedOut >= curEndND) THEN
					SET TimeEnd = curEndND;
				END IF;
				IF (SchedOut <= curEndND) THEN
					SET TimeEnd = SchedOut;
				END IF;
					
				IF ( TimeStart < TimeEnd ) THEN 
					
						-- check in out
					IF (ActualIN <= TimeStart + INTERVAL (time_period_process_shift('GRACE-PERIOD-IN-MINUTES','EMPLOYMENT-TYPE', 
							    nUserID, ShiftID,'0')) MINUTE) THEN
						SET tStart = TimeStart;
					END IF;
					IF (ActualIN > (TimeStart + INTERVAL (time_period_process_shift('GRACE-PERIOD-IN-MINUTES','EMPLOYMENT-TYPE', 
							    nUserID, ShiftID,'0')) MINUTE)) THEN
						SET tStart = ActualIN;
					END IF;
					IF (ActualOUT <= TimeEnd) THEN
						SET tEnd = ActualOUT;
					END IF;
					IF (ActualOUT >= TimeEnd) THEN
						SET tEnd= TimeEnd;
					END IF;
					
					SELECT ActualIN, ActualOUT, TimeStart, TimeEnd, curStartND, curEndND, SchedIN, SchedOUT, tStart, tEnd
					INTO  @ActualIN, @ActualOUT, @TimeStart, @TimeEnd, @curStartND, @curEndND, @SchedIN, @SchedOUT, @tStart, @tEnd;
					
					
					SET unit = ROUND( ( TIME_TO_SEC( TIMEDIFF( tEnd, tStart ) ) / 3600 ), 2 );
				END IF;
			END IF;
		END IF;
	END IF ;
	
	SET ND = 0;
	IF ( unit > 0 ) THEN
		SET ND = unit;
	END IF;
	
	RETURN ND; 
	
END */$$
DELIMITER ;

/* Function  structure for function  `get_overtime_break` */

/*!50003 DROP FUNCTION IF EXISTS `get_overtime_break` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_overtime_break`( day_type VARCHAR(32), unit DECIMAL(5,3), comp_id INT(11) ) RETURNS decimal(5,2)
BEGIN
	SET @deduction = 0;
	
	SELECT deduction INTO @deduction
	FROM ww_time_day_type dt
	LEFT JOIN ww_time_day_type_break dtb ON dt.`day_type_id` = dtb.`day_type_id`
	LEFT JOIN ww_time_day_break db ON db.`break_id` = dtb.`break_id`
	LEFT JOIN ww_time_day_break_range dbr ON dbr.`break_id` = db.`break_id`
	WHERE dt.`day_type` = day_type AND unit BETWEEN dbr.`hour_from` AND dbr.`hour_to` AND dbr.`company_id` = comp_id;
	RETURN @deduction;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_overtime_rate_amount` */

/*!50003 DROP FUNCTION IF EXISTS `get_overtime_rate_amount` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_overtime_rate_amount`( nOvertimeId INT(4), nCompanyid INT(11), nLocationid INT(11) ) RETURNS decimal(12,3)
BEGIN
	SET @nAmt = 0;
	SELECT overtime_amount INTO @nAmt
	FROM ww_payroll_overtime_rates_amount 
	WHERE company_id = nCompanyid AND overtime_id = nOvertimeId
		AND overtime_location_id = nLocationid
		group by company_id,overtime_id,overtime_location_id;
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_partners_personal` */

/*!50003 DROP FUNCTION IF EXISTS `get_partners_personal` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_partners_personal`( nUserID INT(11), nKey VARCHAR(32) ) RETURNS varchar(100) CHARSET utf8
BEGIN
	SET @nValue = '';
	SELECT pp.`key_value` INTO @nValue FROM ww_partners_personal pp
	LEFT JOIN ww_users_profile up ON pp.`partner_id` = up.`partner_id`
	WHERE pp.`key` = nKey AND up.`user_id` = nUserID;
	RETURN @nValue;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_paydate_bonus` */

/*!50003 DROP FUNCTION IF EXISTS `get_paydate_bonus` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paydate_bonus`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nBonus DECIMAL(12,2);
	SELECT ROUND(SUM( IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nBonus 
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_type_id = 8
		AND pct.employee_id = nUserID 
		AND pct.payroll_date = dtPay ;
	RETURN nBonus ;
END */$$
DELIMITER ;

/* Function  structure for function  `get_paydate_deminimis` */

/*!50003 DROP FUNCTION IF EXISTS `get_paydate_deminimis` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paydate_deminimis`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nDeminimis DECIMAL(12,2);
	SELECT ROUND(SUM( IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nDeminimis 
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.is_deminimis = 1
		AND pct.employee_id = nUserID 
		AND pct.payroll_date = dtPay ;
	RETURN nDeminimis ;
END */$$
DELIMITER ;

/* Function  structure for function  `get_paydate_hdmf` */

/*!50003 DROP FUNCTION IF EXISTS `get_paydate_hdmf` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paydate_hdmf`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nHDMF DECIMAL(12,2);
	SELECT ROUND(SUM( IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nHDMF 
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code = 'HDMF_EMP'
		AND pct.employee_id = nUserID 
		AND pct.payroll_date = dtPay ;
	RETURN nHDMF ;
END */$$
DELIMITER ;

/* Function  structure for function  `get_paydate_nontax_income` */

/*!50003 DROP FUNCTION IF EXISTS `get_paydate_nontax_income` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paydate_nontax_income`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nNonTaxIncome DECIMAL(12,2);
	SELECT ROUND(SUM( IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nNonTaxIncome 
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_type_id IN (2,6,7)
		AND pt.is_deminimis = 0
		AND pct.employee_id = nUserID 
		AND pct.payroll_date = dtPay ;
	RETURN nNonTaxIncome ;
END */$$
DELIMITER ;

/* Function  structure for function  `get_paydate_phic` */

/*!50003 DROP FUNCTION IF EXISTS `get_paydate_phic` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paydate_phic`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nPHIC DECIMAL(12,2);
	SELECT ROUND(SUM( IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nPHIC 
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code = 'PHIC_EMP'
		AND pct.employee_id = nUserID 
		AND pct.payroll_date = dtPay ;
	RETURN nPHIC ;
END */$$
DELIMITER ;

/* Function  structure for function  `get_paydate_sss` */

/*!50003 DROP FUNCTION IF EXISTS `get_paydate_sss` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paydate_sss`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nSSS DECIMAL(12,2);
	SELECT ROUND(SUM( IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nSSS 
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code = 'SSS_EMP'
		AND pct.employee_id = nUserID 
		AND pct.payroll_date = dtPay ;
	RETURN nSSS ;
END */$$
DELIMITER ;

/* Function  structure for function  `get_paydate_tax_basic` */

/*!50003 DROP FUNCTION IF EXISTS `get_paydate_tax_basic` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paydate_tax_basic`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nTaxBasic DECIMAL(12,2);
	SELECT ROUND(SUM( 
		( CASE WHEN pt.transaction_code = 'SALARY' THEN 1 
			WHEN pt.transaction_code IN ( 'ABSENCES','ABSENCES_ADJ','LWOP','LWOP_ADJ', 'DEDUCTION_LATE','DEDUCTION_LATE_ADJ','DEDUCTION_UNDERTIME','DEDUCTION_UNDERTIME_ADJ') THEN -1
			ELSE 0 END ) * 
			IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),
		2 )
	INTO nTaxBasic
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code IN (
			'SALARY','ABSENCES','ABSENCES_ADJ','LWOP','LWOP_ADJ',
			'DEDUCTION_LATE','DEDUCTION_LATE_ADJ','DEDUCTION_UNDERTIME','DEDUCTION_UNDERTIME_ADJ')
		AND pct.employee_id = nUserID 
		AND minwageflag = 0
		AND pct.payroll_date = dtPay ;
	RETURN nTaxBasic;
END */$$
DELIMITER ;

/* Function  structure for function  `get_paydate_tax_basic_min` */

/*!50003 DROP FUNCTION IF EXISTS `get_paydate_tax_basic_min` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paydate_tax_basic_min`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nTaxBasicMin DECIMAL(12,2);
	SELECT ROUND(SUM( 
		( CASE WHEN pt.transaction_code = 'SALARY' THEN 1 
			WHEN pt.transaction_code IN ( 'ABSENCES','ABSENCES_ADJ','LWOP','LWOP_ADJ', 'DEDUCTION_LATE','DEDUCTION_LATE_ADJ','DEDUCTION_UNDERTIME','DEDUCTION_UNDERTIME_ADJ') THEN -1
			ELSE 0 END ) * 
			IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),
		2 )
	INTO nTaxBasicMin
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code IN (
			'SALARY','ABSENCES','ABSENCES_ADJ','LWOP','LWOP_ADJ',
			'DEDUCTION_LATE','DEDUCTION_LATE_ADJ','DEDUCTION_UNDERTIME','DEDUCTION_UNDERTIME_ADJ')
		AND pct.employee_id = nUserID 
		AND minwageflag = 1
		AND pct.payroll_date = dtPay ;
	RETURN nTaxBasicMin;
END */$$
DELIMITER ;

/* Function  structure for function  `get_paydate_tax_income` */

/*!50003 DROP FUNCTION IF EXISTS `get_paydate_tax_income` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paydate_tax_income`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nTaxIncome DECIMAL(12,2);
	SELECT ROUND(SUM( IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nTaxIncome
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code NOT IN (
			'SALARY','ABSENCES','ABSENCES_ADJ','LWOP','LWOP_ADJ',
			'DEDUCTION_LATE','DEDUCTION_LATE_ADJ','DEDUCTION_UNDERTIME','DEDUCTION_UNDERTIME_ADJ')
		AND pt.transaction_type_id = 1
		AND pct.employee_id = nUserID 
		AND pct.payroll_date = dtPay ;
	RETURN nTaxIncome;
END */$$
DELIMITER ;

/* Function  structure for function  `get_paydate_wtax` */

/*!50003 DROP FUNCTION IF EXISTS `get_paydate_wtax` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paydate_wtax`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nWtax DECIMAL(12,2);
	SELECT ROUND(SUM( IFNULL(AES_DECRYPT(amount, encryption_key()),0) ),2 )
	INTO nWtax 
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_code = 'WHTAX'
		AND pct.employee_id = nUserID 
		AND pct.payroll_date = dtPay ;
	RETURN nWtax ;
END */$$
DELIMITER ;

/* Function  structure for function  `get_paytag_bonus` */

/*!50003 DROP FUNCTION IF EXISTS `get_paytag_bonus` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_paytag_bonus`( dtPay DATE, nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nBonus DECIMAL(12,2) DEFAULT 0;
	SELECT IFNULL(AES_DECRYPT(amount, encryption_key()),0)
	INTO nBonus 
	FROM ww_payroll_closed_transaction pct 
	LEFT JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id`
	WHERE pct.`deleted` = 0 AND pt.deleted = 0 
		AND pt.transaction_type_id = 8
		AND pct.employee_id = nUserID 
		AND pct.payroll_date = dtPay 
		AND AES_DECRYPT(amount, encryption_key()) > 0 LIMIT 1;
	RETURN nBonus ;
END */$$
DELIMITER ;

/* Function  structure for function  `get_project_movement` */

/*!50003 DROP FUNCTION IF EXISTS `get_project_movement` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_project_movement`( intUser int(11), dtStart date, dtEnd date ) RETURNS int(11)
BEGIN
	declare intMovement int(11);
	
	SELECT m.`movement_id`
	into intMovement
	FROM ww_partners_movement m
	LEFT JOIN ww_partners_movement_action ma ON m.`movement_id` = ma.`movement_id`
	LEFT JOIN ww_partners_movement_action_transfer mat ON ma.`movement_id` = mat.`movement_id`
	WHERE field_name IN ('project') AND m.`status_id` = 3
	AND ma.`user_id` = intUser
	AND ( ma.`effectivity_date` BETWEEN dtStart AND dtEnd
	OR STR_TO_DATE(mat.`to_name`, '%M %d,%Y') BETWEEN dtStart AND dtEnd);
	
	return intMovement;
	
    END */$$
DELIMITER ;

/* Function  structure for function  `get_recurring_total` */

/*!50003 DROP FUNCTION IF EXISTS `get_recurring_total` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_recurring_total`( nRecurringID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmount = 0;
	SELECT ROUND(SUM(AES_DECRYPT(amount, encryption_key())),2) INTO @nAmount
	FROM ww_payroll_entry_recurring_employee
	WHERE deleted = 0 AND recurring_id = nRecurringID;
	
	RETURN @nAmount;
	
    END */$$
DELIMITER ;

/* Function  structure for function  `get_relation` */

/*!50003 DROP FUNCTION IF EXISTS `get_relation` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_relation`( varKey varchar(128), intSeq int(11), varKeyName varchar(128), intRecruit int(11) ) RETURNS varchar(128) CHARSET utf8
BEGIN
	declare varValue VARCHAR(128);
	SELECT key_value
	into varValue
	FROM ww_recruitment_personal_history
	WHERE `key` = varKey AND sequence = intSeq AND key_name = varKeyName AND recruit_id = intRecruit;
	return varValue;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_sbr_date` */

/*!50003 DROP FUNCTION IF EXISTS `get_sbr_date` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_sbr_date`( nUserID int(11), dtPay date, sType varchar(11) ) RETURNS date
BEGIN
	set @sbr_date = '';
	
	SELECT distinct sbr_date into @sbr_date
	FROM ww_payroll_closed_transaction 
	WHERE deleted = 0 and employee_id = nUserID AND transaction_code = sType
		AND YEAR(payroll_date) = year(dtPay) AND MONTH(payroll_date )= month(dtPay);
	return @sbr_date;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_sbr_no` */

/*!50003 DROP FUNCTION IF EXISTS `get_sbr_no` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_sbr_no`( nUserID INT(11), dtPay DATE, sType VARCHAR(11) ) RETURNS varchar(16) CHARSET utf8
BEGIN
	SET @sbr_no = '';
	
	SELECT DISTINCT sbr_no INTO @sbr_no
	FROM ww_payroll_closed_transaction 
	WHERE deleted = 0 AND employee_id = nUserID AND transaction_code = sType
		AND YEAR(payroll_date) = YEAR(dtPay) AND MONTH(payroll_date )= MONTH(dtPay);
	RETURN @sbr_no;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_search` */

/*!50003 DROP FUNCTION IF EXISTS `get_search` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_search`() RETURNS char(255) CHARSET utf8
BEGIN
	RETURN IFNULL(@search,'');
    END */$$
DELIMITER ;

/* Function  structure for function  `get_sensitivity` */

/*!50003 DROP FUNCTION IF EXISTS `get_sensitivity` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_sensitivity`( roleID INT(11) ) RETURNS varchar(9) CHARSET utf8
BEGIN
	SET @sSensitivity = '';
	SET @sProfile = '';
	set @sProfileID = '';
	SELECT profile_id, role into @nProfileID, @sProfile  FROM ww_roles WHERE role_id = roleID;
	
	SELECT GROUP_CONCAT(sensitivity_id) into @sSensitivity FROM ww_profiles_sensitivity ps
	LEFT JOIN ww_profiles p ON ps.`profile_id` = p.`profile_id`
	WHERE FIND_IN_SET(ps.profile_id, @nProfileID ) and p.profile = @sProfile and mod_id = 4;
	RETURN @sSensitivity;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_taxdue` */

/*!50003 DROP FUNCTION IF EXISTS `get_taxdue` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_taxdue`( nYear INT(4), nUserID INT(11), nExempt DECIMAL(12,2) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nTaxdue  DECIMAL(12,2);
	DECLARE nSalary  DECIMAL(12,2);
	DECLARE nAmount  DECIMAL(12,2);
	DECLARE nRate    DECIMAL(12,2);
	DECLARE nTaxable DECIMAL(12,2);
	SET nTaxable = IFNULL(get_bir_net_taxable(nYear, nUserID, nExempt),0);
	
	IF nTaxable > 0 THEN 
		SELECT salary_from, amount, rate 
		INTO nSalary, nAmount, nRate
		FROM ww_payroll_annual_tax 
		WHERE nTaxable BETWEEN salary_from AND salary_to
		ORDER BY salary_from DESC
		LIMIT 1;
		SET nTaxdue = ROUND( ( ( nTaxable - nSalary ) * ROUND( ( nRate / 100 ) ,2) + nAmount ),2);
	ELSE
		SET nTaxdue = 0;
	END IF;
	RETURN nTaxdue;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_tax_basic` */

/*!50003 DROP FUNCTION IF EXISTS `get_tax_basic` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_tax_basic`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmt = 0;
	SELECT AES_DECRYPT( ytd, encryption_key() ) INTO @nAmt
	FROM ww_payroll_closed_summary 
	WHERE user_id = nUserID AND `year` = nYear
		AND summary_code = 'TAXABLE_INCOME' AND deleted = 0;
	
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_tax_overtime` */

/*!50003 DROP FUNCTION IF EXISTS `get_tax_overtime` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_tax_overtime`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	SET @nAmt = 0;
	SELECT AES_DECRYPT( ytd, encryption_key() ) INTO @nAmt
	FROM ww_payroll_closed_summary 
	WHERE user_id = nUserID AND `year` = nYear
		AND summary_code = 'OVERTIME' AND deleted = 0;
	
	RETURN @nAmt;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_time_daytype` */

/*!50003 DROP FUNCTION IF EXISTS `get_time_daytype` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_time_daytype`(userid INT(11), dtDate DATE) RETURNS varchar(32) CHARSET utf8
BEGIN
	SET @sShift = '' ;
	SET @daytype = '';
	-- validate if holiday
	SELECT getholiday( dtDate, userid ) INTO @daytype;
	IF @daytype = 'REGULAR' THEN
		-- validate if REST DAY
		SELECT UPPER(shift) INTO @sShift FROM ww_time_record WHERE user_id = userid AND DATE = dtDate;
		IF @sShift = 'RESTDAY' THEN
			SET @sShift = 'RESTDAY';
		ELSE 
			SET @sShift = 'REGULAR';
		END IF;
	ELSE
		SET @sShift = @daytype;
	END IF;
	RETURN @sShift;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_time_period_from` */

/*!50003 DROP FUNCTION IF EXISTS `get_time_period_from` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_time_period_from`(periodid INT(11), compid INT(11)) RETURNS date
BEGIN
	SET @dtFrom = '0000-00-00';
	SELECT date_from INTO @dtFrom FROM ww_time_period WHERE period_id = periodid AND company_id = compid;
	RETURN @dtFrom;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_time_period_to` */

/*!50003 DROP FUNCTION IF EXISTS `get_time_period_to` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_time_period_to`(periodid INT(11), compid INT(11)) RETURNS date
BEGIN
	SET @dtTo = '0000-00-00';
	SELECT date_to INTO @dtTo FROM ww_time_period WHERE period_id = periodid AND company_id = compid;
	RETURN @dtTo;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_total_hours` */

/*!50003 DROP FUNCTION IF EXISTS `get_total_hours` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_total_hours`( nUserID INT(11), varPayrollDate VARCHAR(128)) RETURNS decimal(12,2)
BEGIN
	SET @hours = 0;
	SELECT SUM(hrs_actual) INTO @hours
	FROM ww_time_record_summary 
	WHERE user_id = nUserID AND payroll_date = varPayrollDate GROUP BY `user_id` ;
	RETURN @hours;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_used_leave` */

/*!50003 DROP FUNCTION IF EXISTS `get_used_leave` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_used_leave`(nUserID INT(11), sFormCode VARCHAR(11), nYear INT(11), nMonth int(11) ) RETURNS decimal(5,2)
BEGIN
	SET @nUsed = 0;
	set @nMonthID = 0;
	SET @nMonthID = nMonth - 1;
	SELECT used
	into @nUsed 
	FROM time_forms_sl_vl
	WHERE user_id = nUserID
	AND `month` = @nMonthID 
	AND `year` = nYear
	AND form_code = sFormCode;
	RETURN @nUsed;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_wtax` */

/*!50003 DROP FUNCTION IF EXISTS `get_wtax` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_wtax`( nYear INT(4), nUserID INT(11) ) RETURNS decimal(12,2)
BEGIN
	DECLARE nWtax DECIMAL(12,2);
	SELECT ROUND(SUM(AES_DECRYPT( amount, encryption_key() ) ),2) INTO nWtax
	FROM ww_payroll_closed_transaction
	WHERE employee_id = nUserID AND YEAR(payroll_date) = nYear
		AND transaction_code = 'WHTAX' AND deleted = 0;
	
	RETURN nWtax;
    END */$$
DELIMITER ;

/* Function  structure for function  `get_zipcode` */

/*!50003 DROP FUNCTION IF EXISTS `get_zipcode` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `get_zipcode`( nUserID int(11) ) RETURNS varchar(4) CHARSET utf8
BEGIN
	SET @sZip = '';
	SELECT key_value INTO @sZip
	FROM ww_partners_personal pp
	LEFT JOIN ww_partners_key pk ON pp.`key_id` = pk.`key_id`
	WHERE pk.`key_class_id` = 1 AND `key` = 'zip_code'
	AND partner_id = nUserID;
	
	RETURN @sZip;
    END */$$
DELIMITER ;

/* Function  structure for function  `is_minimum_wage_earner` */

/*!50003 DROP FUNCTION IF EXISTS `is_minimum_wage_earner` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `is_minimum_wage_earner`( nUserID INT(11) ) RETURNS tinyint(1)
BEGIN
	SET @nMin = 0;
	SELECT 
	IF( ROUND( ( CASE payroll_rate_type_id 
		WHEN 2 THEN ( AES_DECRYPT( `salary`, encryption_key() ) / ( `total_year_days` / 12 ) )
		WHEN 6 THEN ( AES_DECRYPT( `salary`, encryption_key() ) )
		END ), 2 ) > 
		IF(`location_id` IS NULL OR `location_id` = 0, get_config('Payroll','minwage_amount'), get_minwage(`location_id`) ) ,
	0, 1)
	INTO @nMin
	FROM ww_payroll_partners WHERE user_id = nUserID;
	RETURN @nMin;
    END */$$
DELIMITER ;

/* Function  structure for function  `is_thrash` */

/*!50003 DROP FUNCTION IF EXISTS `is_thrash` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `is_thrash`() RETURNS char(1) CHARSET utf8
BEGIN
	RETURN @thrash;
    END */$$
DELIMITER ;

/* Function  structure for function  `is_trash` */

/*!50003 DROP FUNCTION IF EXISTS `is_trash` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `is_trash`() RETURNS char(1) CHARSET utf8
BEGIN
	RETURN IFNULL(@trash,0);
    END */$$
DELIMITER ;

/* Function  structure for function  `nextbday` */

/*!50003 DROP FUNCTION IF EXISTS `nextbday` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `nextbday`(bday DATE) RETURNS date
RETURN DATE_ADD(bday, INTERVAL YEAR(FROM_DAYS(DATEDIFF(NOW(), bday) - 1)) + 1 YEAR) */$$
DELIMITER ;

/* Function  structure for function  `nextbday2` */

/*!50003 DROP FUNCTION IF EXISTS `nextbday2` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `nextbday2`(bday DATE) RETURNS date
BEGIN
SET @retdate = CURDATE();
IF (nextbday(bday) > (CURDATE() + INTERVAL 15 DAY)) THEN
   SET @retdate = DATE_ADD(bday, INTERVAL YEAR(FROM_DAYS(DATEDIFF(NOW(), bday) - 1)) + 0 YEAR);
ELSE
   SET @retdate = DATE_ADD(bday, INTERVAL YEAR(FROM_DAYS(DATEDIFF(NOW(), bday) - 1)) + 1 YEAR);
END IF;
RETURN @retdate;
END */$$
DELIMITER ;

/* Function  structure for function  `payroll_get_wtax` */

/*!50003 DROP FUNCTION IF EXISTS `payroll_get_wtax` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `payroll_get_wtax`(payroll_schedule INT(11), taxcode INT(11), salary DECIMAL(10,2)	) RETURNS decimal(10,2)
BEGIN
   
    SET @salary_from = 0.00;
    SET @salary_to = 0.00;
    SET @salary = salary;
    SET @fixed_amount = 0.00;
    SET @excess_percentage = 0.00;
    SET @wtax = 0.00;
    
    SELECT salary_from, salary_to, fixed_amount, excess_percentage 
    INTO @salary_from, @salary_to, @fixed_amount, @excess_percentage
    FROM `ww_payroll_whtax_table`
	WHERE `payroll_schedule_id` = payroll_schedule
	AND `taxcode_id` = taxcode
	AND @salary BETWEEN `salary_from` AND `salary_to`;
	
	SET @wtax = ( ( @salary - @salary_from ) * @excess_percentage/100 ) + @fixed_amount;
    
    RETURN @wtax ;
  
END */$$
DELIMITER ;

/* Function  structure for function  `set_2_decimal` */

/*!50003 DROP FUNCTION IF EXISTS `set_2_decimal` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `set_2_decimal`( decAmount decimal(12,3)) RETURNS decimal(12,2)
BEGIN
	DECLARE decValAmount DECIMAL(12,2);
	SELECT round(decAmount,2) 
	INTO decValAmount;
	
	RETURN decValAmount;
    END */$$
DELIMITER ;

/* Function  structure for function  `set_salary` */

/*!50003 DROP FUNCTION IF EXISTS `set_salary` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `set_salary`( intUser INT(11), dtPay DATE) RETURNS decimal(12,2)
BEGIN
	DECLARE decSalary DECIMAL(12,2);
	SELECT SUM(AES_DECRYPT(`amount`,encryption_key())) 
	INTO decSalary
	FROM ww_payroll_closed_transaction
	WHERE employee_id = intUser AND payroll_date = dtPay 
	AND transaction_code IN ('SALARY','SSS_EMP','PHIC_EMP','HDMF_EMP');
	
	RETURN decSalary;
    END */$$
DELIMITER ;

/* Function  structure for function  `set_search` */

/*!50003 DROP FUNCTION IF EXISTS `set_search` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `set_search`( search CHAR(255) ) RETURNS tinyint(1)
BEGIN
	SET @search = search;
	return true;
    END */$$
DELIMITER ;

/* Function  structure for function  `set_trash` */

/*!50003 DROP FUNCTION IF EXISTS `set_trash` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `set_trash`( trash BOOLEAN ) RETURNS tinyint(1)
BEGIN
	IF trash THEN SET @trash = 1;
	ELSE SET @trash = 0;
	END IF;
	RETURN TRUE;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_form_balance_email` */

/*!50003 DROP FUNCTION IF EXISTS `time_form_balance_email` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_form_balance_email`(userid INT(11), periodyear INT(1)) RETURNS mediumtext CHARSET utf8
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE formname VARCHAR(32);
    DECLARE nprevious DECIMAL(6,3);
    DECLARE ncurrent DECIMAL(6,3);
    DECLARE nused DECIMAL(6,3);
    DECLARE nbalance DECIMAL(6,3);
    DECLARE nprevyear YEAR;
    DECLARE nperiodfrom DATE;
    DECLARE nperiodto DATE;
    
    -- 
    --  
    DECLARE forms CURSOR FOR
       SELECT tfb.year,tf.form, tfb.previous, tfb.current, tfb.used, tfb.balance, tfb.period_from,tfb.period_to
       FROM `time_form_balance` tfb 
       LEFT JOIN `ww_time_form` tf ON tf.`form_id`=tfb.`form_id` AND tf.`deleted`=0 
       WHERE tfb.`deleted`=0 AND tfb.`user_id`=userid AND (tfb.year = periodyear OR YEAR(tfb.period_extension) = periodyear)
       AND tf.form_code != 'BL';
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- 
    -- 
    OPEN forms;
    
    SET @tbody = '';
    REPEAT
       FETCH forms INTO nprevyear,formname,nprevious,ncurrent,nused,nbalance,nperiodfrom,nperiodto;
       
       IF NOT done THEN
          
          SET nprevious = IFNULL(nprevious,0);
          SET ncurrent  = IFNULL(ncurrent,0);
          SET nused     = IFNULL(nused,0);
          SET nbalance  = IFNULL(nbalance,0);
          SET nprevyear = IFNULL(nprevyear,0);
          SET nperiodfrom = IFNULL(nperiodfrom,0);
          SET nperiodto = IFNULL(nperiodto,0);
          
          
          SET @tbody = CONCAT(@tbody,'<tr>');
          SET @tbody = CONCAT(@tbody,'<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">',formname,' <br> <span class="help-block" style="font-size:80%"> ',
		IF(nperiodfrom = '0000-00-00',
			" ",
			DATE_FORMAT(nperiodfrom, '%b %d, %Y')),' - ',
		IF(nperiodto = '0000-00-00',
			" ",
			DATE_FORMAT(nperiodto, '%b %d, %Y')),
		' </span> <br><span class="help-block" style="font-size:80%"> ',nprevyear,'</span> </td>');
          SET @tbody = CONCAT(@tbody,'<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">',IF(nprevious=0,'-',nprevious),'</td>');
          SET @tbody = CONCAT(@tbody,'<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">',IF(ncurrent=0,'-',ncurrent),'</td>');
          SET @tbody = CONCAT(@tbody,'<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">',IF(nused=0,'-',nused),'</td>');
          SET @tbody = CONCAT(@tbody,'<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">',IF(nbalance=0,'-',nbalance),'</td>');
          SET @tbody = CONCAT(@tbody,'<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">',IF(nprevious=0,'-',nprevious),'</td>');
          SET @tbody = CONCAT(@tbody,'<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">&nbsp;</td>');
          SET @tbody = CONCAT(@tbody,'</tr>');
          
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE forms;
    
    RETURN @tbody;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_form_obt_request` */

/*!50003 DROP FUNCTION IF EXISTS `time_form_obt_request` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_form_obt_request`(formsid INT(11)) RETURNS mediumtext CHARSET utf8
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE requestpurpose VARCHAR(250);
    DECLARE requestamount DECIMAL(6,3);
    DECLARE requestremarks TEXT;
    -- 
    --  
    DECLARE forms CURSOR FOR
       SELECT purpose, amount, remarks 
       FROM `ww_time_forms_obt_transpo` tfot 
	LEFT JOIN ww_time_forms_obt_purpose tfop ON tfot.purpose_id = tfop.purpose_id
       WHERE tfot.`forms_id`= formsid;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- 
    -- 
    OPEN forms;
    
    SET @tbody = '';
    REPEAT
       FETCH forms INTO requestpurpose,requestamount,requestremarks;
       
       IF NOT done THEN
          
          SET requestpurpose = requestpurpose;
          SET requestamount  = IFNULL(requestamount,0);
          SET requestremarks = requestremarks;
           
          SET @tbody = CONCAT(@tbody,'<tr>');
          SET @tbody = CONCAT(@tbody,'<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">',requestpurpose,'</td>');
          SET @tbody = CONCAT(@tbody,'<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">',requestamount,'</td>');
          SET @tbody = CONCAT(@tbody,'<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">',requestremarks,'</td>');
          SET @tbody = CONCAT(@tbody,'</tr>');
          
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE forms;
    
    RETURN @tbody;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_get_allowance_meal` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_allowance_meal` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_allowance_meal`( daytypecode VARCHAR(16), employmenttypeid INT(11), ot_hours DECIMAL(6,2) ) RETURNS decimal(5,2)
BEGIN
    
	SET @amt = 0.00;
	SET @mux = 0.00;
	SET @tot = 0.00;
    SELECT tdmr.`multiplier` INTO @mux
    FROM `ww_time_day_type` tdt
    JOIN `ww_time_day_type_allowance` tdta ON tdta.`day_type_id`=tdt.`day_type_id`
    JOIN `ww_time_day_meal` tdm ON tdm.`meal_id`=tdta.`meal_id` AND tdm.`deleted`=0
    JOIN `ww_time_day_meal_range` tdmr ON tdmr.`meal_id`=tdm.`meal_id`
    WHERE tdt.`deleted`=0 AND 
          tdt.`day_type_code`=daytypecode AND 
          ot_hours BETWEEN tdmr.hour_from AND tdmr.hour_to;
	
	SELECT `meal` INTO @amt
	FROM `ww_time_day_allowance` WHERE `employment_type_id`=employmenttypeid;
	
	SET @tot = @amt * @mux;
	
	return @tot;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_allowance_transpo` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_allowance_transpo` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_allowance_transpo`( daytypecode VARCHAR(16), employmenttypeid INT(11), ot_hours DECIMAL(6,2) ) RETURNS decimal(5,2)
BEGIN
    
	SET @amt = 0.00;
	SET @mux = 0.00;
	SET @tot = 0.00;
    SELECT tdtr.`multiplier` INTO @mux
    FROM `ww_time_day_type` tdt
    JOIN `ww_time_day_type_allowance` tdta ON tdta.`day_type_id`=tdt.`day_type_id`
    JOIN `ww_time_day_transpo` tdtp ON tdtp.`transpo_id`=tdta.`transpo_id` AND tdtp.`deleted`=0
    JOIN `ww_time_day_transpo_range` tdtr ON tdtr.`transpo_id`=tdtp.`transpo_id`
    WHERE tdt.`deleted`=0 AND 
          tdt.`day_type_code`=daytypecode AND 
          ot_hours BETWEEN tdtr.hour_from AND tdtr.hour_to;
	
	SELECT `transpo` INTO @amt
	FROM `ww_time_day_allowance` WHERE `employment_type_id`=employmenttypeid;
	
	SET @tot = @amt * @mux;
	
	return @tot;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_approver_with_email` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_approver_with_email` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_approver_with_email`(
	classid INT(11),
	userid INT(11),
	approverid INT(11)
    ) RETURNS tinyint(1)
BEGIN
	
    SET @nApproverID = 0;
    SET @nIsEmail = 0;
    
    -- users
    SELECT `approver_id`, `email` INTO @nApproverID, @nIsEmail
    FROM `ww_approver_class_user`
    WHERE `deleted`=0 AND `class_id`=classid AND `approver_id`=approverid AND `user_id`=userid
    LIMIT 1;
	
	IF @nApproverID > 0 THEN
	   RETURN @nIsEmail;
	END IF;
	
	-- position
    SELECT apc.`approver_id`, apc.`email` INTO @nApproverID, @nIsEmail
    FROM `ww_approver_class_position` apc
    INNER JOIN `users_profile` up ON up.`user_id`=apc.`approver_id`
	WHERE apc.`deleted`=0 AND apc.`class_id`=classid AND apc.`approver_id`=approverid AND apc.`position_id`=up.`position_id`
	LIMIT 1;
	
	IF @nApproverID > 0 THEN
	   RETURN @nIsEmail;
	END IF;
    
    -- department
    SELECT acd.`approver_id`, acd.`email` INTO @nApproverID, @nIsEmail
    FROM `ww_approver_class_department` acd 
    INNER JOIN `users_profile` up ON up.`user_id`=acd.`approver_id` 
    WHERE acd.`deleted`=0 AND acd.`class_id`=classid AND acd.`approver_id`=approverid AND acd.`department_id`=up.`department_id`;
    
	IF @nApproverID > 0 THEN
	   RETURN @nIsEmail;
	END IF;
    
    -- company
    SELECT acc.`approver_id`, acc.`email` INTO @nApproverID, @nIsEmail
    FROM `ww_approver_class_company` acc 
    INNER JOIN `users_profile` up ON up.`user_id`=acc.`approver_id` 
    WHERE acc.`deleted`=0 AND acc.`class_id`=classid AND acc.`approver_id`=approverid AND acc.`company_id`=up.`company_id`;
    
	IF @nApproverID > 0 THEN
	   RETURN @nIsEmail;
	END IF;
    -- approver has no rights to receive email
    RETURN 0;
    
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_break_deduction` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_break_deduction` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_break_deduction`( daytypecode VARCHAR(16), ot_hours DECIMAL(6,2) ) RETURNS decimal(5,2)
BEGIN
    
	SET @deduction = 0.00;
    SELECT tdbr.deduction INTO @deduction
    FROM `ww_time_day_type` tdt
    JOIN `ww_time_day_type_break` tdtb ON tdtb.`day_type_id`=tdt.`day_type_id`
    JOIN `ww_time_day_break` tdb ON tdb.`break_id`=tdtb.`break_id` AND tdb.`deleted`=0
    JOIN `ww_time_day_break_range` tdbr ON tdbr.`break_id`=tdb.`break_id`
    WHERE tdt.`deleted`=0 AND 
          tdt.`day_type_code`=daytypecode AND 
          ot_hours BETWEEN tdbr.hour_from AND tdbr.hour_to;
	
	return @deduction;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_cut_off` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_cut_off` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_cut_off`( dtDate date, comp_id int(11) ) RETURNS date
BEGIN
    
	SET @cut_off = '0000-00-00';
	SELECT cutoff INTO @cut_off
	FROM ww_time_period WHERE dtDate BETWEEN date_from AND date_to AND company_id = comp_id AND deleted = 0 LIMIT 1;
	
	return @cut_off;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_nd_end` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_nd_end` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_nd_end`(
	shiftid int(11), comp_id int(11)
    ) RETURNS time
BEGIN
	set @value = '00:00:00';
	SELECT a.`class_value` into @value
	FROM ww_time_shift_class_company a
	INNER JOIN ww_time_shift_class b ON a.`class_id` = b.`class_id` AND b.`class_code` = 'NIGHT-DIFF-END'
	WHERE shift_id = shiftid AND company_id = comp_id AND b.`deleted` = 0;
	
	return @value;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_nd_start` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_nd_start` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_nd_start`(
	shiftid int(11), comp_id int(11)
    ) RETURNS time
BEGIN
	set @value = '00:00:00';
	SELECT a.`class_value` into @value
	FROM ww_time_shift_class_company a
	INNER JOIN ww_time_shift_class b ON a.`class_id` = b.`class_id` AND b.`class_code` = 'NIGHT-DIFF-START'
	WHERE shift_id = shiftid AND company_id = comp_id AND b.`deleted` = 0;
	
	return @value;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_ot_rate` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_ot_rate` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_ot_rate`( ot_code varchar(32), comp_id int(11), hourly_rate decimal(12,2) ) RETURNS decimal(5,2)
BEGIN
	set @rate = 0.00;
	SELECT overtime_rate into @rate FROM ww_payroll_overtime_rates where overtime_code = ot_code and company_id = comp_id ;
	set @rate = round( @rate * hourly_rate , 2);
	return @rate;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_payroll_date` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_payroll_date` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_payroll_date`(
	dtDate date,
	comp_id int(11)
    ) RETURNS date
BEGIN
	
	set @paydate = '0000-00-00';
	SELECT payroll_date into @paydate
	FROM ww_time_period WHERE dtDate BETWEEN date_from AND date_to AND company_id = comp_id and deleted = 0 LIMIT 1;
	
	return @paydate;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_previous_period` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_previous_period` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_previous_period`( periodid INT(11)) RETURNS int(11)
BEGIN
	SET @nPeriod = 0;
	SET @dtFrom = '0000-00-00';
	SET @dtTo = '0000-00-00';
	SET @nComp = 0;
	SELECT previous_cutoff, DATE_SUB(date_from, INTERVAL 1 DAY), company_id 
	INTO @dtFrom, @dtTo, @nComp
	FROM ww_time_period WHERE period_id = periodid;
	
	SELECT MIN(period_id) INTO @nPeriod 
	FROM ww_time_period WHERE date_from = @dtFrom AND date_to = @dtTo AND company_id = @nComp;
	RETURN @nPeriod;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_sched_in` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_sched_in` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_sched_in`(
	shiftid int(11)
    ) RETURNS varchar(32) CHARSET utf8
BEGIN
	set @sched_id = '';
	SELECT time_start into @sched_id FROM ww_time_shift WHERE shift_id = shiftid and deleted = 0;
	
	return @sched_id;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_sched_out` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_sched_out` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_sched_out`(
	shiftid int(11)
    ) RETURNS varchar(32) CHARSET utf8
BEGIN
	set @sched_out = '';
	SELECT time_end into @sched_out FROM ww_time_shift WHERE shift_id = shiftid and deleted = 0;
	
	return @sched_out;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_shift` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_shift` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_shift`( puserid int(11), dates date ) RETURNS int(11)
BEGIN
	set @shift_id = 0;
	SELECT if(`aux_shift_id` = 0, `shift_id`, `aux_shift_id`) into @shift_id FROM ww_time_record WHERE `user_id` = puserid AND `date` = dates;
	return @shift_id;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_time_in` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_time_in` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_time_in`( puserid int(11), dates date ) RETURNS datetime
BEGIN
	SET @TimeIN = '0000-00-00 00:0:00';
	set @time_in = '0000-00-00 00:0:00';
	SET @aux_time_in = '0000-00-00 00:0:00';
	SELECT time_in, aux_time_in into @time_in, @aux_time_in FROM ww_time_record WHERE user_id = puserid AND `date` = dates;
	if @time_in is null or @aux_time_in < @time_in then
		set @TimeIN = @aux_time_in;
	else 
		set @TimeIN = @time_in;
	end if;
	
	
	return @TimeIN;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_get_time_out` */

/*!50003 DROP FUNCTION IF EXISTS `time_get_time_out` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_get_time_out`( puserid int(11), dates date ) RETURNS datetime
begin
	set @TimeOUT = '0000-00-00 00:0:00';
	set @time_out = '0000-00-00 00:0:00';
	set @aux_time_out = '0000-00-00 00:0:00';
	SELECT time_out, aux_time_out into @time_out, @aux_time_out FROM ww_time_record WHERE user_id = puserid AND `date` = dates;
	if @time_out is null or @time_out < @aux_time_out then
		set @TimeOUT = @aux_time_out;
	else
		set @TimeOUT = @time_out;
	end if;
	
	return @TimeOUT;
    END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_absent` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_absent` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_absent`(userid INT(11), dateid DATE) RETURNS tinyint(1)
BEGIN
    SET @ifabsent = 0;
    
    SELECT IF(COUNT(tf.`forms_id`)=0,1,0) INTO @ifabsent
    FROM `time_forms` tf, `time_forms_date` tfd, `ww_time_form_status` tfs
    WHERE 
       tfd.`date` = dateid AND
       tf.`user_id` = userid AND 
       tf.`forms_id` = tfd.`forms_id` AND
       tf.`form_status_id` = tfs.form_status_id AND tfs.form_status = 'Approved';
    
    RETURN @ifabsent;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_absent_w_in_cutoff` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_absent_w_in_cutoff` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_absent_w_in_cutoff`(userid INT(11), dateid DATE, period_date_from date, period_cutoff date) RETURNS tinyint(1)
BEGIN
    SET @ifabsent = 0;
    
    SELECT IF(COUNT(tf.`forms_id`)=0,0,1) INTO @ifabsent
    FROM `time_forms` tf, `time_forms_date` tfd, `ww_time_form_status` tfs, `ww_time_record` tr
    WHERE 
       tfd.`date` = dateid AND
       tf.`user_id` = userid AND 
       tf.`forms_id` = tfd.`forms_id` AND
       tfd.date = tr.date and
       tf.`form_status_id` = tfs.form_status_id AND tfs.form_status = 'Approved' AND
       (tr.aux_time_in IS NOT NULL OR tr.aux_time_out IS NOT NULL) AND
       tf.`date_approved` > period_cutoff;
    
    RETURN @ifabsent;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_lwop` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_lwop` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_lwop`(userid INT(11), dateid DATE, lwopid INT(1), cutoffdate DATE, cutoffdateFrom DATE) RETURNS decimal(3,2)
BEGIN
    SET @nLWOP = 0;
    
    SELECT IFNULL(SUM(tfd.`day`),0) INTO @nLWOP
    FROM `time_forms` tf, `time_forms_date` tfd, `ww_time_form_status` tfs
    WHERE 
       tfd.`date` = dateid AND
       tf.`user_id` = userid AND 
       tf.`form_id` IN (23,7) AND
       tf.`forms_id` = tfd.`forms_id` AND
       ((tf.`date_approved` < cutoffdate) OR (tfd.`date` BETWEEN cutoffdateFrom AND cutoffdate)) AND
       tf.`form_status_id` = tfs.form_status_id AND tfs.form_status = 'Approved';
    
    RETURN @nLWOP;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_lwp` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_lwp` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_lwp`(userid INT(11), dateid DATE, lwopid INT(1), cutoffdate DATE) RETURNS decimal(3,2)
BEGIN
    SET @nLWP = 0.00;
    
    SELECT IFNULL(SUM(tfd.`day`),0) INTO @nLWP
    FROM `time_forms` tf, `time_forms_date` tfd, `ww_time_form_status` tfs, `ww_time_form` tfc
    WHERE 
       tf.`user_id` = userid AND 
       tf.`forms_id` = tfd.`forms_id` AND
       tfd.`date` = dateid AND
       tf.`form_id` not in (23,7) AND
       tfc.`is_leave` = 1 AND tfc.`form_id` = tf.`form_id` AND
       tf.`form_status_id` = tfs.form_status_id AND tfs.form_status = 'Approved' AND
       tf.`date_approved` < cutoffdate AND
       (tf.form_code != 'ADDL' OR (tf.form_code = 'ADDL' and tf.type='Use'));
           
    RETURN @nLWP;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_ot` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_ot` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_ot`(userid INT(11), dateid DATE) RETURNS decimal(5,2)
BEGIN
    SET @nOvertime = 0.00;
    
    SELECT IFNULL(SUM(tfd.`hrs`),0) INTO @nOvertime
    FROM `time_forms` tf, `time_forms_date` tfd, `ww_time_form_status` tfs, `ww_time_form` tfc
    WHERE 
       tf.`user_id` = userid AND 
       tf.`forms_id` = tfd.`forms_id` AND
       tfd.`date` = dateid AND
       tfc.`form_id` = tf.`form_id` AND
       tf.`form_status_id` = tfs.form_status_id AND tfs.form_status = 'Approved';
    
    RETURN @nOvertime;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_resigned` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_resigned` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_resigned`(userid INT(11), dates DATE) RETURNS tinyint(1)
BEGIN
    SET @resigned = 0;
    SET @resigned_date = (SELECT `resigned_date` FROM `partners` WHERE `user_id`=userid LIMIT 1);
    
    IF IFNULL(@resigned_date,'0000-00-00')='0000-00-00' THEN
       SET @resigned = 0;
    ELSE
       IF dates > @resigned_date THEN
          SET @resigned = 1;
       END IF;
    END IF;
    
    RETURN @resigned;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_shift` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_shift` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_shift`(classcode VARCHAR(32), classgroup VARCHAR(32), userid INT(11), shiftid INT(11), optreturn VARCHAR(32)) RETURNS varchar(64) CHARSET utf8
BEGIN
    
    RETURN IFNULL((SELECT `class_value`
            FROM `time_shift_class_company`,`users_profile`,`partners` 
            WHERE `class_code`=classcode AND 
                  `time_shift_class_company`.`shift_id`=shiftid AND 
                  (IF(classgroup='EMPLOYMENT-TYPE',
                     IF(`time_shift_class_company`.`employment_type_id`='ALL', 1, FIND_IN_SET(`partners`.`employment_type_id`, `time_shift_class_company`.`employment_type_id`)),
                        IF(classgroup='EMPLOYMENT-STATUS',
                           IF(`time_shift_class_company`.`employment_status_id`='ALL', 1, FIND_IN_SET(`partners`.`status_id`, `time_shift_class_company`.`employment_status_id`)),
                              IF(classgroup='PARTNERS-ID',
                                 IF(`time_shift_class_company`.`partners_id`='ALL', 1, FIND_IN_SET(`partners`.`partner_id`, `time_shift_class_company`.`partners_id`)),
                  optreturn)))) AND
                  `users_profile`.`company_id`=`time_shift_class_company`.`company_id` AND 
                  `users_profile`.`user_id`=`partners`.`user_id` AND
                  `users_profile`.`user_id`=userid
            LIMIT 1)
            , optreturn);
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_shift_department` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_shift_department` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_shift_department`(classcode VARCHAR(32), classgroup VARCHAR(32), comp_id INT(11), shiftid INT(11), userid INT(11), optreturn VARCHAR(32)) RETURNS varchar(64) CHARSET utf8
BEGIN
    
    RETURN IFNULL((SELECT `class_value`
            FROM `ww_time_shift_class_company_department`,`users_profile`,`partners` 
            WHERE `class_code`=classcode AND
		IF(classgroup='DEPARTMENT-ID',
                     IF(`ww_time_shift_class_company_department`.`department_id`='ALL', 1, FIND_IN_SET(users_profile.`department_id`, `ww_time_shift_class_company_department`.`department_id`)),optreturn) AND
                  `users_profile`.`company_id`=`ww_time_shift_class_company_department`.`company_id` AND 
                  `users_profile`.`department_id` = `ww_time_shift_class_company_department`.`department_id` AND
                  `users_profile`.`user_id`=`partners`.`user_id` AND
                  `users_profile`.`user_id`=userid AND
                  ww_time_shift_class_company_department.shift_id = shiftid
                  
            LIMIT 1)
            , optreturn);
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_ut` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_ut` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_ut`(userid INT(11), dateid DATE, time_start varchar(20), time_end varchar(2)) RETURNS decimal(5,2)
BEGIN
    SET @nUndertimeAM = 0.00;
    SET @nUndertimePM = 0.00;
    
    SELECT MAX(ifnull((TIMESTAMPDIFF(MINUTE, CONCAT(dateid + INTERVAL IF(time_start='00:00:00', 1, 0) DAY,' ',time_start),tfd.`time_from`) / 60),0)), 
           MAX(ifnull((TIMESTAMPDIFF(minute, tfd.`time_to`, CONCAT(dateid + INTERVAL IF(time_end='00:00:00', 1, 0) DAY,' ',time_end)) / 60),0)) 
    INTO @nUndertimeAM, @nUndertimePM
    FROM `time_forms` tf, `time_forms_date` tfd, `ww_time_form_status` tfs, `ww_time_form` tfc
    WHERE 
       tf.`user_id` = userid AND 
       tf.`forms_id` = tfd.`forms_id` AND
       tfd.`date` = dateid AND
       tfc.`form_id` = tf.`form_id` AND
       tf.`form_code` = 'UT' AND 
       tf.`form_status_id` = tfs.form_status_id AND tfs.form_status = 'Approved';
    
    RETURN @nUndertimeAM + @nUndertimePM;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_ut_checking` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_ut_checking` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_ut_checking`(userid INT(11), dateid DATE) RETURNS decimal(5,2)
BEGIN
    SET @count = 0;
    
    SELECT count(*) INTO @count
    FROM `time_forms` tf, `time_forms_date` tfd, `ww_time_form_status` tfs, `ww_time_form` tfc
    WHERE 
       tf.`user_id` = userid AND 
       tf.`forms_id` = tfd.`forms_id` AND
       tfd.`date` = dateid AND
       tfc.`form_id` = tf.`form_id` AND
       tf.`form_code` = 'UT' AND 
       tf.`form_status_id` = tfs.form_status_id AND tfs.form_status = 'Approved';
    
    RETURN @count;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_period_process_workhrs` */

/*!50003 DROP FUNCTION IF EXISTS `time_period_process_workhrs` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_period_process_workhrs`(userid INT(11), dates DATE) RETURNS decimal(5,2)
BEGIN
    SET @workhrs = (
       SELECT IFNULL(tssc.`class_value`,0) working_hrs
       FROM `time_record` tr
       JOIN `users_profile` up ON tr.`user_id` = up.`user_id`
       JOIN `ww_time_shift_class_company` tssc ON tssc.`shift_id` = IF(tr.`aux_shift_id`>0,tr.`aux_shift_id`,tr.`shift_id`) AND tssc.`company_id` = up.`company_id`
       JOIN `ww_time_shift_class` tsc ON tsc.`class_id` = tssc.`class_id` AND tsc.`deleted` = 0
       WHERE 
          UPPER(tsc.`class_code`) = 'WORKING-HOURS' AND
          tr.`date`    = dates AND
          tr.`user_id` = userid
       LIMIT 1
    );
    RETURN IFNULL(@workhrs,0.00);
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_record_form_lwp` */

/*!50003 DROP FUNCTION IF EXISTS `time_record_form_lwp` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_record_form_lwp`(userid INT(11), year_id INT(1), month_id INT(1)) RETURNS decimal(3,2)
BEGIN
    SET @nLWP = 0.00;
    
    SELECT IFNULL(SUM(tfd.`day`),0) INTO @nLWP
    FROM `ww_time_forms` tf, `ww_time_forms_date` tfd, `ww_time_form_status` tfs, `ww_time_form` tfc
    WHERE 
       tf.`deleted` = 0 AND
       tf.`user_id` = userid AND 
       tf.`forms_id` = tfd.`forms_id` AND
       YEAR(tfd.`date`) = year_id AND
       MONTH(tfd.`date`) = month_id AND
       tfc.`is_leave` = 1 AND tfc.`form_id` = tf.`form_id` AND
       tf.`form_status_id` = tfs.form_status_id AND tfs.form_status = 'Approved' AND
       -- TIMESTAMPDIFF(DAY,  tf.`created_on`, tf.`date_from`) < 14 AND
       TIMESTAMPDIFF(DAY,  tf.`date_approved`, tf.`date_from`) < 13 ;
    RETURN @nLWP;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_record_list_forms` */

/*!50003 DROP FUNCTION IF EXISTS `time_record_list_forms` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_record_list_forms`(dateid DATE, userid INT(11)) RETURNS tinyint(1)
BEGIN
    SET @formcount=0;
    
    SELECT COUNT(time_forms.forms_id) INTO @formcount
    FROM ww_time_forms time_forms, ww_time_forms_date time_forms_date
    WHERE time_forms.forms_id=time_forms_date.forms_id AND time_forms.user_id=userid AND time_forms_date.`date`=dateid AND
    time_forms.deleted=0 AND time_forms_date.deleted=0;
    
    
    RETURN @formcount;
  
END */$$
DELIMITER ;

/* Function  structure for function  `time_validate_attendance_deduction` */

/*!50003 DROP FUNCTION IF EXISTS `time_validate_attendance_deduction` */;
DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` FUNCTION `time_validate_attendance_deduction`(
	nUserID int(11),   	-- employee subject for adjustment
	dtDate date,   		-- date that has deduction
	nUnit decimal(12,2), 	-- unit deducted 
	sType varchar(32)	-- type of deduction
    ) RETURNS decimal(12,2)
BEGIN
	-- validate the data of affected dates
	SET @nUnit = 0;
	set @nAdjustment = 0;
	SET @nAbsent = 0;
	SET @lwop = 0;
	if sType = 'ABSENCES' then
		SELECT absent, ( ifnull(absent,0) * hrs_rendered ),( IFNULL(lwop,0) * hrs_rendered ) into @nAbsent, @nUnit, @lwop FROM ww_time_record_summary WHERE user_id = nUserID AND `date` = dtDate LIMIT 1;
		IF @nAbsent = 1 tHEN
		   SET @nAdjustment = 0;
		ELSE
		   if @lwop = 0 then
			SET @nAdjustment = @nUnit - nUnit;
		   end if;
		END IF;
	elseif sType = 'LWOP' then
		SELECT absent, ( ifnull(lwop,0) * hrs_rendered ) into @nAbsent, @nUnit FROM ww_time_record_summary WHERE user_id = nUserID AND `date` = dtDate LIMIT 1;
		IF @nAbsent = 1 THEN
		   SET @nAdjustment = 0;
		ELSE
		   SET @nAdjustment = @nUnit - nUnit;
		END IF;
	elseif sType = 'DEDUCTION_LATE' then
		SELECT ifnull(late,0) into @nUnit FROM ww_time_record_summary WHERE user_id = nUserID AND `date` = dtDate LIMIT 1;
		SET @nAdjustment = @nUnit - nUnit;
	elseif sType = 'DEDUCTION_UNDERTIME' then
		SELECT ifnull(undertime,0) into @nUnit FROM ww_time_record_summary WHERE user_id = nUserID AND `date` = dtDate LIMIT 1;
		SET @nAdjustment = @nUnit - nUnit;
	end if;
		
	return @nAdjustment;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `log_msg` */

/*!50003 DROP PROCEDURE IF EXISTS  `log_msg` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `log_msg`(msg VARCHAR(255))
BEGIN
	insert into logtable (`log`) values(msg);	
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_approvers_change_applicable` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_approvers_change_applicable` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_approvers_change_applicable`(IN classid INT(11), userid INT(11), positionid INT(11), departmentid INT(11), companyid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE done_1 TINYINT(11) DEFAULT 0;
    DECLARE done_2 TINYINT(11) DEFAULT 0;
    DECLARE done_3 TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE uid INT;
    DECLARE ccode VARCHAR(16);
    
    
    -- STEP 1: scan class user
    -- 
    DECLARE user_approvers CURSOR FOR
       SELECT up.`user_id`
       FROM `ww_approver_class_user` acp
       INNER JOIN `users_profile` up ON acp.`user_id` = up.`user_id`
       WHERE 
             acp.`position_id` = positionid AND 
             acp.`department_id` = departmentid AND 
             acp.`company_id` = companyid AND
             acp.`user_id` = userid AND 
             acp.`deleted` = 0 AND
             up.`active` = 1
       GROUP BY up.`user_id`;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    SET ccode = (SELECT `class_code` FROM `ww_approver_class` WHERE `class_id`=classid LIMIT 1);
    
       OPEN user_approvers;
       REPEAT
          FETCH user_approvers INTO uid;
          IF NOT done THEN
             SET rec = rec + 1;
             
             IF ccode = '201REQ' THEN
                SET rec = rec;
             ELSEIF ccode='PPA' THEN
                CALL sp_approvers_change_applicable_pending('PPA-PLANNING',uid);
                CALL sp_approvers_change_applicable_pending('PPA-APPRAISAL',uid);
             ELSEIF ccode='REC' THEN
                SET rec = rec;
             ELSE
                CALL sp_approvers_change_applicable_pending(ccode,uid);
             END IF;
                 
          END IF;
       UNTIL done END REPEAT;
       CLOSE user_approvers;
    
    
    -- STEP 2: scan class position
    -- 
    IF rec = 0 THEN
       BEGIN
          DECLARE position_approvers CURSOR FOR
          SELECT up.`user_id`
          FROM `ww_approver_class_position` acp
          INNER JOIN `users_profile` up 
                  ON 
                     acp.`position_id` = up.`position_id` AND
                     acp.`department_id` = up.`department_id` AND
                     acp.`company_id` = up.`company_id` 
          WHERE 
                acp.`position_id` = positionid AND 
                acp.`department_id` = departmentid AND 
                acp.`company_id` = companyid AND
                acp.`deleted`=0 AND
                up.`active` = 1
          GROUP BY up.`user_id`;
          DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done_1 = 1;
       
          OPEN position_approvers;
          REPEAT
             FETCH position_approvers INTO uid;
             IF NOT done_1 THEN
                SET rec = rec + 1;
             
                IF ccode = '201REQ' THEN
                   SET rec = rec;
                ELSEIF ccode='PPA' THEN
                   SET @strings = CONCAT('PPA-PLANNING',uid);
                   INSERT INTO ww_system_messages (msg_type, msg_code, msg) VALUES ('attention','PLANNING',@strings);
                   CALL sp_approvers_change_applicable_pending('PPA-PLANNING',uid);
                   SET @strings = CONCAT('PPA-APPRAISAL',uid);
                   CALL sp_approvers_change_applicable_pending('PPA-APPRAISAL',uid);
                   INSERT INTO ww_system_messages (msg_type, msg_code, msg) VALUES ('attention','APPRAISAL',@strings);
                ELSEIF ccode='REC' THEN
                   SET rec = rec;
                ELSE
                   CALL sp_approvers_change_applicable_pending(ccode,uid);
                END IF;
             
             END IF;
          UNTIL done_1 END REPEAT;
          CLOSE position_approvers;
       END; 
    END IF;    
    
    
    -- STEP 3: scan class department
    -- 
    IF rec = 0 THEN
       BEGIN
          DECLARE department_approvers CURSOR FOR
          SELECT up.`user_id`
          FROM `ww_approver_class_department` acp
          INNER JOIN `users_profile` up 
                  ON 
                     acp.`department_id` = up.`department_id` AND
                     acp.`company_id` = up.`company_id`
          WHERE 
                acp.`department_id` = departmentid AND 
                acp.`company_id` = companyid AND
                acp.`deleted` = 0 AND
                up.`active` = 1
          GROUP BY up.`user_id`;
          DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done_2 = 1;
       
          OPEN department_approvers;
          REPEAT
             FETCH department_approvers INTO uid;
             IF NOT done_2 THEN
                SET rec = rec + 1;
             
                IF ccode = '201REQ' THEN
                   SET rec = rec;
                ELSEIF ccode='PPA' THEN
                   CALL sp_approvers_change_applicable_pending('PPA-PLANNING',uid);
                   CALL sp_approvers_change_applicable_pending('PPA-APPRAISAL',uid);
                ELSEIF ccode='REC' THEN
                   SET rec = rec;
                ELSE
                   CALL sp_approvers_change_applicable_pending(ccode,uid);
                END IF;
             
             END IF;
          
          UNTIL done_2 END REPEAT;
          CLOSE department_approvers;
       END; 
    END IF;    
    
    -- 
    -- STEP 3: scan class company
    -- 
    IF rec = 0 THEN
       BEGIN
          DECLARE company_approvers CURSOR FOR
          SELECT up.`user_id`
          FROM `ww_approver_class_company` acp
          INNER JOIN `users_profile` up 
                  ON 
                     acp.`company_id` = up.`company_id`
          WHERE 
                acp.`company_id` = companyid AND
                acp.`deleted` = 0 AND
                up.`active` = 1
          GROUP BY up.`user_id`;
          DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done_3 = 1;
       
          OPEN company_approvers;
          REPEAT
             FETCH company_approvers INTO uid;
             IF NOT done_3 THEN
                SET rec = rec + 1;
             
                IF ccode = '201REQ' THEN
                   SET rec = rec;
                ELSEIF ccode='PPA' THEN
                   CALL sp_approvers_change_applicable_pending('PPA-PLANNING',uid);
                   CALL sp_approvers_change_applicable_pending('PPA-APPRAISAL',uid);
                ELSEIF ccode='REC' THEN
                   SET rec = rec;
                ELSE
                   CALL sp_approvers_change_applicable_pending(ccode,uid);
                END IF;
             
             END IF;
          UNTIL done_3 END REPEAT;
          CLOSE company_approvers;
       END; 
    END IF;    
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_approvers_change_applicable_pending` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_approvers_change_applicable_pending` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_approvers_change_applicable_pending`(IN classcode VARCHAR(16), IN userid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userids INT;
    DECLARE approverid INT;
    DECLARE appraisalid INT;
    DECLARE planningid INT;
    
    IF classcode = '201REQ' THEN
       BEGIN
          SET rec = 0;
       END;
       
    ELSEIF classcode='PPA-PLANNING' THEN
       BEGIN
       DECLARE forms CURSOR FOR
       SELECT  pap.`planning_id`, pap.`user_id`
       FROM ww_performance_planning_applicable pap 
	   WHERE pap.user_id = userid AND ( status_id IN (0,1,2,3));
          DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
          -- START TRANSACTION;
          OPEN forms;
          REPEAT
             FETCH forms INTO planningid, userid;
             IF NOT done THEN
                -- remove existing approver
	            DELETE FROM ww_performance_planning_approver 
	            WHERE planning_id = planningid AND user_id = userid;
                -- insert new approver set
                CALL `sp_performance_planning_populate_approvers`(planningid, userid); 
                -- update main form status
		UPDATE ww_performance_planning_applicable 
		SET to_user_id = IF( status_id = 0, userid, IF(status_id = 1, userid, getFirstApprover(planningid, userid)) ),
		    status_id = IF( status_id = 0, 0, IF(status_id = 1, 1,2) )
		WHERE planning_id = planningid AND user_id = userid;   
             END IF;
          UNTIL done END REPEAT;
          -- END TRANSACTION
          
          CLOSE forms;
       END;
       
    ELSEIF classcode='PPA-APPRAISAL' THEN
       BEGIN
          DECLARE forms CURSOR FOR               
	      SELECT  pap.`appraisal_id`, pap.`user_id`
	      FROM ww_performance_appraisal_applicable pap 
	      WHERE pap.user_id = userid AND ( status_id IN (0,1,2,3));
          DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
          -- START TRANSACTION;
          OPEN forms;
          REPEAT
             FETCH forms INTO appraisalid, userid;
             IF NOT done THEN
                -- remove existing approver/s
                DELETE FROM ww_performance_appraisal_approver 
                WHERE appraisal_id = appraisalid AND user_id = userid;
                -- insert new approver set
                CALL `sp_performance_appraisal_populate_approvers`(appraisalid, userid);
                -- update main record status
		UPDATE ww_performance_planning_applicable 
		SET to_user_id = IF( status_id = 0, userid, IF(status_id = 1, userid,getFirstApprover(appraisalid, userid)) ),
		    status_id = IF( status_id = 0, 0, IF(status_id = 1, 1,2) )
		WHERE appraisal_id = appraisalid AND user_id = userid;   
                SET rec = rec + 1;
             END IF;
          UNTIL done END REPEAT;
          -- END TRANSACTION
          
          CLOSE forms;
       END;
       
    ELSEIF classcode='REC' THEN
       BEGIN
          SET rec = 0;
       END;
       
    ELSE
       BEGIN
          -- TIME FORMS
          DECLARE forms CURSOR FOR
          SELECT  tr.`forms_id`, tr.`user_id` 
          FROM `time_forms` tr 
          WHERE user_id = userid AND form_status_id IN (2,3,4,5) AND UPPER(form_code) = classcode;
          DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
          
          -- START TRANSACTION;
          OPEN forms;
          REPEAT
             FETCH forms INTO recordid, userids;
             IF NOT done THEN
                -- remove existing approvers
	        DELETE FROM ww_time_forms_approver WHERE forms_id = recordid;
	        -- insert approvers
                CALL `sp_time_forms_populate_approvers`(recordid, userid);
                -- update main form status to for-approval
                UPDATE ww_time_forms SET form_status_id = 2 WHERE forms_id = recordid;      
	        SET rec = rec + 1;
             END IF;
          UNTIL done END REPEAT;
          -- END TRANSACTION
          
          CLOSE forms;
       END;
       
    END IF;
           
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_approver_assign_all` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_approver_assign_all` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_approver_assign_all`(IN `userid` INT(11))
BEGIN
	DECLARE done TINYINT(11) DEFAULT 0;
	DECLARE rec INT(11) DEFAULT 0;
	DECLARE recordid INT;
	DECLARE userids INT;
	DECLARE approverid INT;
	DECLARE appraisalid INT;
	DECLARE planningid INT;
	DECLARE classcode VARCHAR(16);
		
	DECLARE forms CURSOR FOR
		SELECT ac.class_code
		FROM ww_approver_class ac
		WHERE ac.deleted=0 
		AND ac.class_code != '201REQ';
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	
	
	DELETE FROM ww_approver_class_user
	WHERE user_id=userid;
	
	OPEN forms;
	REPEAT 
		FETCH forms INTO classcode;
		IF NOT done THEN
					
			INSERT INTO `ww_approver_class_user`
			(`class_id`,`user_id`,`position_id`,`department_id`,`company_id`,`approver_id`,`alias`,`condition`,`sequence`,
			`approver`,`email`,`created_by`,`created_on`,`modified_by`,`modified_on`,`deleted`)
			
			SELECT ac.class_id,acu.`user_id`,acu.`position_id`,acu.`department_id`,acu.`company_id`,acu.`approver_id`,acu.
			`alias`,acu.`condition`,acu.`sequence`,acu.`approver`,acu.`email`,acu.`created_by`,acu.`created_on`,
			acu.`modified_by`,NOW(),acu.`deleted` 
			FROM ww_approver_class_users acu
			INNER JOIN ww_approver_class ac
			WHERE acu.`user_id`=userid
			AND ac.`class_code`=classcode
			AND acu.`deleted`=0
			;	
			
			CALL sp_approvers_change_applicable_pending(classcode,userid);
		END IF;
		UNTIL done END REPEAT;
	CLOSE forms;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_clearance_email_notification` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_clearance_email_notification` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_clearance_email_notification`()
BEGIN
    
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE recordid INT;
    
    DECLARE userid INT;
    DECLARE email VARCHAR(128);
    DECLARE full_name VARCHAR(128);
       
    DECLARE users_emails CURSOR FOR
	SELECT u.user_id, u.`email`, u.full_name 
	FROM ww_users u 
	LEFT JOIN ww_roles r ON r.`role_id` = u.`role_id` 
	WHERE r.`role_id` = 2 AND r.deleted=0;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    -- [1]      
    SET @system_url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
    SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
    SET @system_author = (SELECT `value` FROM `ww_config` WHERE `key`='author' LIMIT  1);
        
    -- [1] retrieve the email template
    --  
    SET @emailto = 'webmaster@hdisystech.com';
    SET @emailsubject = '';
    SET @emailbody = '';
    SET @email_body = '';
    SET @name_list = '';
       
    SELECT `subject`,`body` INTO @emailsubject, @emailbody
    FROM `ww_system_template`
    WHERE `code` = 'CLEARANCE-NOTIFICATION' LIMIT 1;
       
              
    IF @emailsubject <> '' THEN
       -- [2] replace variables
       SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @system_url);
       SET @emailbody = REPLACE(@emailbody, '{{system_author}}', @system_author);
       
       
	   OPEN users_emails;
	    
	   REPEAT
	       FETCH users_emails INTO userid,email,full_name;
	       
	       SET @emailto = email;
	       SET @notify_to = userid;
	       SET @name_to_notify = full_name;
	       SET @bcc = 'webmaster@hdisystech.com';
	       
	       
		      
		IF NOT done THEN
		        SET @email_body = @emailbody;
			#SET @emailto = to_email;
			SET rec = rec + 1;
			
		        
		BEGIN
              
                 DECLARE done_1 TINYINT(11) DEFAULT 0;
                 DECLARE turnaround INT;
		 DECLARE display_name VARCHAR(128);
                 DECLARE user_list CURSOR FOR
			SELECT 
			IFNULL(CASE WHEN CURDATE() > ww_partners_clearance.`effectivity_date` THEN DATEDIFF(CURDATE(),ww_partners_clearance.`effectivity_date`) ELSE DATEDIFF(ww_partners_clearance.`effectivity_date`, CURDATE()) END, 0) AS "turnaround",
			`ww_partners`.`alias` AS "display_name"								
			FROM (`ww_partners_clearance`) 
			INNER JOIN ww_partners_clearance_status ON `ww_partners_clearance`.`status_id` = `ww_partners_clearance_status`.`status_id` 
			INNER JOIN ww_partners ON `ww_partners_clearance`.`partner_id` = `ww_partners`.`partner_id` WHERE `ww_partners_clearance_status`.`status` IN('Open','Ongoing') AND ww_partners_clearance.`deleted` = 0 ; 
                 DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done_1 = 1;
                 
		      
                 OPEN user_list;
	    
	             REPEAT
	             FETCH user_list INTO turnaround,display_name ;
	       
	                IF NOT done_1 THEN
				IF turnaround = 23 THEN
				  
				   INSERT INTO `ww_system_email_queue` (`to`, `subject`,`body`)
				   SELECT @emailto, @emailsubject, REPLACE(@email_body, '{{employee_names}}', display_name);
				   
				   INSERT INTO `ww_system_feeds` (`user_id`,`display_name`,`feed_content`,`uri`,`recipient_id`,`createdon`,`deleted`) 
				VALUES
				  ( @notify_to, @name_to_notify, CONCAT('The Exit clearance of ',display_name,' is about to reach 30 days by (Date of exact 30 days). Please be reminded of the standard process and the notification to concerned Department heads. Wednesday, next status meeting.'), 'en/partners/clearance', @notify_to, CURDATE(), 0 ); 
				END IF; 
	                END IF;
	             
	             UNTIL done_1 END REPEAT;
	    
	             CLOSE user_list;
	             
              
              END; -- BEGIN
		        
		        
		END IF;	-- first done	  
		
		
	              
		      
	    UNTIL done END REPEAT;
	    
	    CLOSE users_emails;
	    
	    -- COMMIT;
	    SELECT rec;
     END IF;
     
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_get_last_cutoff_date` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_get_last_cutoff_date` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_get_last_cutoff_date`(IN class_value INT, IN datefrom DATE, IN compid INT)
BEGIN
	DECLARE datetoprevious DATE;
	
	IF class_value = 1 THEN
	
		SELECT date_from, date_to
		FROM ww_time_period
		WHERE (datefrom BETWEEN date_from AND date_to) AND company_id IN(compid);
		
	ELSEIF class_value = 2 THEN
	
		SELECT DATE(date_from - INTERVAL 1 DAY) INTO datetoprevious 
		FROM ww_time_period WHERE datefrom BETWEEN date_from AND date_to AND company_id IN(compid);
		
		SELECT (SELECT date_from FROM ww_time_period
			WHERE date_to=datetoprevious AND company_id IN(compid)) AS date_from,
			date_to
		FROM ww_time_period
		WHERE (datefrom BETWEEN date_from AND date_to) AND company_id IN(compid);
		
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_get_leave_balance` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_get_leave_balance` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_get_leave_balance`(IN iuser_id INT(11), IN iperiod_extension DATE, IN iform_id INT(11))
BEGIN
	SELECT ww_time_form_balance.*, ww_time_form.form  
	FROM ww_time_form_balance
	JOIN ww_time_form ON ww_time_form.form_id = ww_time_form_balance.form_id
	WHERE ww_time_form_balance.deleted = 0 
	  AND ww_time_form.`deleted` = 0
	  AND user_id = iuser_id
	  AND IF(iform_id = 0, 1, ww_time_form_balance.form_id = iform_id)
	  AND iperiod_extension BETWEEN ww_time_form_balance.period_from AND ww_time_form_balance.period_extension
	  AND ww_time_form.form_code <> 'ADDL'
	  AND balance > 0
	  ORDER BY `year` DESC
	  limit 1;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_manpower_plan_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_manpower_plan_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_manpower_plan_email`(IN planid INT(11),IN emailtype varchar(50))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE userid INT;
    DECLARE planid INT;
    DECLARE email VARCHAR(128);
    DECLARE approver VARCHAR(32);
    DECLARE classid INT;
    DECLARE ownerid INT;
    
    DECLARE approvers CURSOR FOR
       SELECT mp.`plan_id`, mpa.`user_id`, u.`email`, mpa.`display_name`, mp.`user_id` ownid
       FROM `ww_recruitment_manpower_plan_approver` mpa
       INNER JOIN `users` u ON u.user_id=mpa.user_id
       INNER JOIN `users_profile` up ON up.user_id=mpa.user_id
       INNER JOIN `ww_recruitment_manpower_plan` mp ON mp.plan_id = mpa.plan_id
       WHERE mpa.`deleted`=0 AND mpa.`plan_status_id`>=2 AND IFNULL(u.`email`,'')<>'';
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    OPEN approvers;
    
    REPEAT
       FETCH approvers INTO planid, userid, email, approver, ownerid;
       
       IF NOT done THEN
           SET rec = rec + 1;
           
        --   IF time_get_approver_with_email(classid,ownerid,userid) = 1 THEN
              -- START
           
           -- [1] retrieve the application
           SET @planid = 0;
           SET @displayname = '';
           SET @createdon = '';
           SET @userid = 0;
          
           SELECT `user_id`, `plan_id`, if(`display_name` is not null,`display_name`,''),DATE_FORMAT(`created_on`, '%M-%e %l%p, %W')
           INTO @userid, @planid, @displayname, @createdon
           FROM `ww_recruitment_manpower_plan`
           WHERE `plan_id`=planid LIMIT 1;
           
           -- [3] retrieve the email template
           SET @emailto = email;
           SET @emailsubject = '';
           SET @emailbody = '';
	   set @code_type = case
		when emailtype = 'approved' THEN 'recruitment_manpower_plan_approved'
		when emailtype = 'for_approval' THEN 'recruitment_manpower_plan_for_approval' 
		WHEN emailtype = 'disapproved' THEN 'recruitment_manpower_plan_disapproved' 
		else 'recruitment_manpower_plan_for_approval' 
		END;
	   
           SELECT `subject`,`body` INTO @emailsubject, @emailbody
           FROM `ww_system_template`
           WHERE `code` = @code_type LIMIT 1;
           IF @emailsubject <> '' THEN
              -- [2] replace variables
              SET @emailbody = REPLACE(@emailbody, '{{approver}}', approver);
              SET @emailbody = REPLACE(@emailbody, '{{requestor}}', @displayname);
           
              -- {{link}}
              SET @url = get_config('System','URL');
	          IF RIGHT(TRIM(@url),1) <> '/' THEN
	             SET @url = CONCAT(TRIM(@url),'/');
	          END IF;
	   
              -- {{header/email logo}}
              SET @logo = get_config('System','print_logo'); 
	          IF TRIM(@logo) <> '' THEN
	             SET @logo = CONCAT(@url,@logo);
	          ELSE
	             SET @logo = CONCAT(@url,get_config('System','logo'));
	          END IF;
	   	         
              SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='annual_manpower_planning' LIMIT 1);
              SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
              SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
              SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
              SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
              SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
               
              -- [3] insert to table
              IF TRIM(@emailbody) <> '' THEN
                 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
                 SELECT @emailto, @emailsubject, @emailbody;
              END IF;
              
              -- SELECT @emailto, @emailsubject, @emailbody;
              
             -- END IF; -- time_get_approver_with_email(classid,ownerid,userid) = 1
              
           END IF;
        END IF;
        
    UNTIL done END REPEAT;
    
    CLOSE approvers;
    
    -- SELECT rec;
    
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_change_password_reminder` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_change_password_reminder` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_change_password_reminder`()
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE emails VARCHAR(128);
    
    DECLARE users_emails CURSOR FOR
       SELECT `email` 
       FROM `users`
       WHERE `hash`='$2a$08$hRV4eko18h6qPQ0gn7.f.eKk9O9Dv7nPKfZbN1mhregMrBYi3sR6i' AND active=1;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    SET @system_fromaddress = (SELECT `value` FROM `ww_config` WHERE `key`='from_address' LIMIT  1);
    SET @emailto = @system_fromaddress;
    SET @emailsubject = '';
    SET @emailbody = '';
    
    -- retrieve the email template
    SELECT `subject`,`body` INTO @emailsubject, @emailbody
    FROM `ww_system_template` WHERE `code` = 'PASSWORD-REMINDER' LIMIT 1;
           
    IF @emailsubject <> '' THEN
       -- {{link}}
       SET @url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
	   IF RIGHT(TRIM(@url),1) <> '/' THEN
	      SET @url = CONCAT(TRIM(@url),'/');
	   END IF;
	         
       SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
       SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
       SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       SET @count_recipients = 0;
       SET @is_hundred = 0;
       SET @bcc = '';
       
       OPEN users_emails;
       REPEAT
          FETCH users_emails INTO emails;
       
	      IF NOT done THEN
             SET @bcc = CONCAT(emails,', ', @bcc);
	         SET @is_hundred = @count_recipients % 100;
	         IF @is_hundred = 0 AND @count_recipients > 0 THEN
	            INSERT INTO `ww_system_email_queue` (`to`, `bcc`, `subject`,`body`)
	            SELECT @emailto, @bcc, @emailsubject, @emailbody;
	            SET @bcc = '';
	         END IF;
	      END IF;
	      SET @count_recipients = @count_recipients + 1;
	       
	   UNTIL done END REPEAT;
	    
	   CLOSE users_emails;
       
	   IF (CHAR_LENGTH(@bcc) > 0) THEN 
	      INSERT INTO `ww_system_email_queue` (`to`, bcc, `subject`,`body`)
	      SELECT @emailto, @bcc, @emailsubject, @emailbody;
	   END IF;
    END IF;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_clearance_action_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_clearance_action_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_clearance_action_email`(IN clearanceid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE signatory VARCHAR(32);
        
       SET @userid = 0;
       SET @email = '';
       SET @recipientAlias = '';
       SET @displayname = '';
       SET @user_email_cc = '';   
       
       -- [1] retrieve the recipient email and firstname 
        SELECT pc.alternate_email, u.email, u.full_name INTO @email, @user_email_cc, @displayname
        FROM `ww_partners_clearance` pc
        INNER JOIN `ww_partners` p ON p.`partner_id`=pc.`partner_id`
        INNER JOIN `ww_users` u ON u.user_id=p.user_id AND u.`active`=1 
        WHERE pc.`deleted`=0 AND pc.`clearance_id`=clearanceid LIMIT 1;
       
       -- [3] retrieve the email template
       SET @emailto = @email;
       SET @emailsubject = '';
       SET @emailbody = '';
       
       SELECT `subject`,`body` INTO @emailsubject, @emailbody
       FROM `ww_system_template`
       WHERE `code` = 'CLEARANCE-ACTION' LIMIT 1;
       
       
       IF @emailsubject <> '' THEN
         
           -- {{header/email logo}}
           SET @logo = get_config('System','print_logo'); 
         IF TRIM(@logo) <> '' THEN
            SET @logo = CONCAT(@url,@logo);
         ELSE
            SET @logo = CONCAT(@url,get_config('System','logo'));
         END IF;
               
           SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='forms_request' LIMIT 1);
           SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
           SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
           SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
           SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
           SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
                      
           -- [3] insert to table
           INSERT INTO `ww_system_email_queue` (`to`, `cc`, `subject`,`body`)
           SELECT @emailto, @user_email_cc, @emailsubject, @emailbody;
        
       END IF; -- @emailsubject <> '' THEN
       
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_clearance_email_notification` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_clearance_email_notification` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_clearance_email_notification`()
BEGIN
    
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE recordid INT;
    
    DECLARE userid INT;
    DECLARE email VARCHAR(128);
    DECLARE full_name VARCHAR(128);
       
    DECLARE users_emails CURSOR FOR
	SELECT u.user_id, u.`email`, u.full_name 
	FROM ww_users u 
	LEFT JOIN ww_roles r ON r.`role_id` = u.`role_id` 
	WHERE r.`role_id` = 2 AND r.deleted=0;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    -- [1]      
    SET @system_url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
    SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
    SET @system_author = (SELECT `value` FROM `ww_config` WHERE `key`='author' LIMIT  1);
    SET @system_fromaddress = (SELECT `value` FROM `ww_config` WHERE `key`='from_address' LIMIT  1);
        
    -- [1] retrieve the email template
    --  
    SET @emailto = @system_fromaddress;
    SET @emailsubject = '';
    SET @emailbody = '';
    SET @email_body = '';
    set @name_list = '';
       
    SELECT `subject`,`body` INTO @emailsubject, @emailbody
    FROM `ww_system_template`
    WHERE `code` = 'CLEARANCE-NOTIFICATION' LIMIT 1;
       
              
    IF @emailsubject <> '' THEN
       -- [2] replace variables
       SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @system_url);
       SET @emailbody = REPLACE(@emailbody, '{{system_author}}', @system_author);
       
       
	   OPEN users_emails;
	    
	   REPEAT
	       FETCH users_emails INTO userid,email,full_name;
	       
	       SET @emailto = email;
	       SET @notify_to = userid;
	       SET @name_to_notify = full_name;
	       SET @bcc = @system_fromaddress;
	       
	       
		      
		IF NOT done THEN
		        SET @email_body = @emailbody;
			#SET @emailto = to_email;
			SET rec = rec + 1;
			
		        
		BEGIN
              
                 DECLARE done_1 TINYINT(11) DEFAULT 0;
                 DECLARE turnaround int;
		 DECLARE display_name VARCHAR(128);
                 DECLARE user_list CURSOR FOR
			SELECT 
			IFNULL(CASE WHEN CURDATE() > ww_partners_clearance.`effectivity_date` THEN DATEDIFF(CURDATE(),ww_partners_clearance.`effectivity_date`) ELSE DATEDIFF(ww_partners_clearance.`effectivity_date`, CURDATE()) END, 0) AS "turnaround",
			`ww_partners`.`alias` AS "display_name"								
			FROM (`ww_partners_clearance`) 
			INNER JOIN ww_partners_clearance_status ON `ww_partners_clearance`.`status_id` = `ww_partners_clearance_status`.`status_id` 
			INNER JOIN ww_partners ON `ww_partners_clearance`.`partner_id` = `ww_partners`.`partner_id` WHERE `ww_partners_clearance_status`.`status` IN('Open','Ongoing') AND ww_partners_clearance.`deleted` = 0 ; 
                 DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done_1 = 1;
                 
		      
                 OPEN user_list;
	    
	             REPEAT
	             FETCH user_list INTO turnaround,display_name ;
	       
	                IF NOT done_1 THEN
				if turnaround = 23 then
				  
				   INSERT INTO `ww_system_email_queue` (`to`, `subject`,`body`)
				   SELECT @emailto, @emailsubject, REPLACE(@email_body, '{{employee_names}}', display_name);
				   
				   INSERT INTO `ww_system_feeds` (`user_id`,`display_name`,`feed_content`,`uri`,`recipient_id`,`createdon`,`deleted`) 
				VALUES
				  ( @notify_to, @name_to_notify, CONCAT('The Exit clearance of ',display_name,' is about to reach 30 days by (Date of exact 30 days). Please be reminded of the standard process and the notification to concerned Department heads. Wednesday, next status meeting.'), 'en/partners/clearance', @notify_to, CURDATE(), 0 ); 
				end if; 
	                END IF;
	             
	             UNTIL done_1 END REPEAT;
	    
	             CLOSE user_list;
	             
              
              END; -- BEGIN
		        
		        
		END IF;	-- first done	  
		
		
	              
		      
	    UNTIL done END REPEAT;
	    
	    CLOSE users_emails;
	    
	    -- COMMIT;
	    SELECT rec;
     END IF;
     
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_demographics_gender` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_demographics_gender` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_demographics_gender`(IN pYear INT(1), IN pMonth INT(1))
BEGIN
    SET @female = 0;
    SET @male   = 0;
    
    SELECT SUM(IF(UPPER(up.`gender`)='FEMALE',1,0)), SUM(IF(UPPER(up.`gender`)='MALE',1,0))
    INTO @female, @male
    FROM `partners` p, `users_profile` up
    WHERE p.`user_id` = up.`user_id` AND up.`gender` <> '' AND
          -- Check for Resignation Date later: p.`resigned_date` 
          IF(IFNULL(p.`resigned_date`,'0000-00-00') = '0000-00-00', 
             1, 
             IF(DATE_FORMAT(p.`resigned_date`,'%Y%m') <= DATE_FORMAT(CONCAT(pYear,'-',pMonth,'-01'),'%Y%m'), 0, 1)) AND
          IF(DATE_FORMAT(p.`effectivity_date`,'%Y%m') <= DATE_FORMAT(CONCAT(pYear,'-',pMonth,'-01'),'%Y%m'), 1, 0);
    
    SELECT `ag_gen`.`age_gender` `gender`, `ag_grp`.`age_group` AS `edad`, 
           COUNT(`up`.`user_id`) bilang,
           COUNT(`up`.`user_id`)/(IF(UPPER(`ag_gen`.`age_gender`)='FEMALE', @female, @male)) bahagi, 
           @female, @male, pYear, pMonth
    FROM `ww_partners_age_group` `ag_grp`
    JOIN `ww_partners_age_gender` `ag_gen`
    LEFT JOIN `partners` p ON 
                              IF(IFNULL(p.`resigned_date`,'0000-00-00') = '0000-00-00', 
                                 1, 
                                 IF(DATE_FORMAT(p.`resigned_date`,'%Y%m') <= DATE_FORMAT(CONCAT(pYear,'-',pMonth,'-01'),'%Y%m'), 0, 1)) AND
                              IF(DATE_FORMAT(p.`effectivity_date`,'%Y%m') <= DATE_FORMAT(CONCAT(pYear,'-',pMonth,'-01'),'%Y%m'), 1, 0)
    LEFT JOIN `users_profile` up ON p.`user_id` = up.`user_id` AND  up.`gender` = `ag_gen`.`age_gender` AND `up`.`age` BETWEEN `ag_grp`.`age_fr` AND `ag_grp`.`age_to`
    GROUP BY 1,2;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_demographics_status` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_demographics_status` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_demographics_status`(IN pYear INT(1), IN pMonth INT(1))
BEGIN
    SET @female = 0;
    SET @male   = 0;
    
    SELECT SUM(IF(UPPER(up.`gender`)='FEMALE',1,0)), SUM(IF(UPPER(up.`gender`)='MALE',1,0))
    INTO @female, @male
    FROM `partners` p, `users_profile` up
    WHERE p.`user_id` = up.`user_id` AND up.`gender` <> '' AND
          -- Check for Resignation Date later: p.`resigned_date` 
          IF(IFNULL(p.`resigned_date`,'0000-00-00') = '0000-00-00', 
             1, 
             IF(DATE_FORMAT(p.`resigned_date`,'%Y%m') <= DATE_FORMAT(CONCAT(pYear,'-',pMonth,'-01'),'%Y%m'), 0, 1)) AND
          IF(DATE_FORMAT(p.`effectivity_date`,'%Y%m') <= DATE_FORMAT(CONCAT(pYear,'-',pMonth,'-01'),'%Y%m'), 1, 0);
    
    SELECT pet.`employment_status`, pet.`employment_status_id`, 
           IF(up.`gender`='','Male', IFNULL(up.`gender`, 'Male')) `gender`, 
           COUNT(p.`status_id`) bilang,
           COUNT(p.`status_id`)/(IF(UPPER(up.`gender`)='FEMALE', @female, @male)) bahagi,
           @female, @male, pYear, pMonth
    FROM `ww_partners_employment_status` pet
    INNER JOIN `partners` p ON p.`status_id` = pet.`employment_status_id` AND
         IF(IFNULL(p.`resigned_date`,'0000-00-00') = '0000-00-00', 
            1, 
            IF(DATE_FORMAT(p.`resigned_date`,'%Y%m') <= DATE_FORMAT(CONCAT(pYear,'-',pMonth,'-01'),'%Y%m'), 0, 1)) AND
         IF(DATE_FORMAT(p.`effectivity_date`,'%Y%m') <= DATE_FORMAT(CONCAT(pYear,'-',pMonth,'-01'),'%Y%m'), 1, 0)
    INNER JOIN `users_profile` up ON up.`user_id` = p.`user_id` -- AND TRIM(up.`gender`) <> '' 
    WHERE pet.`active` = 1
    GROUP BY 1, 2, 3 
    
    ORDER BY 2;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_demographics_type` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_demographics_type` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_demographics_type`(IN pYear INT(1), IN pMonth INT(1))
BEGIN
    
    SELECT pet.`employment_type`, p.`employment_type_id`, pp.`key_value`, COUNT(p.`employment_type_id`) key_count
    FROM `partners` p, `ww_partners_employment_type` pet, `ww_partners_personal` pp
    WHERE p.`employment_type_id` = pet.`employment_type_id` AND 
          pet.`deleted` = 0 AND
          pp.`deleted` = 0 ANd pp.`key` = 'gender' AND
          IF(IFNULL(p.`resigned_date`,'0000-00-00') = '0000-00-00', 
             1, 
             IF(DATE_FORMAT(p.`resigned_date`,'%Y%m') <= DATE_FORMAT(CONCAT(pYear,'-',pMonth,'-01'),'%Y%m'), 0, 1)) AND
          IF(DATE_FORMAT(p.`effectivity_date`,'%Y%m') <= DATE_FORMAT(CONCAT(pYear,'-',pMonth,'-01'),'%Y%m'), 1, 0)
    GROUP BY 2, 3;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_email_anniversary` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_email_anniversary` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_email_anniversary`()
BEGIN
    
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE recordid INT;
    
    DECLARE userid INT;
    DECLARE email VARCHAR(128);
    DECLARE photo VARCHAR(128);
    DECLARE fname VARCHAR(64);
       
    DECLARE users_emails CURSOR FOR
       SELECT `u`.`email`,
              IFNULL(`up`.`photo`,'assets/img/avatar.png') AS `photo`,
              `up`.`firstname`
       FROM (((`users` `u` 
       JOIN `users_profile` `up` ON((`u`.`user_id` = `up`.`user_id`))) 
       JOIN `users_position` `upos` ON((`up`.`position_id` = `upos`.`position_id`))) 
       JOIN `partners` `p` ON(((`u`.`user_id` = `p`.`user_id`) AND (IFNULL(`p`.`resigned_date`,0) = 0)))) 
       WHERE `u`.`active` = 1 AND MONTH(p.effectivity_date) = MONTH(CURDATE()) AND DAY(p.effectivity_date) = DAY(CURDATE());
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    -- [1]      
    SET @system_url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
    SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
    SET @system_author = (SELECT `value` FROM `ww_config` WHERE `key`='author' LIMIT  1);
        
    -- [1] retrieve the email template
    --  
    SET @system_fromaddress = (SELECT `value` FROM `ww_config` WHERE `key`='from_address' LIMIT  1);
    SET @emailto = @system_fromaddress;
    SET @emailsubject = '';
    SET @emailbody = '';
    SET @email_body = '';
       
    SELECT `subject`,`body` INTO @emailsubject, @emailbody
    FROM `ww_system_template`
    WHERE `code` = 'EMPLOYEE-ANNIV-NOTIFICATION' LIMIT 1;
       
              
    IF @emailsubject <> '' THEN
       -- [2] replace variables
       SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @system_url);
       SET @emailbody = REPLACE(@emailbody, '{{system_author}}', @system_author);
       
       
	   OPEN users_emails;
	    
	   REPEAT
	       FETCH users_emails INTO email,photo,fname;
	       
	       SET @emailto = email;
	       SET @bcc = @system_fromaddress;
	       
	       
		      
		IF NOT done THEN
		        SET @email_body = @emailbody;
		        SET @email_body = REPLACE(@email_body, '{{employee_name}}', fname);
			#SET @emailto = to_email;
			SET rec = rec + 1;
			INSERT INTO `ww_system_email_queue` (`to`, `subject`,`body`)
		        SELECT @emailto, @emailsubject, @email_body;
		END IF;		      
		      
	    UNTIL done END REPEAT;
	    
	    CLOSE users_emails;
	    
	    -- COMMIT;
	    SELECT rec;
     END IF;
     
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_email_bday` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_email_bday` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_email_bday`()
BEGIN
    
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE recordid INT;
    
    DECLARE userid INT;
    DECLARE email VARCHAR(128);
    DECLARE photo VARCHAR(128);
    DECLARE fname VARCHAR(64);
    DECLARE cname VARCHAR(128);
       
    DECLARE users_emails CURSOR FOR
       SELECT `u`.`email`,
              IFNULL(`up`.`photo`,'assets/img/avatar.png') AS `photo`,
              `up`.`display_name`,
              `up`.`company`
       FROM (((`users` `u` 
       JOIN `users_profile` `up` ON((`u`.`user_id` = `up`.`user_id`))) 
       JOIN `users_position` `upos` ON((`up`.`position_id` = `upos`.`position_id`))) 
       JOIN `partners` `p` ON(((`u`.`user_id` = `p`.`user_id`) AND (IFNULL(`p`.`resigned_date`,0) = 0)))) 
       WHERE `u`.`active` = 1 AND `getdaystimeline`(`nextbday2`(`up`.`birth_date`))='Today';
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    -- [1] retrieve the memo
    SET @memo_id = 0;
    SET @memo_type_id = 0;
    SET @memo_type = '';
    SET @memo_title = '';
    SET @attachment = '';
    SET @memo_body = '';
    SET @created_on = '';
    SET @fileattach = '';
       
    SET @system_url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
    SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
    SET @system_author = (SELECT `value` FROM `ww_config` WHERE `key`='author' LIMIT  1);
        
    -- [1] retrieve the email template
    --  
    SET @system_fromaddress = (SELECT `value` FROM `ww_config` WHERE `key`='from_address' LIMIT  1);
    SET @emailto = @system_fromaddress;
    SET @emailsubject = '';
    SET @emailbody = '';
    SET @email_body = '';
       
    SELECT `subject`,`body` INTO @emailsubject, @emailbody
    FROM `ww_system_template`
    WHERE `code` = 'BIRTHDAY-GREETING' LIMIT 1;
       
              
    IF @emailsubject <> '' THEN
       -- [2] replace variables
       SET @emailbody = REPLACE(@emailbody, '{{memo_type}}', @memo_type);
       SET @emailbody = REPLACE(@emailbody, '{{memo_body}}', @memo_body);
       SET @emailbody = REPLACE(@emailbody, '{{memo_created}}', DATE_FORMAT(NOW(),'%M %e, %Y - %W'));
       SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @system_url);
       SET @emailbody = REPLACE(@emailbody, '{{system_author}}', @system_author);
       SET @emailbody = REPLACE(@emailbody, '{{memo_title}}', 'Birthday Greetings');
       
       -- [3] FORMATTING
       OPEN users_emails;
       REPEAT
          FETCH users_emails INTO email,photo,fname,cname;
	  SET @emailto = email;
	  SET @bcc = @system_fromaddress;
	  --  
	  IF NOT done THEN
             SET @attachment = CONCAT(@attachment,
                                      '<p style="display:inline-block;vertical-align:top;width:30%">',
                                      '<img src="', 
                                      @system_url, IF(TRIM(IFNULL(photo,''))='', '/uploads/users/avatar.jpg', photo),
                                      '" height="125px" width="125px" alt="Please enable images" style="border-radius:50%;padding:15px" /><br>',
                                      '<b>',fname,'</b><br>of ',
                                      cname,
                                      '</p>'
                               );
             SET rec = rec + 1;
          END IF;
	  -- 
       UNTIL done END REPEAT;
	    
       CLOSE users_emails;
       
       
       -- [4] EMAILING
       IF rec > 0 THEN
       BEGIN
          DECLARE done_1 TINYINT(11) DEFAULT 0;
          DECLARE to_email VARCHAR(100);
       
          DECLARE users_recipient CURSOR FOR
          SELECT u.email FROM `users` u
          WHERE u.`deleted`=0 AND u.`active`=1 AND TRIM(IFNULL(u.`email`,''))<>'' ORDER BY 1;
          DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done_1 = 1;
                 
          SET @count_recipients = 0;
          SET @is_hundred = 0;
          SET @emailto = @system_fromaddress;
          SET @bcc = '';
          SET @email_body = REPLACE(@emailbody, '{{memo_attachment}}', @attachment);
          
          OPEN users_recipient;
          
          REPEAT
             FETCH users_recipient INTO to_email;
            
             IF NOT done_1 THEN
                SET @bcc = CONCAT(to_email,', ', @bcc);
	        SET @is_hundred = @count_recipients % 50;
	        IF @is_hundred = 0 AND @count_recipients > 0 THEN
	           INSERT INTO `ww_system_email_queue` (`to`, `bcc`, `subject`,`body`)
	           SELECT @emailto, @bcc, @emailsubject, @email_body;
	           SET @bcc = '';
                END IF;
             END IF;
                
             SET @count_recipients = @count_recipients + 1;
          
          UNTIL done_1 END REPEAT;
    
          CLOSE users_recipient;
          
	  IF (CHAR_LENGTH(@bcc) > 0) THEN 
	     INSERT INTO `ww_system_email_queue` (`to`, bcc, `subject`,`body`)
	     SELECT @emailto, @bcc, @emailsubject, @email_body;
	  END IF;
       END;
       END IF; -- [4] END
       
       
       SELECT rec;
       
   END IF; -- IF @emailsubject
   
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_incident_change_pending_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_incident_change_pending_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_incident_change_pending_approvers`(IN user_ids VARCHAR(256), IN class_id INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE cocincidents CURSOR FOR
       SELECT  tr.`incident_id`, tr.`involved_partners` FROM `ww_partners_incident` tr WHERE `deleted`=0
       AND FIND_IN_SET(involved_partners, user_ids) AND incident_status_id IN (2,3);
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- START TRANSACTION;
        
    OPEN cocincidents;
    
    REPEAT
       FETCH cocincidents INTO recordid, userid;
       
       IF NOT done THEN
	   DELETE FROM ww_partners_incident_approver WHERE incident_id = recordid;
           CALL `sp_partners_incident_populate_approvers`(recordid, userid);
           UPDATE ww_partners_incident SET incident_status_id = 2 WHERE incident_id = recordid;      
	   SET rec = rec + 1;
	   
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE cocincidents;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_incident_populate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_incident_populate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_incident_populate_approvers`(IN incidentid INT(11), IN userid INT(11))
BEGIN
	  -- 
          -- [0] Override from USER
          -- 
          
          SET @rec = 0;
          SET @class = '';
          
	  SELECT c.`class_code`, COUNT(a.`id`) INTO @class, @rec
          FROM `ww_approver_class_user` a
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE a.`user_id`=userid AND c.`class_code`='IR' AND a.deleted = 0;
          
          IF @rec > 0 THEN
             INSERT INTO `ww_partners_incident_approver`
             (`incident_id`, `user_id`, `condition`, `sequence`, `incident_status_id`)
             SELECT incidentid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,8))
             FROM `ww_approver_class_user` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`approver_id`<>userid
             AND a.user_id = userid
             GROUP BY 2
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE           
          
          -- 
          -- [1] Override from POSITION
          -- 
          
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id` AND b.department_id=a.department_id
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE b.`user_id`=userid AND c.`class_code`= 'IR';
          
          IF @rec > 0 THEN
             INSERT INTO `ww_partners_incident_approver`
             (`incident_id`, `user_id`, `condition`, `sequence`, `incident_status_id`)
             SELECT incidentid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,8))
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.department_id=a.department_id AND u.user_id=userid
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
             GROUP BY 2
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
	     WHERE b.`user_id`=userid AND c.`class_code`= 'IR'
             AND a.`approver_id`<>userid;
          
             IF @rec > 0 THEN
                INSERT INTO `ww_partners_incident_approver`
                (`incident_id`, `user_id`, `condition`, `sequence`, `incident_status_id`)
                SELECT incidentid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,8))
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
                WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
                GROUP BY 2
                ON DUPLICATE KEY UPDATE `incident_status_id`=VALUES(`incident_status_id`), `sequence`=VALUES(`sequence`), `deleted`=0;             
             ELSE
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
	        WHERE b.`user_id`=userid AND c.`class_code`= 'IR'
                AND a.`approver_id`<>userid;
          
                IF @rec > 0 THEN
                   INSERT INTO `ww_partners_incident_approver`
                   (`incident_id`, `user_id`, `condition`, `sequence`, `incident_status_id`)
                   SELECT incidentid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,8))
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
                   GROUP BY 2
                   ON DUPLICATE KEY UPDATE `deleted`=0;             
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
          end if;   
          END IF; -- IF POSITION        
          IF @rec > 0 THEN
	     -- email approver/s application content
	     CALL sp_partners_ir_email(incidentid,'for_approval');
          END IF;               
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_ir_approver_approve_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_ir_approver_approve_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_ir_approver_approve_email`(IN receiver varchar(50),IN emailto VARCHAR(50))
BEGIN
   SET @emailsubject = '';
   SET @emailbody = '';
   set @emailto = emailto;
         
   SELECT `subject`,`body` INTO @emailsubject, @emailbody
   FROM `ww_system_template`
   WHERE `code` = 'IR-APPROVER-APPROVED' LIMIT 1;
   
   IF @emailsubject <> '' THEN
      -- [2] replace variables
      SET @emailbody = REPLACE(@emailbody, '{{receiver_name}}', receiver);
   
      -- {{link}}
      SET @url = get_config('System','URL');
	  IF RIGHT(TRIM(@url),1) <> '/' THEN
	     SET @url = CONCAT(TRIM(@url),'/');
	  END IF;
   
      -- {{header/email logo}}
      SET @logo = get_config('System','print_logo'); 
	  IF TRIM(@logo) <> '' THEN
	     SET @logo = CONCAT(@url,@logo);
	  ELSE
	     SET @logo = CONCAT(@url,get_config('System','logo'));
	  END IF;
		 
      SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='incident_report' LIMIT 1);
      SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
      SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
      SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
      SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
      SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       
      -- [3] insert to table
      IF TRIM(@emailbody) <> '' THEN
	 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
	 SELECT @emailto, @emailsubject, @emailbody;
      END IF; 
   END IF; 
    
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_ir_da_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_ir_da_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_ir_da_email`(IN receiver varchar(50),IN emailto VARCHAR(50),IN involve_employee VARCHAR(50))
BEGIN
   SET @emailsubject = '';
   SET @emailbody = '';
   set @emailto = emailto;
         
   SELECT `subject`,`body` INTO @emailsubject, @emailbody
   FROM `ww_system_template`
   WHERE `code` = 'IR-DA' LIMIT 1;
   
   IF @emailsubject <> '' THEN
      -- [2] replace variables
      SET @emailbody = REPLACE(@emailbody, '{{receiver_name}}', receiver);
      SET @emailbody = REPLACE(@emailbody, '{{involve_employee}}', involve_employee);
   
      -- {{link}}
      SET @url = get_config('System','URL');
	  IF RIGHT(TRIM(@url),1) <> '/' THEN
	     SET @url = CONCAT(TRIM(@url),'/');
	  END IF;
   
      -- {{header/email logo}}
      SET @logo = get_config('System','print_logo'); 
	  IF TRIM(@logo) <> '' THEN
	     SET @logo = CONCAT(@url,@logo);
	  ELSE
	     SET @logo = CONCAT(@url,get_config('System','logo'));
	  END IF;
		 
      SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='incident_report' LIMIT 1);
      SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
      SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
      SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
      SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
      SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       
      -- [3] insert to table
      IF TRIM(@emailbody) <> '' THEN
	 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
	 SELECT @emailto, @emailsubject, @emailbody;
      END IF; 
   END IF; 
    
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_ir_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_ir_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_ir_email`(IN incidentid INT(11),IN emailtype varchar(50))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE userid INT;
    DECLARE incident_id INT;
    DECLARE email VARCHAR(128);
    DECLARE approver VARCHAR(32);
    DECLARE ownerid INT;
    
    DECLARE approvers CURSOR FOR
       SELECT pia.`incident_id`, pia.`user_id`, u.`email`, u.`full_name`, pin.`complainants` ownid
       FROM `ww_partners_incident_approver` pia
       INNER JOIN `ww_partners_incident` pin ON pia.incident_id=pin.incident_id
       INNER JOIN `users` u ON u.user_id=pia.user_id
       INNER JOIN `users_profile` up ON up.user_id=pia.user_id
       WHERE pia.`deleted`=0 AND pia.incident_id=incidentid AND pia.`incident_status_id`=2 AND IFNULL(u.`email`,'')<>'';
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    OPEN approvers;
    
    REPEAT
       FETCH approvers INTO incident_id, userid, email, approver, ownerid;
       
       IF NOT done THEN
           SET rec = rec + 1;
                  	              
        --   IF time_get_approver_with_email(classid,ownerid,userid) = 1 THEN
              -- START
           
           -- [1] retrieve the application
           SET @incidentid = 0;
           SET @displayname = '';
           SET @createdon = '';
           SET @userid = 0;
          
           SELECT `user_id`, `incident_id`, if(`full_name` is not null,`full_name`,''),DATE_FORMAT(`pin`.`created_on`, '%M-%e %l%p, %W')
           INTO @userid, @incidentid, @complainant, @createdon
           FROM `ww_partners_incident` pin
           INNER JOIN `users` u ON u.user_id=pin.complainants
           WHERE `incident_id`=incidentid LIMIT 1;
           	                   
           -- [3] retrieve the email template
           SET @emailto = email;
           SET @emailsubject = '';
           SET @emailbody = '';
	   set @code_type = case
		when emailtype = 'approved' THEN 'IR-APPROVED'
		when emailtype = 'for_approval' THEN 'IR-FOR-APPROVAL' 
		WHEN emailtype = 'disapproved' THEN 'recruitment_manpower_plan_disapproved' 
		else 'recruitment_manpower_plan_for_approval' 
		END;
	   SET @status = CASE
		WHEN emailtype = 'approved' THEN 'Approved'
		WHEN emailtype = 'for_approval' THEN 'For Approval'  
		ELSE 'Draft' 
		END;
			   
           SELECT `subject`,`body` INTO @emailsubject, @emailbody
           FROM `ww_system_template`
           WHERE `code` = @code_type LIMIT 1;
           IF @emailsubject <> '' THEN
              -- [2] replace variables
              SET @emailbody = REPLACE(@emailbody, '{{approver}}', approver);
              SET @emailbody = REPLACE(@emailbody, '{{complainant}}', @complainant);
              SET @emailbody = REPLACE(@emailbody, '{{status}}', @status);
           
              -- {{link}}
              SET @url = get_config('System','URL');
	          IF RIGHT(TRIM(@url),1) <> '/' THEN
	             SET @url = CONCAT(TRIM(@url),'/');
	          END IF;
	   
              -- {{header/email logo}}
              SET @logo = get_config('System','print_logo'); 
	          IF TRIM(@logo) <> '' THEN
	             SET @logo = CONCAT(@url,@logo);
	          ELSE
	             SET @logo = CONCAT(@url,get_config('System','logo'));
	          END IF;
	   	         
              SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='incident_report' LIMIT 1);
              SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
              SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
              SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
              SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
              SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
               
              -- [3] insert to table
              IF TRIM(@emailbody) <> '' THEN
                 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
                 SELECT @emailto, @emailsubject, @emailbody;
              END IF;
              
              -- SELECT @emailto, @emailsubject, @emailbody;
              
             -- END IF; -- time_get_approver_with_email(classid,ownerid,userid) = 1
              
           END IF;
        END IF;
        
    UNTIL done END REPEAT;
    
    CLOSE approvers;
    
    -- SELECT rec;
    
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_ir_hearing_schedule_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_ir_hearing_schedule_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_ir_hearing_schedule_email`(IN receiver varchar(50),IN emailto VARCHAR(50),IN involve_employee VARCHAR(50), IN dates VARCHAR(50))
BEGIN
   SET @emailsubject = '';
   SET @emailbody = '';
   set @emailto = emailto;
         
   SELECT `subject`,`body` INTO @emailsubject, @emailbody
   FROM `ww_system_template`
   WHERE `code` = 'IR-HEARING-SCHEDULE' LIMIT 1;
   
   IF @emailsubject <> '' THEN
      -- [2] replace variables
      SET @emailbody = REPLACE(@emailbody, '{{receiver_name}}', receiver);
      SET @emailbody = REPLACE(@emailbody, '{{involve_employee}}', involve_employee);
      SET @emailbody = REPLACE(@emailbody, '{{dates}}', dates);
   
      -- {{link}}
      SET @url = get_config('System','URL');
	  IF RIGHT(TRIM(@url),1) <> '/' THEN
	     SET @url = CONCAT(TRIM(@url),'/');
	  END IF;
   
      -- {{header/email logo}}
      SET @logo = get_config('System','print_logo'); 
	  IF TRIM(@logo) <> '' THEN
	     SET @logo = CONCAT(@url,@logo);
	  ELSE
	     SET @logo = CONCAT(@url,get_config('System','logo'));
	  END IF;
		 
      SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='incident_report' LIMIT 1);
      SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
      SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
      SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
      SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
      SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       
      -- [3] insert to table
      IF TRIM(@emailbody) <> '' THEN
	 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
	 SELECT @emailto, @emailsubject, @emailbody;
      END IF; 
   END IF; 
    
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_ir_immediate_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_ir_immediate_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_ir_immediate_email`(IN receiver varchar(50),IN emailto VARCHAR(50),IN complainant VARCHAR(50))
BEGIN
   SET @emailsubject = '';
   SET @emailbody = '';
   set @emailto = emailto;
         
   SELECT `subject`,`body` INTO @emailsubject, @emailbody
   FROM `ww_system_template`
   WHERE `code` = 'IR-FOR-APPROVAL' LIMIT 1;
   
   IF @emailsubject <> '' THEN
      -- [2] replace variables
      SET @emailbody = REPLACE(@emailbody, '{{approver}}', receiver);
      SET @emailbody = REPLACE(@emailbody, '{{complainant}}', complainant);
      SET @emailbody = REPLACE(@emailbody, '{{status}}', 'Approval');
   
      -- {{link}}
      SET @url = get_config('System','URL');
	  IF RIGHT(TRIM(@url),1) <> '/' THEN
	     SET @url = CONCAT(TRIM(@url),'/');
	  END IF;
   
      -- {{header/email logo}}
      SET @logo = get_config('System','print_logo'); 
	  IF TRIM(@logo) <> '' THEN
	     SET @logo = CONCAT(@url,@logo);
	  ELSE
	     SET @logo = CONCAT(@url,get_config('System','logo'));
	  END IF;
		 
      SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='incident_report' LIMIT 1);
      SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
      SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
      SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
      SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
      SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       
      -- [3] insert to table
      IF TRIM(@emailbody) <> '' THEN
	 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
	 SELECT @emailto, @emailsubject, @emailbody;
      END IF; 
   END IF; 
    
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_ir_nte_from_hr_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_ir_nte_from_hr_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_ir_nte_from_hr_email`(IN receiver varchar(50),IN emailto VARCHAR(50),IN involve VARCHAR(50))
BEGIN
   SET @emailsubject = '';
   SET @emailbody = '';
   set @emailto = emailto;
         
   SELECT `subject`,`body` INTO @emailsubject, @emailbody
   FROM `ww_system_template`
   WHERE `code` = 'IR-NTE-FROM-HR' LIMIT 1;
   
   IF @emailsubject <> '' THEN
      -- [2] replace variables
      SET @emailbody = REPLACE(@emailbody, '{{receiver_name}}', receiver);
      SET @emailbody = REPLACE(@emailbody, '{{involve_employee}}', involve);
   
      -- {{link}}
      SET @url = get_config('System','URL');
	  IF RIGHT(TRIM(@url),1) <> '/' THEN
	     SET @url = CONCAT(TRIM(@url),'/');
	  END IF;
   
      -- {{header/email logo}}
      SET @logo = get_config('System','print_logo'); 
	  IF TRIM(@logo) <> '' THEN
	     SET @logo = CONCAT(@url,@logo);
	  ELSE
	     SET @logo = CONCAT(@url,get_config('System','logo'));
	  END IF;
		 
      SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='incident_report' LIMIT 1);
      SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
      SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
      SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
      SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
      SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       
      -- [3] insert to table
      IF TRIM(@emailbody) <> '' THEN
	 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
	 SELECT @emailto, @emailsubject, @emailbody;
      END IF; 
   END IF; 
    
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_loan_application_approval` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_loan_application_approval` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_loan_application_approval`(IN loanApplicationId INT, IN userid INT, IN statusid INT, IN usercomment TEXT)
BEGIN
   /* This will insert records to ww_time_record and executed thru events
      PARAMETER:
         statusid : 1=APPROVED, 0=DECLINE
      LAST Change: 2014-04-11 initial
                   2014-04-11 
   */
   -- [1]
   UPDATE `ww_partners_loan_application_approver`
   SET
      `comment`        = usercomment,
      `comment_date`   = NOW(),
      `loan_application_status_id` = IF(statusid = 1, 6, 7)
   WHERE 
      `loan_application_id` = loanApplicationId AND 
      `user_id` = userid AND
      `deleted` = 0
   LIMIT 1;
             
   -- set next approver
   IF statusid = 1 THEN
      SET @seq = (SELECT MAX(sequence) FROM `ww_partners_loan_application_approver` WHERE `loan_application_id`=loanApplicationId AND `loan_application_status_id`=6 AND `deleted`=0)+1;
      UPDATE `ww_partners_loan_application_approver`
      SET `loan_application_status_id` = 2
      WHERE `loan_application_id` = loanApplicationId AND `sequence` = @seq AND `deleted`=0 AND `condition` = 'By Level';
   END IF;
  
   -- [2] Update status by sequence to approver
   -- Change the status of the next approver
   -- 20150722 Only work on BY LEVEL
   
   -- 20150722 inlcude EITHER OF and ALL on approval condition
   -- [2.5] Check condition on approver   
   SET @conditions = '';
   
   SELECT `condition` INTO @conditions 
   FROM `ww_partners_loan_application_approver`
   WHERE 
      `loan_application_id` = loanApplicationId AND 
      `user_id` = userid AND
      `deleted` = 0
   LIMIT 1;
   
   -- [3] Update status on header
   -- Check if all approver already approved
   IF(@conditions = 'Either Of') THEN
	   UPDATE `ww_partners_loan_application`
	   SET
	      `loan_application_status_id` = IF(statusid=1, 6, 7),
	      `date_approved` = IF(statusid=1, NOW(), `date_approved`),
	      `date_declined` = IF(statusid=1, `date_declined`, NOW())
	   WHERE 
	      `loan_application_id` = loanApplicationId 
	   LIMIT 1;
	   
	   -- [1]
	   UPDATE `ww_partners_loan_application_approver`
	   SET
	      `comment`        = usercomment,
	      `comment_date`   = NOW(),
	      `loan_application_status_id` = IF(statusid = 1, 6, 7)
	   WHERE 
	      `loan_application_id` = loanApplicationId AND 
	      `deleted` = 0
	   LIMIT 1;
   
   ELSE
	   SET @appCount    = 0;
	   SET @appApproved = 0;
	   SET @appDeclined = 0;
	   
	   SELECT COUNT(*), SUM(IF(`loan_application_status_id`=6,1,0)), SUM(IF(`loan_application_status_id`=7,1,0)) 
	   INTO @appCount, @appApproved, @appDeclined
	   FROM `ww_partners_loan_application_approver`
	   WHERE `loan_application_id`=loanApplicationId;
	   
	   UPDATE `ww_partners_loan_application`
	   SET
	      `loan_application_status_id` = IF(@appCount=@appApproved, 6, IF(@appCount=@appDeclined, 7, IF(@appDeclined > 0, 7, `loan_application_status_id`))),
	      `date_approved` = IF(@appCount=@appApproved, NOW(), `date_approved`),
	      `date_declined` = IF(@appDeclined > 0, NOW(), `date_declined`)
	   WHERE 
	      `loan_application_id` = loanApplicationId
	   LIMIT 1;	      
   END IF;
   
   INSERT INTO `logtable` (`log`) VALUES (concat(@appCount,' ',@appApproved,' ',loanApplicationId));   
   
   -- [4] Push email 
   IF (@appCount = @appApproved) OR (@appDeclined > 0) THEN
      CALL sp_partners_loan_application_email_status(loanApplicationId);
   ELSE
      CALL sp_partners_loan_application_email(loanApplicationId);
   END IF;
   -- 
   
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_loan_application_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_loan_application_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_loan_application_email`(IN loan_application_id INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    DECLARE loanapplicationid INT;
    DECLARE email VARCHAR(128);
    DECLARE approver VARCHAR(32);
    DECLARE classid INT;
    DECLARE ownerid INT;
    
    DECLARE approvers CURSOR FOR
       SELECT plaa.`loan_application_id`, plaa.`user_id`, u.`email`, up.`firstname`, plaa.`loan_application_id`, appc.`class_id`, pla.`user_id` ownid
       FROM `ww_partners_loan_application_approver` plaa
       INNER JOIN `users` u ON u.user_id=plaa.user_id
       INNER JOIN `users_profile` up ON up.user_id=plaa.user_id
       INNER JOIN ww_partners_loan_application pla ON pla.loan_application_id = plaa.loan_application_id
       INNER JOIN ww_approver_class appc ON UPPER(appc.`class_code`)= UPPER(pla.`loan_type_code`)
       WHERE plaa.`deleted`=0 AND plaa.`loan_application_status_id`=2 AND plaa.`loan_application_id`=loan_application_id AND IFNULL(u.`email`,'')<>'';
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    OPEN approvers;
    
    REPEAT
       FETCH approvers INTO recordid, userid, email, approver, loanapplicationid, classid, ownerid;
       
       IF NOT done THEN
           SET rec = rec + 1;
           
        --   IF time_get_approver_with_email(classid,ownerid,userid) = 1 THEN
              -- START
           
           -- [1] retrieve the application
           SET @loantypeid = 0;
           SET @loantypecode = '';
           SET @loantype = '';
           SET @displayname = '';
           SET @createdon = '';
           SET @userid = 0;
           SELECT `user_id`, `loan_type_id`, `loan_type_code`, `display_name`,DATE_FORMAT(`created_on`, '%M-%e %l%p, %W')
           INTO @userid, @loantypeid, @loantypecode, @displayname, @createdon
           FROM `ww_partners_loan_application`
           WHERE `loan_application_id`=loanapplicationid LIMIT 1;
           
           
           -- [2] retrieve the form 
           SELECT `loan_type` INTO @loantype
           FROM `ww_partners_loan_type` WHERE `loan_type_id`=@loantypeid LIMIT 1;
       
           
           -- [3] retrieve the email template
           SET @emailto = email;
           SET @emailsubject = '';
           SET @emailbody = '';
       
           SELECT `subject`,`body` INTO @emailsubject, @emailbody
           FROM `ww_system_template`
           WHERE `code` = @loantypecode LIMIT 1;
           
           
           
           IF @emailsubject <> '' THEN
              -- [2] replace variables
              SET @emailbody = REPLACE(@emailbody, '{{alias}}', approver);
              SET @emailbody = REPLACE(@emailbody, '{{fullname}}', @displayname);
              SET @emailbody = REPLACE(@emailbody, '{{loantype}}', @loantype);
              SET @emailbody = REPLACE(@emailbody, '{{createdon}}', @createdon);
                        
              -- {{link}}
              SET @url = get_config('System','URL');
	          IF RIGHT(TRIM(@url),1) <> '/' THEN
	             SET @url = CONCAT(TRIM(@url),'/');
	          END IF;
	   
              -- {{header/email logo}}
              SET @logo = get_config('System','print_logo'); 
	          IF TRIM(@logo) <> '' THEN
	             SET @logo = CONCAT(@url,@logo);
	          ELSE
	             SET @logo = CONCAT(@url,get_config('System','logo'));
	          END IF;
	   	         
              SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='loan_application' LIMIT 1);
              SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
              SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
              SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
              SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
              SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
               
              -- [3] insert to table
              IF TRIM(@emailbody) <> '' THEN
                 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
                 SELECT @emailto, @emailsubject, @emailbody;
              END IF;
              
           END IF;
        END IF;
        
    UNTIL done END REPEAT;
    
    CLOSE approvers;
    
    -- SELECT rec;
    
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_loan_application_email_status` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_loan_application_email_status` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_loan_application_email_status`(IN loan_application_id INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE approver VARCHAR(32);
    DECLARE comments TEXT;
    
    DECLARE approvers CURSOR FOR
       SELECT up.`firstname`, plaa.`comment`
       FROM `ww_partners_loan_application_approver` plaa
       JOIN `users_profile` up ON up.user_id=plaa.user_id
       WHERE 
             plaa.`deleted` = 0 AND 
             plaa.`loan_application_status_id` IN (6,7,8) AND 
             plaa.`loan_application_id` = loan_application_id;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    SET @comment_body = '';
    
    OPEN approvers;
    
    REPEAT
       FETCH approvers INTO approver, comments;
       
       IF NOT done THEN
           SET rec = rec + 1;
           SET @comment_body = CONCAT(@comment_body,'<strong>',approver,':</strong><br>',IFNULL(comments,'-'),'<br>');
       END IF;
    UNTIL done END REPEAT;
    CLOSE approvers;           
    
    IF rec > 0 THEN
           -- [1] retrieve the application
           SET @loantypeid = 0;
           SET @loantypecode = '';
           SET @loantype = '';
           SET @displayname = '';
           SET @createdon = '';
           SET @userid = 0;
           SET @email = '';
           set @loanApplicationStatus = '';
           set @loanApplicationId = 0;
           set @firstname = '';
           
           SELECT `pla`.`user_id`, u.`email`, `up`.`firstname`, `loan_type_id`, `plas`.`loan_application_status`,`pla`.`loan_application_id`,`loan_type_code`, `pla`.`display_name`,DATE_FORMAT(`pla`.`created_on`, '%M-%e %l%p, %W')
           INTO @userid, @email, @firstname, @loantypeid, @loanApplicationStatus, @loanApplicationId, @loantypecode, @displayname, @createdon
           FROM `ww_partners_loan_application` pla
	   JOIN `users` u ON u.`user_id` = pla.`user_id`
	   JOIN `users_profile` up ON up.`user_id` = pla.`user_id`
	   LEFT JOIN `ww_partners_loan_application_status` plas ON plas.`loan_application_status_id` = pla.`loan_application_status_id` AND plas.`deleted` = 0           
           WHERE `loan_application_id`=loan_application_id LIMIT 1;
           -- [2] retrieve the form 
           SELECT `loan_type` INTO @loantype
           FROM `ww_partners_loan_type` WHERE `loan_type_id`=@loantypeid LIMIT 1;
       
           
           -- [3] retrieve the email template
           SET @emailto = @email;
           SET @emailsubject = '';
           SET @emailbody = '';
       
	   SELECT `subject`,`body` INTO @emailsubject, @emailbody
	   FROM `ww_system_template`
	   WHERE `code` = CONCAT(@loantypecode,'-STATUS') LIMIT 1;
           
           
           
           IF @emailsubject <> '' THEN
              -- [2] replace variables
              SET @emailbody = REPLACE(@emailbody, '{{alias}}', @firstname);
              SET @emailbody = REPLACE(@emailbody, '{{status}}', @loanApplicationStatus);
              SET @emailbody = REPLACE(@emailbody, '{{loantype}}', @loantype);
              SET @emailbody = REPLACE(@emailbody, '{{createdon}}', @createdon);
	
              -- {{link}}
              SET @url = get_config('System','URL');
	          IF RIGHT(TRIM(@url),1) <> '/' THEN
	             SET @url = CONCAT(TRIM(@url),'/');
	          END IF;
	   
              -- {{header/email logo}}
              SET @logo = get_config('System','print_logo'); 
	          IF TRIM(@logo) <> '' THEN
	             SET @logo = CONCAT(@url,@logo);
	          ELSE
	             SET @logo = CONCAT(@url,get_config('System','logo'));
	          END IF;
	   	         
              SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='loan_application' LIMIT 1);
              SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
              SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
              SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
              SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
              SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
               
              -- [3] insert to table
              IF TRIM(@emailbody) <> '' THEN
                 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
                 SELECT @emailto, @emailsubject, @emailbody;
              END IF;
              
           END IF;
    END IF; -- rec > 0 THEN        
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_loan_application_populate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_loan_application_populate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_loan_application_populate_approvers`(IN loan_application_id INT(11), IN userid INT(11))
BEGIN
       -- 
       -- [1] Override from user
       -- 
       SET @rec = 0;
       SET @class = '';
       SET @positions = '';
       SET @conditions = '';
       
       SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`), a.condition INTO @class, @positions, @rec, @conditions
       FROM `ww_approver_class_user` a
       JOIN `users_profile` b ON b.user_id = a.`user_id` 
       JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
       JOIN `ww_partners_loan_application` d ON d.`user_id` = b.`user_id`
       WHERE a.`deleted`=0 AND b.`user_id`=userid AND d.`loan_application_id`=loan_application_id AND UPPER(c.`class_code`)= UPPER(d.`loan_type_code`);
       
       IF @rec > 0 THEN
          INSERT INTO `ww_partners_loan_application_approver`
          (`loan_application_id`, `user_id`, `condition`, `sequence`, `loan_application_status_id`)
          SELECT loan_application_id, `approver_id`, `condition`, `sequence`, IF(@conditions='By Level',IF(@rec=1,2,IF(`sequence`=1,2,3)),2)
          FROM `ww_approver_class_user` a
          JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
          JOIN `users_profile` u ON u.user_id=userid
          WHERE a.`deleted`=0 AND UPPER(b.`class_code`)=UPPER(@class) AND a.`user_id`=userid AND 
                -- a.`position_id`=u.`position_id` AND a.`department_id`=u.`department_id` AND 
                a.`company_id`=u.`company_id` AND a.`approver_id`<>userid
          GROUP BY 2
          ON DUPLICATE KEY UPDATE `deleted`=0;             
       ELSE  
          
          -- 
          -- [1] Override from POSITION
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          SET @conditions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`), a.condition INTO @class, @positions, @rec, @conditions
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id` AND b.department_id=a.department_id
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          JOIN `ww_partners_loan_application` d ON d.`user_id` = b.`user_id`
          WHERE a.`deleted`=0 AND b.`user_id`=userid AND d.`loan_application_id`=loan_application_id AND UPPER(c.`class_code`)= UPPER(d.`loan_type_code`);
          
          IF @rec > 0 THEN
             INSERT INTO `ww_partners_loan_application_approver`
             (`loan_application_id`, `user_id`, `condition`, `sequence`, `loan_application_status_id`)
             SELECT loan_application_id, `approver_id`, `condition`, `sequence`, IF(@conditions='By Level',IF(@rec=1,2,IF(`sequence`=1,2,3)),2)
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.department_id=a.department_id AND u.user_id=userid
             WHERE a.`deleted`=0 AND UPPER(b.`class_code`)=UPPER(@class) AND a.`position_id`=@positions AND a.`approver_id`<>userid
             GROUP BY 2
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`), a.condition INTO @class, @department, @rec, @conditions
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
             JOIN `ww_partners_loan_application` d ON d.`user_id` = b.`user_id`
             WHERE a.`deleted`=0 AND b.`user_id`=userid AND d.`loan_application_id`=loan_application_id AND UPPER(c.`class_code`)=UPPER(d.`loan_type_code`) AND a.`approver_id`<>userid;
          
             IF @rec > 0 THEN
                INSERT INTO `ww_partners_loan_application_approver`
                (`loan_application_id`, `user_id`, `condition`, `sequence`, `loan_application_status_id`)
                SELECT loan_application_id, `approver_id`, `condition`, `sequence`, IF(@conditions='By Level',IF(@rec=1,2,IF(`sequence`=1,2,3)),2)
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
                WHERE a.`deleted`=0 AND UPPER(b.`class_code`)=UPPER(@class) AND a.`department_id`=@department AND a.`approver_id`<>userid
                GROUP BY 2
                ON DUPLICATE KEY UPDATE `loan_application_status_id`=VALUES(`loan_application_status_id`), `sequence`=VALUES(`sequence`), `deleted`=0;             
             ELSE
                
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`), a.condition INTO @class, @company, @rec, @conditions
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
                JOIN `ww_partners_loan_application` d ON d.`user_id` = b.`user_id`
                WHERE a.`deleted`=0 AND b.`user_id`=userid AND d.`loan_application_id`=loan_application_id AND UPPER(c.`class_code`)=UPPER(d.`loan_type_code`);
          
                IF @rec > 0 THEN
                   INSERT INTO `ww_partners_loan_application_approver`
                   (`loan_application_id`, `user_id`, `condition`, `sequence`, `loan_application_status_id`)
                   SELECT loan_application_id, `approver_id`, `condition`, `sequence`, IF(@conditions='By Level',IF(@rec=1,2,IF(`sequence`=1,2,3)),2)
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND UPPER(b.`class_code`)=UPPER(@class) AND a.`company_id`=@company AND a.`approver_id`<>userid
                   GROUP BY 2
                   ON DUPLICATE KEY UPDATE `deleted`=0;             
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
             
          END IF; -- IF POSITION    
       END IF; -- IF user          
          
          
       IF @rec > 0 THEN
          -- email approver/s application content
          CALL sp_partners_loan_application_email(loan_application_id);
       END IF;
          
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_memo_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_memo_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_memo_email`(IN memoid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    DECLARE email VARCHAR(100);
       
    DECLARE users_emails CURSOR FOR
       SELECT u.email
       FROM `ww_memo` m
       INNER JOIN `ww_system_feeds` sf ON sf.`record_id`=m.`memo_id`
       INNER JOIN `ww_memo_apply_to` mat ON mat.apply_to_id=m.apply_to_id 
       INNER JOIN `ww_memo_recipient` mr ON mr.memo_id=m.memo_id
       INNER JOIN `ww_users_profile` up ON 
          IF(m.apply_to_id=1, up.user_id=mr.apply_to,
          IF(m.apply_to_id=2, up.company_id=mr.apply_to,
          IF(m.apply_to_id=3, up.division_id=mr.apply_to,
          IF(m.apply_to_id=3, up.department_id=mr.apply_to, 0)))) OR m.created_by=up.user_id
       INNER JOIN `ww_users` u ON u.user_id=up.user_id AND u.`active`=1 AND IFNULL(u.`email`,'') <> ''
       WHERE m.`deleted`=0 AND m.`memo_id`=memoid AND (m.`email`=1 AND CURDATE() BETWEEN m.`publish_from` AND m.`publish_to`);
       
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    -- [1] retrieve the memo
    SET @memo_id = 0;
    SET @memo_type_id = 0;
    SET @memo_type = '';
    SET @memo_title = '';
    SET @attachment = '';
    SET @memo_body = '';
    SET @created_on = '';
    SET @fileattach = '';
       
    SET @system_url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
    SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
    SET @system_author = (SELECT `value` FROM `ww_config` WHERE `key`='author' LIMIT  1);
    SET @system_fromaddress = (SELECT `value` FROM `ww_config` WHERE `key`='from_address' LIMIT  1);
    
    SELECT `memo_type_id`, `memo_title`, 
       IF(IFNULL(`attachment`,'')='', '',CONCAT('<img alt="',`memo_title`,'" width="580px" src="', @system_url,`attachment`,'">')), 
       `memo_body`, `memo_id`, `publish_from`, CONCAT(@system_url,`attachment`)
    INTO @memo_type_id, @memo_title, @attachment, @memo_body, @memo_id, @created_on, @fileattach
    FROM `ww_memo`
    WHERE `memo_id`=memoid LIMIT 1;
       
    --  
    -- [2] retrieve the memo type 
    -- 
    SELECT `memo_type` INTO @memo_type
    FROM `ww_memo_type`
    WHERE `memo_type_id`=@memo_type_id LIMIT 1;
       
    --  
    -- [3] retrieve the email template
    --  
    SET @emailto = @system_fromaddress;
    SET @emailsubject = '';
    SET @emailbody = '';
    SET @bcc = '';
       
    SELECT `subject`,`body` INTO @emailsubject, @emailbody
    FROM `ww_system_template`
    WHERE `code` = 'MEMO' LIMIT 1;
       
              
    IF @emailsubject <> '' THEN
       -- [2] replace variables
       SET @emailbody = REPLACE(@emailbody, '{{memo_type}}', @memo_type);
       SET @emailbody = REPLACE(@emailbody, '{{memo_title}}', @memo_title);
       SET @emailbody = REPLACE(@emailbody, '{{memo_attachment}}', @attachment);
       SET @emailbody = REPLACE(@emailbody, '{{memo_body}}', @memo_body);
       SET @emailbody = REPLACE(@emailbody, '{{memo_created}}', DATE_FORMAT(@created_on,'%M %e, %Y - %W'));
       SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @system_url);
       SET @emailbody = REPLACE(@emailbody, '{{system_route}}', @system_url);
       SET @emailbody = REPLACE(@emailbody, '{{system_author}}', @system_author);
       
       SET @count_recipients = 0;
       SET @is_hundred = 0;
       
       OPEN users_emails;
	    
       REPEAT
          FETCH users_emails INTO email;
       
          IF NOT done THEN
	     SET @bcc = CONCAT(email,', ', @bcc);
	     SET @is_hundred = @count_recipients % 50;
	     IF @is_hundred = 0 AND @count_recipients > 0 THEN
	        INSERT INTO `ww_system_email_queue` (`to`, `bcc`, `subject`,`body`)
	        SELECT @emailto, @bcc, @emailsubject, @emailbody;
	        SET @bcc = '';
	     END IF;
          END IF;
       
          SET @count_recipients = @count_recipients + 1;
       
       UNTIL done END REPEAT;
    
       CLOSE users_emails;
    
       -- COMMIT;
       -- [3] insert to table
	  
       IF (CHAR_LENGTH(@bcc) > 0) THEN 
          INSERT INTO `ww_system_email_queue` (`to`, bcc, `subject`,`body`)
          SELECT @emailto, @bcc, @emailsubject, @emailbody;
       END IF;
       
     END IF;
       
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_memo_feeds` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_memo_feeds` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_memo_feeds`(IN memoid INT(11), IN modulepath VARCHAR(125))
BEGIN
    
    -- [1] add to activity feeds
    SET @messagetype = '';
    SET @userid = 0;
    SET @displayname = '';
    SET @recordid = 0;
    SET @feedcontent = '';
    SET @email = 0;
    SET @publish = 0;
        
    SELECT IF(mt.`memo_type`='Announcement','Announcement','Company News'), 
       m.`created_by`, u.`display_name`, m.`memo_id`,
       CONCAT(
          '<h4>',m.`memo_title`,'</h4><br>',
          IF(IFNULL(m.`attachment`,'')='', '', 
          IF(SUBSTRING_INDEX(m.`attachment`, '.', -1) = 'pdf',
          CONCAT('<img alt="',m.`memo_title`,'" src="',REPLACE(CONCAT(SUBSTRING_INDEX(m.`attachment`, '.', 1),'.jpg'), CONCAT("/",modulepath,"/"), CONCAT("/",modulepath,"/dashboard/") ),'" width="100%" class="pdf" />','<br><br>'),
          CONCAT('<img alt="',m.`memo_title`,'" src="',REPLACE(m.`attachment`, CONCAT("/",modulepath,"/"), CONCAT("/",modulepath,"/dashboard/") ),'" width="100%" class="image" />','<br><br>')
          )),      
          m.`memo_body`,
          '<br>'
          
       ), m.email, m.publish, m.publish_from, m.publish_to
    INTO @messagetype, @userid, @displayname, @recordid, @feedcontent, @email, @publish, @publish_from, @publish_to
    FROM `ww_memo` m
    INNER JOIN `ww_memo_type` mt ON mt.`memo_type_id`=m.`memo_type_id`
    LEFT JOIN `users` u ON u.`user_id`=m.`created_by`
    WHERE m.`deleted`=0 AND m.`memo_id` = memoid LIMIT 1;
    
            
    -- [2] populate to activity feeds recipient
    SET @id = 0;
    SELECT `id` INTO @id 
    FROM `ww_system_feeds` 
    WHERE `record_id`=memoid AND `message_type` IN ('Announcement','Company News')
    LIMIT 1;
    
    IF @id = 0 THEN    
        IF @publish = 1 AND (DATE(NOW()) BETWEEN DATE(@publish_from) AND DATE(@publish_to)) THEN
           INSERT INTO `ww_system_feeds`
           (`message_type`, `user_id`, `display_name`, `record_id`, `feed_content`)
           SELECT @messagetype, @userid, @displayname, @recordid, @feedcontent;
           SELECT `id` INTO @id 
           FROM `ww_system_feeds` WHERE `deleted`=0 AND `record_id`=memoid LIMIT 1;
           /* send email to recipients */   
           IF @email = 1 THEN
              CALL `sp_partners_memo_email`(memoid);
           END IF;
        END IF;
    ELSE
       IF @publish = 1 AND (DATE(NOW()) BETWEEN DATE(@publish_from) AND DATE(@publish_to)) THEN
            UPDATE `ww_system_feeds` 
            SET `feed_content`=@feedcontent , `deleted`=0
            WHERE `record_id`=memoid;
       ELSE
            UPDATE `ww_system_feeds` 
            SET `feed_content`=@feedcontent, `deleted`=1 
            WHERE `record_id`=memoid;
       END IF;
    END IF;
    
    
    -- [2] popute to activity feeds recipient
    IF @id > 0 THEN
       /* to clear existing recipients */
       DELETE FROM `ww_system_feeds_recipient` WHERE `id`=@id AND `like`=0;
    
       /* add selected recipients */
       INSERT INTO `ww_system_feeds_recipient` (`id`, `user_id`)
       SELECT sf.`id`, up.`user_id`
       FROM `ww_memo` m
       INNER JOIN `ww_system_feeds` sf ON sf.`record_id`=m.`memo_id`
       INNER JOIN `ww_memo_apply_to` mat ON mat.apply_to_id=m.apply_to_id 
       INNER JOIN `ww_memo_recipient` mr ON mr.memo_id=m.memo_id
       INNER JOIN `users_profile` up ON 
          IF(m.apply_to_id=1, up.user_id=mr.apply_to,
          IF(m.apply_to_id=2, up.company_id=mr.apply_to,
          IF(m.apply_to_id=3, up.division_id=mr.apply_to,
          IF(m.apply_to_id=3, up.department_id=mr.apply_to, 0)))) OR m.created_by=up.user_id
       INNER JOIN `users` u ON u.user_id=up.user_id AND u.`active`=1
       WHERE m.`deleted`=0 AND m.`memo_id`=memoid
       ON DUPLICATE KEY UPDATE `like`=1;
    END IF;
    
       
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_memo_feeds_recipient` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_memo_feeds_recipient` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_memo_feeds_recipient`(IN memoid INT(11))
BEGIN
    
    
    SET @id = 0;
    SELECT `id` INTO @id 
    FROM `ww_system_feeds` WHERE `deleted`=0 AND `record_id`=memoid LIMIT 1;
           
    IF @id > 0 THEN
       /* to clear existing recipients */
       DELETE FROM `ww_system_feeds_recipient` WHERE `id`=@id AND `like`=0;
       
       INSERT INTO `ww_system_feeds_recipient` (`id`, `user_id`, `department_id`)
       SELECT @id id, up.`user_id`, 0 department_id
       FROM 
          `ww_memo` m, 
          `ww_system_feeds` sf, 
          `ww_memo_apply_to` mat, 
          `ww_memo_recipient` mr, 
          `users_profile` up, 
          `users` u
       WHERE 
          m.`deleted`=0 AND sf.`deleted`=0 AND sf.`id`=@id
          AND sf.record_id=m.memo_id -- AND sf.message_type IN ('Announcement','Company News')
          AND mat.apply_to_id=m.apply_to_id 
          AND mr.memo_id=m.memo_id
          AND 
          IF(m.apply_to_id=1, up.user_id=mr.apply_to,
          IF(m.apply_to_id=2, up.company_id=mr.apply_to,
          IF(m.apply_to_id=3, up.division_id=mr.apply_to,
          IF(m.apply_to_id=4, up.department_id=mr.apply_to, 0)))) OR m.created_by=up.user_id
          AND u.user_id=up.user_id AND u.`active`=1
       ON DUPLICATE KEY UPDATE `like`=1;
    END IF;
       
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_memo_process` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_memo_process` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_memo_process`()
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE periodid INT;
    DECLARE datefrom DATE;
    DECLARE dateto DATE;
    DECLARE cutoff DATE; 
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE memo CURSOR FOR
       SELECT `memo_id`, `publish_from`, `publish_to`
       FROM `ww_memo` 
       WHERE `publish`=1 AND 
             `deleted`=0 AND 
             DATE(NOW()) BETWEEN `publish_from` AND `publish_to`;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
 
    -- START TRANSACTION;
        
    OPEN memo;
    
    REPEAT
       FETCH memo INTO recordid, datefrom, dateto;
       
       IF NOT done THEN
           SET rec = rec + 1;
           
           -- execute processing
           CALL `sp_partners_memo_feeds`(recordid);
           
           -- update memo header
           UPDATE `ww_system_feeds`
           SET `modifiedon` = NOW()
           WHERE `message_type` IN ('Annoucement','Company News') AND
                 `deleted`=0 AND
                 `record_id`=recordid;
                 
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE memo;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movements` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movements` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movements`()
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE actionid INT;
    DECLARE userid INT;
    DECLARE typeid INT;
    DECLARE typecode VARCHAR(128);
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE forms CURSOR FOR       
	SELECT pm.movement_id, pma.action_id, pma.user_id, pma.type_id, pmt.type_code
	FROM ww_partners_movement pm
	INNER JOIN ww_partners_movement_action pma ON pm.movement_id = pma.movement_id
	INNER JOIN ww_partners_movement_type pmt ON pma.type_id =  pmt.type_id
	WHERE 
	      pm.status_id = 11 AND pma.status_id NOT IN (4,5,6) AND 
	      DATE(pma.effectivity_date) <= CURDATE() AND pm.`deleted`=0;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- START TRANSACTION;
        
    OPEN forms;
    
    REPEAT
       FETCH forms INTO recordid, actionid, userid, typeid, typecode;
       
       IF NOT done THEN
	      CASE 
	      WHEN typecode IN ('REGULAR', 'PROMOTE', 'TRANSFER', 'EMPSTATUS', 'ASSIGN', 'DEVELOP') THEN
		       CALL sp_partners_movement_update_tranfer(actionid, userid, typecode);
	      WHEN typecode IN ('ADDALLOWANCE') THEN
		       CALL sp_partners_movement_update_allowance(actionid, userid, typecode);			       
	      WHEN typecode IN ('SALARY', 'WAGE', 'ALIGNMENT') THEN
		       CALL sp_partners_movement_update_compensation(actionid, userid, typecode);
	      WHEN typecode IN ('RESIGN', 'TERMINATE', 'ENDCNTRCT', 'RETIRE') THEN
		       CALL sp_partners_movement_update_moving(actionid, userid, typecode);
	      WHEN typecode IN ('EXT') THEN
		       CALL sp_partners_movement_update_extension(actionid, userid, typecode);
	      else begin end;
          END CASE;
	
	  INSERT INTO `logtable` (`log`) VALUES (CONCAT(recordid));
	  
	  IF (typecode = 'REGULAR') THEN
	     CALL sp_time_form_balance_process_prorated(userid, actionid);
	  END IF;
			
          UPDATE ww_partners_movement_action
          SET status_id = 6  
          WHERE action_id = actionid;
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE forms;
    
    -- COMMIT;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_anniversary` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_anniversary` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_anniversary`()
BEGIN
	    DECLARE done TINYINT(11) DEFAULT 0;
	    DECLARE actionid INT;
	    DECLARE userid INT;
    	    
	    DECLARE forms CURSOR FOR       
		SELECT pma.action_id,pma.user_id
		FROM ww_partners_movement pm
		INNER JOIN ww_partners_movement_action pma ON pm.movement_id = pma.movement_id
		INNER JOIN ww_partners_movement_type pmt ON pma.type_id =  pmt.type_id
		INNER JOIN ww_partners_movement_action_transfer pmat ON pma.action_id =  pmat.action_id
		WHERE 
		      pma.status_id = 6 AND 
		      pmat.field_name = 'end_date' AND STR_TO_DATE(pmat.to_name,'%M %d,%Y') <= CURDATE() AND pm.`deleted`=0;
	    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	 
	    -- START TRANSACTION;
	    OPEN forms;
	    
	    REPEAT
		FETCH forms INTO actionid,userid;
	       
		IF NOT done THEN
			CALL sp_partners_movement_anniv_update(actionid, userid);
		end if;
		
	    UNTIL done END REPEAT;
		    
	    CLOSE forms;
		    
	     -- COMMIT;	    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_anniv_update` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_anniv_update` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_anniv_update`(IN actionid INT(11), IN userid INT(11))
BEGIN
	
	    DECLARE done TINYINT(11) DEFAULT 0;
	    declare fromname VARCHAR(128);
	    DECLARE fromid INT;
	    DECLARE columnname VARCHAR(250);
	    DECLARE tablename VARCHAR(250);
	    DECLARE columnid VARCHAR(250);
            
	    DECLARE forms CURSOR FOR       
		SELECT pmf.field_name AS column_name, 
		       IF(pmf.table_name IS NULL, 'ww_partners_personal', pmf.table_name) AS table_name, 
		       IF(pmf.field_name='employment_status', 'status_id', CONCAT(pmf.field_name,'_id')) AS column_id,  
		       pmat.from_id, pmat.from_name
		FROM ww_partners_movement_action_transfer pmat 
		LEFT JOIN ww_partners_movement_fields pmf ON pmat.field_id = pmf.field_id
		WHERE pmat.action_id = actionid;
	    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	 
	    -- START TRANSACTION;
	    OPEN forms;
	    
	    REPEAT
		FETCH forms INTO columnname, tablename, columnid, fromid, fromname;
	       
		IF NOT done THEN
			IF tablename = 'ww_partners_personal' THEN
				CALL sp_partners_movement_update_partners_personal(actionid, userid, columnname, fromname);	    
			ELSE 		
				CASE 
				WHEN columnname IN ('department', 'division', 'location', 'position', 'reports_to') THEN	   
				   SET @SQL = CONCAT('UPDATE ww_users_profile SET ', columnid, ' = ', fromid, ' WHERE user_id = ',userid);
				   PREPARE stmt FROM @SQL;
				   EXECUTE stmt;
				   DEALLOCATE PREPARE stmt;
				WHEN columnname IN ('role') THEN
				   SET @SQL = CONCAT('UPDATE ww_users SET ', columnid, ' = ', fromid, ' WHERE user_id = ',userid);
				   PREPARE stmt FROM @SQL;
				   EXECUTE stmt;
				   DEALLOCATE PREPARE stmt;
				WHEN columnname IN ('employment_status', 'employment_type') THEN
				   SET @SQL = CONCAT('UPDATE ww_partners SET ', columnid, ' = ', fromid, ' WHERE user_id = ',userid);
				   PREPARE stmt FROM @SQL;
				   EXECUTE stmt;
				   DEALLOCATE PREPARE stmt;
				ELSE BEGIN END;  
				END CASE;
			end if;
		END IF;
				
	     UNTIL done END REPEAT;
		    
	     CLOSE forms;
		    
	      -- COMMIT;	    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_approval` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_approval` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_approval`(IN movementid INT, IN userid INT, IN statusid INT, IN usercomment TEXT)
BEGIN
   /* This will insert records to ww_time_record and executed thru events
      PARAMETER:
         statusid : 1=APPROVED, 0=DECLINE
      LAST Change: 2014-04-11 initial
                   2014-04-11 
   */
   INSERT INTO ww_system_messages
   (msg_code,msg,created_on)
   VALUES
   ('MV',CONCAT(movementid, ',', userid, ',', statusid, ',', usercomment), NOW());
   -- [1]
   UPDATE `ww_partners_movement_approver`
   SET
      `comment`        = usercomment,
      `comment_date`   = NOW(),
      `movement_status_id` = statusid
   WHERE 
      `movement_id` = movementid AND 
      `user_id` = userid AND
      `deleted` = 0
   LIMIT 1;
             
   -- set next approver
   IF statusid = 3 THEN
      SET @seq = (SELECT MAX(sequence) FROM `ww_partners_movement_approver` WHERE `movement_id`=movementid AND `movement_status_id`=3 AND `deleted`=0)+1;
      UPDATE `ww_partners_movement_approver`
      SET `movement_status_id` = 2
      WHERE `movement_id` = movementid AND `sequence` = @seq AND `deleted`=0 AND `condition` = 'By Level';
   END IF;
   IF statusid = 4 THEN
      SET @seq = (SELECT MAX(sequence) FROM `ww_partners_movement_approver` WHERE `movement_id`=movementid AND `movement_status_id`=4 AND `deleted`=0)+1;
      UPDATE `ww_partners_movement_approver`
      SET `movement_status_id` = 4
      WHERE `movement_id` = movementid AND `sequence` = @seq AND `deleted`=0 AND `condition` = 'By Level';
   END IF;
     
   -- [2] Update status by sequence to approver
   -- Change the status of the next approver
   -- 20150722 Only work on BY LEVEL
   
   -- 20150722 inlcude EITHER OF and ALL on approval condition
   -- [2.5] Check condition on approver   
   SET @conditions = '';
   
   SELECT `condition` INTO @conditions 
   FROM `ww_partners_movement_approver`
   WHERE 
      `movement_id` = movementid AND 
      `user_id` = userid AND
      `deleted` = 0
   LIMIT 1;
   
   -- [3] Update status on header
   -- Check if all approver already approved
   IF(@conditions = 'Either Of') THEN
	   UPDATE `ww_partners_movement`
	   SET
	      `status_id` = statusid,
	      `date_approved` = IF(statusid=3, NOW(), `date_approved`),
	      `date_declined` = IF(statusid=4, `date_declined`, NOW())
	   WHERE 
	      `movement_id` = movementid 
	   LIMIT 1;
	   
	   -- [1]
	   UPDATE `ww_partners_movement_approver`
	   SET
	      `comment`        = usercomment,
	      `comment_date`   = NOW(),
	      `movement_status_id` = statusid
	   WHERE 
	      `movement_id` = movementid AND 
	      `deleted` = 0
	   LIMIT 1;
   
   ELSE
	   SET @appCount    = 0;
	   SET @appApproved = 0;
	   SET @appDeclined = 0;
	   
	   SELECT COUNT(*), SUM(IF(`movement_status_id`=3,1,0)), SUM(IF(`movement_status_id`=4,1,0)) 
	   INTO @appCount, @appApproved, @appDeclined
	   FROM `ww_partners_movement_approver`
	   WHERE `movement_id`=movementid;
     	   
	   UPDATE `ww_partners_movement`
	   SET
	      `status_id` = IF(@appCount=@appApproved, 6, IF(@appCount=@appDeclined, 4, IF(@appDeclined > 0, 4, IF(@appApproved > 0, 7, `status_id`)))),
	      `date_approved` = IF(@appCount=@appApproved, NOW(), `date_approved`),
	      `date_declined` = IF(@appDeclined > 0, NOW(), `date_declined`)
	   WHERE 
	      `movement_id` = movementid 
	   LIMIT 1;
   END IF;
      
   
   -- [4] Push email 
   IF (@appDeclined > 0) THEN
      CALL sp_partners_movement_email_status(movementid);
   ELSE  
      CALL sp_partners_movement_email(movementid);
   END IF;
   -- 
   
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_change_pending_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_change_pending_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_change_pending_approvers`(IN user_ids VARCHAR(256), IN class_id INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE cocincidents CURSOR FOR
       SELECT  mv.`movement_id`, `mva`.`user_id` 
       FROM `ww_partners_movement` mv 
       LEFT JOIN `ww_partners_movement_action` mva on mv.movement_id = mva.movement_id
       WHERE `mv`.`deleted`=0
       AND FIND_IN_SET(`mva`.`user_id` , user_ids) AND `mv`.status_id = 2;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- START TRANSACTION;
        
    OPEN cocincidents;
    
    REPEAT
       FETCH cocincidents INTO recordid, userid;
       
       IF NOT done THEN
	   DELETE FROM ww_partners_movement_approver WHERE movement_id = recordid;
           CALL `sp_partners_movement_populate_approvers`(recordid, userid);
           UPDATE ww_partners_movement SET status_id = 2 WHERE movement_id = recordid;      
	   SET rec = rec + 1;
	   
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE cocincidents;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_email`(IN movementid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    DECLARE movement_id INT;
    DECLARE email VARCHAR(128);
    DECLARE approver VARCHAR(32);
    DECLARE classid INT;
    DECLARE ownerid INT;
    
    DECLARE approvers CURSOR FOR
       SELECT pma.`id`, pma.`user_id`, u.`email`, up.`firstname`, pma.`movement_id`, pmac.`user_id` ownid
       FROM `ww_partners_movement_approver` pma
       INNER JOIN `users` u ON u.user_id=pma.user_id
       INNER JOIN `users_profile` up ON up.user_id=pma.user_id
       INNER JOIN `ww_partners_movement` pm ON pm.movement_id = pma.movement_id
       INNER JOIN `ww_partners_movement_action` pmac ON pm.movement_id = pmac.movement_id
       WHERE pma.`deleted`=0 AND pma.`movement_status_id`=2 AND pma.`movement_id`=movementid AND IFNULL(u.`email`,'')<>'';
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    OPEN approvers;
    
    REPEAT
       FETCH approvers INTO recordid, userid, email, approver, movement_id, ownerid;
       
       IF NOT done THEN
           SET rec = rec + 1;      
        --   IF time_get_approver_with_email(classid,ownerid,userid) = 1 THEN
              -- START
           
           -- [1] retrieve the application
           SET @formid = 0;
           SET @formcode = '';
           SET @formname = '';
           SET @displayname = '';
           SET @createdon = '';
           SET @userid = 0;
       
           SELECT `user_id`, `pm`.`movement_id`, 'MV', 'Movement', `display_name`,
                  DATE_FORMAT(`pm`.`created_on`, '%M-%e %l%p, %W')
           INTO @userid, @movementid, @formcode, @formname, @displayname, @createdon
           FROM `ww_partners_movement` pm
           INNER JOIN `ww_partners_movement_action` pmac ON pm.movement_id = pmac.movement_id
           WHERE pm.`movement_id`=movement_id LIMIT 1;
                     
           -- [3] retrieve the email template
           SET @emailto = email;
           SET @emailsubject = '';
           SET @emailbody = '';
       
           SELECT `subject`,`body` INTO @emailsubject, @emailbody
           FROM `ww_system_template`
           WHERE `code` = 'movement' LIMIT 1;
           
           IF @emailsubject <> '' THEN
              -- [2] replace variables
              SET @emailbody = REPLACE(@emailbody, '{{alias}}', approver);
              SET @emailbody = REPLACE(@emailbody, '{{fullname}}', @displayname);
              SET @emailbody = REPLACE(@emailbody, '{{form}}', @formname);
              SET @emailbody = REPLACE(@emailbody, '{{createdon}}', @createdon);
              
              -- {{link}}
              SET @url = get_config('System','URL');
	          IF RIGHT(TRIM(@url),1) <> '/' THEN
	             SET @url = CONCAT(TRIM(@url),'/');
	          END IF;
	   
              -- {{header/email logo}}
              SET @logo = get_config('System','print_logo'); 
	          IF TRIM(@logo) <> '' THEN
	             SET @logo = CONCAT(@url,@logo);
	          ELSE
	             SET @logo = CONCAT(@url,get_config('System','logo'));
	          END IF;
	   	         
              SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='movement_manage' LIMIT 1);
              SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
              SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
              SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
              SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
              SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
               
              -- [3] insert to table
              IF TRIM(@emailbody) <> '' THEN
                 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
                 SELECT @emailto, @emailsubject, @emailbody;
              END IF;
              
              -- SELECT @emailto, @emailsubject, @emailbody;
              
             -- END IF; -- time_get_approver_with_email(classid,ownerid,userid) = 1
              
           END IF;
        END IF;
        
    UNTIL done END REPEAT;
    
    CLOSE approvers;
    
    -- SELECT rec;
    
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_email_hr_approval` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_email_hr_approval` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_email_hr_approval`(IN movementid INT(11), IN recipientid INT(11),IN mvstatus VARCHAR(50))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE approver VARCHAR(32);
    DECLARE comments TEXT;    
        
       -- [1] retrieve the application
       SET @userid = 0;
       SET @email = '';
       SET @movementstatus = '';
       SET @movementid = 0;
       SET @formcode = '';
       SET @formname = '';
       SET @displayname = '';
       SET @createdon = '';
       
       SELECT pmac.`user_id`, u.`email`, pms.`status`, 
              `pm`.`movement_id`, 'MV', 'Movement', `firstname`,DATE_FORMAT(pm.`created_on`, '%M-%e %l%p, %W')
       INTO @userid, @email, @movementstatus, @movementid, @formcode, @formname, @displayname, @createdon
       FROM `ww_partners_movement` pm
       JOIN `ww_partners_movement_action` pmac ON pmac.`movement_id` = pm.`movement_id`
       JOIN `users` u ON u.`user_id` = pm.`created_by`
       JOIN `users_profile` up ON up.`user_id` = pm.`created_by`
       LEFT JOIN `ww_partners_movement_status` pms ON pms.`status_id` = pm.`status_id` AND pms.`deleted` = 0
       WHERE `pm`.`movement_id`=movementid LIMIT 1;
       
       -- [1.5] retrieve the recipient email and firstname 
       SELECT u.email, up.firstname INTO @email, @recipientAlias
       FROM `ww_users` u 
       LEFT JOIN ww_users_profile up ON u.user_id = up.user_id
       WHERE u.user_id= recipientid LIMIT 1;
       
       -- [3] retrieve the email template
       SET @emailto = @email;
       SET @emailsubject = '';
       SET @emailbody = '';
       
       SELECT `subject`,`body` INTO @emailsubject, @emailbody
       FROM `ww_system_template`
       WHERE `code` = 'movement-hr-approval' LIMIT 1;
       
       
       IF @emailsubject <> '' THEN
           -- [2] replace variables           
           SET @emailbody = REPLACE(@emailbody, '{{fullname}}', @displayname);
           SET @emailbody = REPLACE(@emailbody, '{{alias}}', @recipientAlias);
           SET @emailbody = REPLACE(@emailbody, '{{adstatus}}', mvstatus);
           SET @emailbody = REPLACE(@emailbody, '{{status}}', @movementstatus);
           SET @emailbody = REPLACE(@emailbody, '{{comments}}', @comment_body);
           SET @emailbody = REPLACE(@emailbody, '{{form}}', @formname);
           SET @emailbody = REPLACE(@emailbody, '{{createdon}}', @createdon);         
          
           -- {{link}}
           SET @url = get_config('System','URL');
	       IF RIGHT(TRIM(@url),1) <> '/' THEN
	          SET @url = CONCAT(TRIM(@url),'/');
	       END IF;
	       
           -- {{header/email logo}}
           SET @logo = get_config('System','print_logo'); 
	       IF TRIM(@logo) <> '' THEN
	          SET @logo = CONCAT(@url,@logo);
	       ELSE
	          SET @logo = CONCAT(@url,get_config('System','logo'));
	       END IF;
	         
           SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='movement_admin' LIMIT 1);
           SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
           SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
           SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
           SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
           SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
                      
           -- [3] insert to table
           INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
           SELECT @emailto, @emailsubject, @emailbody;
        
       END IF; -- @emailsubject <> '' THEN
       
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_email_hr_approved` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_email_hr_approved` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_email_hr_approved`(IN movementid INT(11),IN mvstatus VARCHAR(50))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    DECLARE movement_id INT;
    DECLARE email VARCHAR(128);
    DECLARE approver VARCHAR(32);
    DECLARE classid INT;
    DECLARE ownerid INT;
    
    DECLARE approvers CURSOR FOR
       SELECT pma.`id`, pma.`user_id`, u.`email`, up.`firstname`, pma.`movement_id`, pmac.`user_id` ownid
       FROM `ww_partners_movement_approver` pma
       INNER JOIN `users` u ON u.user_id=pma.user_id
       INNER JOIN `users_profile` up ON up.user_id=pma.user_id
       INNER JOIN `ww_partners_movement` pm ON pm.movement_id = pma.movement_id
       INNER JOIN `ww_partners_movement_action` pmac ON pm.movement_id = pmac.movement_id
       WHERE pma.`deleted`=0 AND pma.`movement_status_id`=3 AND pma.`movement_id`=movementid AND IFNULL(u.`email`,'')<>'' GROUP BY `pma`.`user_id`;
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    OPEN approvers;
    
    REPEAT
       FETCH approvers INTO recordid, userid, email, approver, movement_id, ownerid;
       
       IF NOT done THEN
           SET rec = rec + 1;      
           
           -- [1] retrieve the application
           SET @formid = 0;
           SET @formcode = '';
           SET @formname = '';
           SET @displayname = '';
           SET @createdon = '';
           SET @userid = 0;
       
           SELECT `user_id`, `pm`.`movement_id`, 'MV', 'Movement', `display_name`,
                  DATE_FORMAT(`pm`.`created_on`, '%M-%e %l%p, %W')
           INTO @userid, @movementid, @formcode, @formname, @displayname, @createdon
           FROM `ww_partners_movement` pm
           INNER JOIN `ww_partners_movement_action` pmac ON pm.movement_id = pmac.movement_id
           WHERE pm.`movement_id`=movement_id LIMIT 1;
                     
           -- [3] retrieve the email template
           SET @emailto = email;
           SET @emailsubject = '';
           SET @emailbody = '';
       
           SELECT `subject`,`body` INTO @emailsubject, @emailbody
           FROM `ww_system_template`
           WHERE `code` = 'movement-hr-approved' LIMIT 1;
           
           IF @emailsubject <> '' THEN
              -- [2] replace variables
              SET @emailbody = REPLACE(@emailbody, '{{alias}}', approver);
              SET @emailbody = REPLACE(@emailbody, '{{fullname}}', @displayname);
              SET @emailbody = REPLACE(@emailbody, '{{form}}', @formname);
              SET @emailbody = REPLACE(@emailbody, '{{createdon}}', @createdon);
              SET @emailbody = REPLACE(@emailbody, '{{status}}', mvstatus);
              
              -- {{link}}
              SET @url = get_config('System','URL');
	          IF RIGHT(TRIM(@url),1) <> '/' THEN
	             SET @url = CONCAT(TRIM(@url),'/');
	          END IF;
	   
              -- {{header/email logo}}
              SET @logo = get_config('System','print_logo'); 
	          IF TRIM(@logo) <> '' THEN
	             SET @logo = CONCAT(@url,@logo);
	          ELSE
	             SET @logo = CONCAT(@url,get_config('System','logo'));
	          END IF;
	   	         
              SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='movement_manage' LIMIT 1);
              SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
              SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
              SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
              SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
              SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
               
              -- [3] insert to table
              IF TRIM(@emailbody) <> '' THEN
                 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
                 SELECT @emailto, @emailsubject, @emailbody;
              END IF;
              
           END IF;
        END IF;
        
    UNTIL done END REPEAT;
    
    CLOSE approvers;
    
	-- sending email to the creator
        SELECT pmac.`user_id`, u.`email`, pms.`status`, 
              `pm`.`movement_id`, 'MV', 'Movement', `firstname`,DATE_FORMAT(`pm`.`created_on`, '%M-%e %l%p, %W')
        INTO @userid, @email, @movementstatus, @movementid, @formcode, @formname, @displayname, @createdon
        FROM `ww_partners_movement` pm
        JOIN `ww_partners_movement_action` pmac ON pmac.`movement_id` = pm.`movement_id`
        JOIN `users` u ON u.`user_id` = pmac.`user_id`
        JOIN `users_profile` up ON up.`user_id` = pmac.`user_id`
        LEFT JOIN `ww_partners_movement_status` pms ON pms.`status_id` = pm.`status_id` AND pms.`deleted` = 0
        WHERE `pm`.`movement_id`=movementid LIMIT 1;
        
	-- [3] retrieve the email template
	SET @emailto = @email;
	SET @emailsubject = '';
	SET @emailbody = '';
	SELECT `subject`,`body` INTO @emailsubject, @emailbody
	FROM `ww_system_template`
	WHERE `code` = 'movement-hr-approved' LIMIT 1;
	
	IF @emailsubject <> '' AND @emailto <> '' THEN
	   -- [2] replace variables
	   SET @emailbody = REPLACE(@emailbody, '{{alias}}', @displayname);
	   SET @emailbody = REPLACE(@emailbody, '{{status}}', mvstatus);
	   SET @emailbody = REPLACE(@emailbody, '{{form}}', @formname);
	   SET @emailbody = REPLACE(@emailbody, '{{fullname}}', @displayname);
	      
	   -- {{link}}
	   SET @url = get_config('System','URL');
	       IF RIGHT(TRIM(@url),1) <> '/' THEN
		  SET @url = CONCAT(TRIM(@url),'/');
	       END IF;
	       
	   -- {{header/email logo}}
	   SET @logo = get_config('System','print_logo'); 
	       IF TRIM(@logo) <> '' THEN
		  SET @logo = CONCAT(@url,@logo);
	       ELSE
		  SET @logo = CONCAT(@url,get_config('System','logo'));
	       END IF;
		 
	   SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='movement' LIMIT 1);
	   SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
	   SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
	   SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
	   SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
	   SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
		      
	   -- [3] insert to table
	   INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
	   SELECT @emailto, @emailsubject, @emailbody;
	END IF; -- @emailsubject <> '' THEN
           
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_email_status` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_email_status` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_email_status`(IN movementid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE approver VARCHAR(32);
    DECLARE comments TEXT;
    DECLARE approvers CURSOR FOR
       SELECT up.`firstname`, pma.`comment`
       FROM `ww_partners_movement_approver` pma
       JOIN `users_profile` up ON up.user_id=pma.user_id
       WHERE 
             pma.`deleted` = 0 AND 
             pma.`movement_status_id` IN (4,6,7,8) AND 
             pma.`movement_id` = movementid;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    SET @comment_body = '';
    
    OPEN approvers;
    REPEAT
       FETCH approvers INTO approver, comments;
       IF NOT done THEN
           SET rec = rec + 1;
           SET @comment_body = CONCAT(@comment_body,'<strong>',approver,':</strong><br>',IFNULL(comments,'-'),'<br>');
        END IF;
    UNTIL done END REPEAT;
    CLOSE approvers;
    
    
    IF rec > 0 THEN
    
       -- [1] retrieve the application
       SET @userid = 0;
       SET @email = '';
       SET @movementstatus = '';
       SET @movementid = 0;
       SET @formcode = '';
       SET @formname = '';
       SET @displayname = '';
       SET @createdon = '';
       
       SELECT pmac.`user_id`, u.`email`, pms.`status`, 
              `pm`.`movement_id`, 'MV', 'Movement', `firstname`,DATE_FORMAT(`pm`.`created_on`, '%M-%e %l%p, %W')
       INTO @userid, @email, @movementstatus, @movementid, @formcode, @formname, @displayname, @createdon
       FROM `ww_partners_movement` pm
       JOIN `ww_partners_movement_action` pmac ON pmac.`movement_id` = pm.`movement_id`
       JOIN `users` u ON u.`user_id` = pmac.`user_id`
       JOIN `users_profile` up ON up.`user_id` = pmac.`user_id`
       LEFT JOIN `ww_partners_movement_status` pms ON pms.`status_id` = pm.`status_id` AND pms.`deleted` = 0
       WHERE `pm`.`movement_id`=movementid LIMIT 1;
       
       -- [3] retrieve the email template
       SET @emailto = @email;
       SET @emailsubject = '';
       SET @emailbody = '';
       
       SELECT `subject`,`body` INTO @emailsubject, @emailbody
       FROM `ww_system_template`
       WHERE `code` = 'movement-status' LIMIT 1;
       
       
       IF @emailsubject <> '' AND @emailto <> '' THEN
           -- [2] replace variables
           SET @emailbody = REPLACE(@emailbody, '{{alias}}', @displayname);
           SET @emailbody = REPLACE(@emailbody, '{{status}}', @movementstatus);
           SET @emailbody = REPLACE(@emailbody, '{{comments}}', @comment_body);
           SET @emailbody = REPLACE(@emailbody, '{{form}}', @formname);
              
           -- link
           SET @url = get_config('System','URL');
	       IF RIGHT(TRIM(@url),1) <> '/' THEN
	          SET @url = CONCAT(TRIM(@url),'/');
	       END IF;
	       
           -- {{header/email logo}}
           SET @logo = get_config('System','print_logo'); 
	       IF TRIM(@logo) <> '' THEN
	          SET @logo = CONCAT(@url,@logo);
	       ELSE
	          SET @logo = CONCAT(@url,get_config('System','logo'));
	       END IF;
	         
           SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='movement' LIMIT 1);
           SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
           SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
           SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
           SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
           SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
                      
           -- [3] insert to table
           INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
           SELECT @emailto, @emailsubject, @emailbody;
        
       END IF; -- @emailsubject <> '' THEN
       
    END IF; -- rec > 0 THEN
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_get_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_get_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_get_approvers`(IN formcode VARCHAR(16), IN userid INT(11))
BEGIN
          
    -- 
    -- [0] Override from USER
    -- 
    SET @rec = 0;
    SET @class = '';
    SET @users = '';
    
    SELECT c.`class_code`, b.`user_id`, COUNT(a.`id`) INTO @class, @users, @rec
    FROM `ww_approver_class_user` a
    JOIN `users_profile` b ON b.user_id = a.`user_id`
    JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
    WHERE a.`deleted`=0 AND b.`user_id`=userid AND c.`class_code`=formcode
          AND a.department_id = b.department_id AND a.company_id = b.company_id AND a.user_id = b.user_id;
    
    IF @rec > 0 THEN
       SELECT  `approver_id`, `condition`, `sequence`, c.lastname, c.firstname, `position`
       FROM `ww_approver_class_user` a
       JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
       JOIN `users_profile` c ON a.`approver_id`=c.`user_id` 
       LEFT JOIN `ww_users_position` d ON c.`position_id`=d.`position_id` 
       JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
       WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`user_id`=@users AND
             a.department_id = e.department_id AND a.company_id = e.company_id AND a.user_id = e.user_id;
    ELSE    
       
       -- 
       -- [1] Override from POSITION
       -- 
       SET @rec = 0;
       SET @class = '';
       SET @positions = '';
    
       SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
       FROM `ww_approver_class_position` a
       JOIN `users_profile` b ON b.position_id = a.`position_id`
       JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
       WHERE a.`deleted`=0 AND b.`user_id`=userid AND  c.`class_code`=formcode AND 
             a.department_id = b.department_id AND a.company_id = b.company_id;
       
       IF @rec > 0 THEN
          SELECT  `approver_id`, `condition`, `sequence`, c.lastname, c.firstname, `position`
          FROM `ww_approver_class_position` a
          JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
          JOIN `users_profile` c ON a.`approver_id`=c.`user_id` 
          LEFT JOIN `ww_users_position` d ON c.`position_id`=d.`position_id` 
          JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
          WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND 
                a.department_id = e.department_id AND a.company_id = e.company_id;
       ELSE     
	    
          -- 
          -- [2] Override from DEPARTMENT
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @department = '';
          
          SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
          FROM `ww_approver_class_department` a
          JOIN `users_profile` b ON b.department_id = a.`department_id`
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
	  WHERE a.`deleted`=0 AND b.`user_id`=userid AND  c.`class_code`=formcode AND 
	        a.company_id = b.company_id;
  
          IF @rec > 0 THEN
	     SELECT  `approver_id`, `condition`, `sequence`, c.lastname, c.firstname, `position`
	     FROM `ww_approver_class_department` a
	     JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
	     JOIN `users_profile` c ON a.`approver_id`=c.`user_id` 
	     LEFT JOIN `ww_users_position` d ON c.`position_id`=d.`position_id` 
	     JOIN `users_profile` e ON e.department_id = a.`department_id` AND e.`user_id`=userid
	     WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.company_id = e.company_id;
          ELSE
             
	     -- 
	     -- [3] Override from COMPANY
	     -- 
	     SET @rec = 0;
	     SET @class = '';
	     SET @company = '';
               
	     SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
	     FROM `ww_approver_class_company` a
	     JOIN `users_profile` b ON b.company_id = a.`company_id`
	     JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
	     WHERE b.`user_id`=userid AND  c.`class_code`=formcode AND a.`deleted`=0;
  
	    IF @rec > 0 THEN
	       SELECT  `approver_id`, `condition`, `sequence`, c.lastname, c.firstname, `position`
	       FROM `ww_approver_class_company` a
	       JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
	       JOIN `users_profile` c ON a.`approver_id`=c.`user_id` 
	       LEFT JOIN `ww_users_position` d ON c.`position_id`=d.`position_id` 
	       JOIN `users_profile` e ON e.company_id = a.`company_id` AND e.`user_id`=userid
	       WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company;
	    END IF; -- IF COMPANY
            
         END IF; -- IF DEPARTMENT
         
      END IF; -- IF POSITION  
      
   END IF; -- IF USER  
   
   END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_populate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_populate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_populate_approvers`(IN movementid INT(11), IN userid INT(11))
BEGIN
	  -- 
          -- [0] Override from USER
          -- 
          
          SET @rec = 0;
          SET @class = '';
          
	  SELECT c.`class_code`, COUNT(a.`id`) INTO @class, @rec
          FROM `ww_approver_class_user` a
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE a.`user_id`=userid AND c.`class_code`='MV' AND a.deleted = 0;
          
          IF @rec > 0 THEN
             INSERT INTO `ww_partners_movement_approver`
             (`movement_id`, `user_id`, `condition`, `sequence`, `movement_status_id`)
             SELECT movementid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,1))
             FROM `ww_approver_class_user` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`approver_id`<>userid
             AND a.user_id = userid
             GROUP BY 2
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE           
          
          -- 
          -- [1] Override from POSITION
          -- 
          
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id` AND b.department_id=a.department_id
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE b.`user_id`=userid AND c.`class_code`= 'IR';
          
          IF @rec > 0 THEN
             INSERT INTO `ww_partners_movement_approver`
             (`movement_id`, `user_id`, `condition`, `sequence`, `movement_status_id`)
             SELECT movementid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,1))
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.department_id=a.department_id AND u.user_id=userid
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
             GROUP BY 2
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
	     WHERE b.`user_id`=userid AND c.`class_code`= 'IR'
             AND a.`approver_id`<>userid;
          
             IF @rec > 0 THEN
                INSERT INTO `ww_partners_movement_approver`
                (`movement_id`, `user_id`, `condition`, `sequence`, `movement_status_id`)
                SELECT movementid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,1))
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
                WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
                GROUP BY 2
                ON DUPLICATE KEY UPDATE `movement_status_id`=VALUES(`movement_status_id`), `sequence`=VALUES(`sequence`), `deleted`=0;             
             ELSE
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
	        WHERE b.`user_id`=userid AND c.`class_code`= 'IR'
                AND a.`approver_id`<>userid;
          
                IF @rec > 0 THEN
                   INSERT INTO `ww_partners_movement_approver`
                   (`movement_id`, `user_id`, `condition`, `sequence`, `movement_status_id`)
                   SELECT movementid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,1))
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
                   GROUP BY 2
                   ON DUPLICATE KEY UPDATE `deleted`=0;             
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
          END IF;   
          END IF; -- IF POSITION  
           
          IF @rec > 0 THEN
	     -- email approver/s application content
	     CALL sp_partners_movement_email(movementid);
          END IF;                   
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_update_allowance` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_update_allowance` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_update_allowance`(IN actionid INT(11), IN userid INT(11), IN typecode VARCHAR(128))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
        
    DECLARE transaction_id INT(11) DEFAULT 0;
    DECLARE from_allowance VARCHAR(250);
    DECLARE to_allowance VARCHAR(250);
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE forms CURSOR FOR      
	SELECT maaa.transaction_id, 
	       maaa.from_allowance, maaa.to_allowance
	FROM ww_partners_movement_action_additional_allowance maaa 
	WHERE maaa.action_id = actionid;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	    
    -- START TRANSACTION;
	
    OPEN forms;
    
    REPEAT
       FETCH forms INTO transaction_id, from_allowance, to_allowance;
       
	IF NOT done THEN
	    SELECT recurring_id  INTO @recuring_id
	    FROM `ww_payroll_entry_recurring` er WHERE er.`transaction_id`=transaction_id  AND er.`deleted`=0 ORDER BY created_on DESC LIMIT 1;
	    
	    SELECT COUNT(ere.`recurring_id`) INTO @rec
	    FROM `ww_payroll_entry_recurring_employee` ere
	    LEFT JOIN `ww_payroll_entry_recurring` er ON ere.recurring_id = er.recurring_id
	    WHERE ere.`deleted`=0 AND ere.`employee_id`=userid AND er.`transaction_id`=transaction_id;
	
	    IF @rec = 0 THEN
		INSERT INTO `ww_payroll_entry_recurring_employee` (`recurring_id`,`employee_id`,`quantity`,`amount`) 
		VALUES (@recuring_id, userid, AES_ENCRYPT( 1, encryption_key() ), AES_ENCRYPT( to_allowance, encryption_key()));
		
		INSERT INTO `logtable_movement` (`action_id`,`recurring_id`,`employee_id`,`quantity`,`amount`) VALUES (actionid,@recuring_id, userid, AES_ENCRYPT( 1, encryption_key() ), AES_ENCRYPT( to_allowance, encryption_key()));
	    ELSE
		UPDATE `ww_payroll_entry_recurring_employee`
		SET quantity = AES_ENCRYPT( 1, encryption_key() ), amount = AES_ENCRYPT( to_allowance, encryption_key() )
		WHERE employee_id = userid AND recurring_id = @recuring_id;	    
	    END IF;
	END IF;
		
	UNTIL done END REPEAT;
	    
	CLOSE forms;
	    
	-- COMMIT;
		
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_update_compensation` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_update_compensation` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_update_compensation`(IN actionid INT(11), IN userid INT(11), IN typecode VARCHAR(128))
BEGIN
    DECLARE tosalary INT(11) DEFAULT 0;
	
	SELECT to_salary INTO tosalary 
	FROM ww_partners_movement_action_compensation 
	WHERE action_id = actionid;
	    
	UPDATE ww_payroll_partners
	SET salary = AES_ENCRYPT( tosalary, encryption_key() )
	WHERE user_id = userid;
	    	   
       
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_update_extension` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_update_extension` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_update_extension`(IN actionid INT(11), IN userid INT(11), IN typecode VARCHAR(128))
BEGIN
    DECLARE partnerid INT(11) DEFAULT 0;
    DECLARE enddate DATE;
    DECLARE keyid INT(11) DEFAULT 0;
    DECLARE keylabel VARCHAR(250);
	    
    SELECT partner_id INTO partnerid 
    FROM ww_users_profile 
    WHERE user_id = userid;
	    
    SELECT DATE_FORMAT(end_date, "%M %d, %Y") INTO enddate 
    FROM ww_partners_movement_action_extension 
    WHERE action_id = actionid;
	    
    SELECT key_id, key_label INTO keyid, keylabel 
    FROM ww_partners_key 
    WHERE `key_code` = 'last_probationary';
	    
    DELETE FROM ww_partners_personal 
    WHERE `key` = 'last_probationary' 
    AND partner_id = partnerid;	   
	    
    INSERT INTO ww_partners_personal (partner_id, key_id, `key`, sequence, key_name, key_value, created_on, created_by)
    VALUES (partnerid, keyid, 'last_probationary', 1, keylabel, enddate, NOW(), 1);	   
		
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_update_moving` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_update_moving` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_update_moving`(IN actionid INT(11), IN userid INT(11), IN typecode VARCHAR(128))
BEGIN
    DECLARE blocked TINYINT(1) DEFAULT 0;
    DECLARE enddate DATE;
    DECLARE fromstatus_id TINYINT(1);
    DECLARE fromstatus_name VARCHAR(32);
    DECLARE tostatus_id TINYINT(1);
    DECLARE tostatus_name VARCHAR(32);
    DECLARE movementid INT(11);
	
    SELECT blacklisted, end_date, movement_id INTO blocked, enddate, movementid
    FROM ww_partners_movement_action_moving 
    WHERE action_id = actionid;
	    
    UPDATE ww_partners
    SET resigned_date = enddate, blacklisted = blocked
    WHERE user_id = userid;
    
    SELECT status_id, `status` INTO fromstatus_id, fromstatus_name
    FROM ww_partners 
    WHERE user_id = userid;
	 
    CASE typecode	    
       WHEN 'RESIGN' THEN	    
          UPDATE ww_partners SET status_id = 8 WHERE user_id = userid;
       WHEN 'RETIRE' THEN	    
          UPDATE ww_partners SET status_id = 9 WHERE user_id = userid;
       WHEN 'ENDCNTRCT' THEN	    
          UPDATE ww_partners SET status_id = 10 WHERE user_id = userid;
       WHEN 'TERMINATE' THEN	    
          UPDATE ww_partners SET status_id = 11 WHERE user_id = userid;
    else begin end;
    END CASE;
	    
    UPDATE ww_users
    SET active = 0
    WHERE user_id = userid;
    
    SELECT status_id, `status` INTO tostatus_id, tostatus_name
    FROM ww_partners 
    WHERE user_id = userid;
    
    INSERT INTO ww_partners_movement_action_transfer (action_id, movement_id, field_id, field_name, from_id, to_id, from_name, to_name)
    VALUES (actionid, movementid, 9, 'employment_status', fromstatus_id, tostatus_id, fromstatus_name, tostatus_name);
    
    UPDATE ww_recruitment rec, ww_users_profile uprof
    SET rec.blacklisted = blocked
    WHERE uprof.user_id = userid AND rec.recruit_id = uprof.recruit_id;
       
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_update_partners_personal` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_update_partners_personal` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_update_partners_personal`(IN actionid INT(11), IN userid INT(11), IN columnname VARCHAR(128), IN toname VARCHAR(128))
BEGIN
    DECLARE partnerid INT(11) DEFAULT 0;
    DECLARE keyid INT(11) DEFAULT 0;
    DECLARE keylabel VARCHAR(250);
    
    SELECT partner_id INTO partnerid 
    FROM ww_users_profile 
    WHERE user_id = userid;
    
    SELECT key_id, key_label INTO keyid, keylabel 
    FROM ww_partners_key 
    WHERE `key_code` = columnname;
	    
    DELETE FROM ww_partners_personal 
    WHERE `key` = columnname AND partner_id = partnerid;
    	   
    INSERT INTO ww_partners_personal (partner_id, key_id, `key`, sequence, key_name, key_value, created_on, created_by)
    VALUES (partnerid, keyid, columnname, 1, keylabel, toname, NOW(), 1);	   
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_movement_update_tranfer` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_movement_update_tranfer` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_movement_update_tranfer`(IN actionid INT(11), IN userid INT(11), IN typecode VARCHAR(128))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
        
    DECLARE columnname VARCHAR(250);
    DECLARE tablename VARCHAR(250);
    DECLARE columnid VARCHAR(250);
    DECLARE toid INT;
    DECLARE toname VARCHAR(250);
    DECLARE partnerid INT(11) DEFAULT 0;
    DECLARE keyid INT(11) DEFAULT 0;
    DECLARE keylabel VARCHAR(250);
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE forms CURSOR FOR      
	SELECT pmf.field_name AS column_name, 
	       IF(pmf.table_name IS NULL, 'ww_partners_personal', pmf.table_name) AS table_name,
	       case
		  when pmf.field_name = 'employment_status' then 'status_id'
		  WHEN pmf.field_name = 'job_level' THEN 'job_grade_id'
		  else CONCAT(pmf.field_name,'_id')
	       end as column_id,
	       -- IF(pmf.field_name='employment_status', 'status_id', CONCAT(pmf.field_name,'_id')) AS column_id,  
	       pmat.to_id, pmat.to_name
	FROM ww_partners_movement_action_transfer pmat 
	LEFT JOIN ww_partners_movement_fields pmf ON pmat.field_id = pmf.field_id
	WHERE pmat.action_id = actionid;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	    
    -- START TRANSACTION;
	
    OPEN forms;
    
    REPEAT
       FETCH forms INTO columnname, tablename, columnid, toid, toname;
       
       IF NOT done THEN
	       IF tablename = 'ww_partners_personal' THEN
              CALL sp_partners_movement_update_partners_personal(actionid, userid, columnname, toname);	    
	       ELSE 
		      CASE 
		      WHEN columnname IN ('department', 'division', 'location', 'position', 'reports_to') THEN	   
		           SET @SQL = CONCAT('UPDATE ww_users_profile SET ', columnid, ' = ', toid, ' WHERE user_id = ',userid);
		           PREPARE stmt FROM @SQL;
		           EXECUTE stmt;
		           DEALLOCATE PREPARE stmt;
		      WHEN columnname IN ('role') THEN
		           SET @SQL = CONCAT('UPDATE ww_users SET ', columnid, ' = ', toid, ' WHERE user_id = ',userid);
		           PREPARE stmt FROM @SQL;
		           EXECUTE stmt;
		           DEALLOCATE PREPARE stmt;
		      WHEN columnname IN ('employment_status', 'employment_type', 'job_level') THEN
		           SET @SQL = CONCAT('UPDATE ww_partners SET ', columnid, ' = ', toid, ' WHERE user_id = ',userid);
		           PREPARE stmt FROM @SQL;
		           EXECUTE stmt;
		           DEALLOCATE PREPARE stmt;
		      else begin end;
		      END CASE;
	       END IF;
	    END IF;
	       
	UNTIL done END REPEAT;
	    
	CLOSE forms;
	    
	-- COMMIT;
		
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_personal_change_pending_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_personal_change_pending_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_personal_change_pending_approvers`(IN partner_ids VARCHAR(256), IN class_id INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    DECLARE partnerid INT;
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE personalRequests CURSOR FOR
       SELECT  tr.`personal_id`, tr.`partner_id` FROM `ww_partners_personal_request` tr WHERE `deleted`=0
       AND FIND_IN_SET(partner_id, partner_ids) AND `status` IN (2);
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- START TRANSACTION;
        
    OPEN personalRequests;
    
    REPEAT
       FETCH personalRequests INTO recordid, partnerid;
              
          SELECT user_id INTO userid
           FROM `ww_users_profile` 
           WHERE partner_id = partnerid
           ;
          
       IF NOT done THEN
	   DELETE from ww_partners_personal_approver WHERE personal_request_id = recordid;
           CALL `sp_partners_personal_populate_approvers`(recordid, userid);
           UPDATE ww_partners_personal_request SET `status` = 2 WHERE personal_id = recordid;      
	   SET rec = rec + 1;
	   
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE personalRequests;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_personal_populate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_personal_populate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_personal_populate_approvers`(IN personalrequestid INT(11), IN userid INT(11))
BEGIN
          -- 
          -- [1] Override from POSITION
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id`
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE b.`user_id`=userid AND c.`class_code`= '201REQ' AND a.`approver_id`<>userid;
          
          IF @rec > 0 THEN
             INSERT INTO `ww_partners_personal_approver`
             (`personal_request_id`, `user_id`, `condition`, `sequence`, `personal_request_status_id`)
             SELECT personalrequestid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,3))
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
             JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
             AND a.department_id = e.department_id AND a.company_id = e.company_id
             GROUP BY 2
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
             WHERE b.`user_id`=userid AND c.`class_code`= '201REQ' AND a.`approver_id`<>userid;
          
             IF @rec > 0 THEN
                INSERT INTO `ww_partners_personal_approver`
                (`personal_request_id`, `user_id`, `condition`, `sequence`, `personal_request_status_id`)
                SELECT personalrequestid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,3))
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
		JOIN `users_profile` e ON e.department_id = a.`department_id` AND e.`user_id`=userid
                WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
                AND a.company_id = e.company_id 
                GROUP BY 2
                ON DUPLICATE KEY UPDATE `personal_request_status_id`=VALUES(`personal_request_status_id`), `sequence`=VALUES(`sequence`), `deleted`=0;             
             ELSE
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
                JOIN `time_forms` d ON d.`user_id` = b.`user_id`
                WHERE b.`user_id`=userid AND c.`class_code`= '201REQ' AND a.`approver_id`<>userid;
          
                IF @rec > 0 THEN
                   INSERT INTO `ww_partners_personal_approver`
                   (`personal_request_id`, `user_id`, `condition`, `sequence`, `personal_request_status_id`)
                   SELECT personalrequestid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,3))
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
                   GROUP BY 2
                   ON DUPLICATE KEY UPDATE `deleted`=0;             
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
             
          END IF; -- IF POSITION          
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_personal_process` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_personal_process` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_personal_process`()
BEGIN
    /* Script to remove declared dependent which falls on more than 21 years old*/
    
    UPDATE ww_users u, ww_partners p, ww_partners_personal_history pph, ww_partners_personal_history pph2, ww_partners_personal_history pph3 
    
    SET pph.`key_value` = '0'
    
    WHERE u.`active` = 1 AND p.`user_id` = u.`user_id` AND
          pph.`key_value` = 1 AND 
          pph3.`key_value` IN ('son','daughter') AND 
          getage( STR_TO_DATE(pph2.`key_value`, '%M %d, %Y') ) > 21 AND
          pph.`key` = 'family-dependent' AND pph.`partner_id` = p.`partner_id` AND
          pph2.`key` = 'family-birthdate' AND pph2.`partner_id` = p.`partner_id` AND pph2.`sequence` = pph.`sequence` AND
          pph3.`key` = 'family-relationship' AND pph3.`partner_id` = p.`partner_id` AND pph3.`sequence` = pph.`sequence`
    ;
        
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_sms_bday` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_sms_bday` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_sms_bday`()
BEGIN
    
    INSERT INTO `ww_system_sms_queue` (`to`,`subject`,`body`)
    SELECT REPLACE(REPLACE(TRIM(pp.`key_value`),'-',''),'+',''),
       IF(IFNULL(up.`nickname`,'')='',up.`firstname`,up.`nickname`),
       REPLACE(
       REPLACE(st.`body`, '{{alias}}', IF(TRIM(IFNULL(up.`nickname`,''))='',up.`firstname`,up.`nickname`)),
          '{{application_title}}', c.`value`)
    
    FROM `users_profile` up 
    JOIN `users` u ON u.user_id=up.user_id AND u.active=1
    JOIN `ww_system_template` st ON st.`code`='SMS-BDAY-REMINDER'
    JOIN `ww_partners_personal` pp ON pp.`key`='mobile' AND pp.`partner_id`=up.`partner_id`
    LEFT JOIN `ww_config` c ON c.`key`='application_title' AND c.deleted=0
    WHERE 
       nextbday(up.`birth_date`)=CURDATE() AND
       REPLACE(TRIM(pp.`key_value`),'-','')<>'' AND pp.`sequence`=1;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_sms_reminder` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_sms_reminder` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_sms_reminder`(IN userid INT(11))
BEGIN
    
    INSERT INTO `ww_system_sms_queue` (`to`,`subject`,`body`)
    SELECT REPLACE(REPLACE(TRIM(pp.`key_value`),'-',''),'+',''),
       IF(IFNULL(up.`nickname`,'')='',up.`firstname`,up.`nickname`),
       REPLACE(
       REPLACE(st.`body`, '{{alias}}', IF(TRIM(IFNULL(up.`nickname`,''))='',up.`firstname`,up.`nickname`)),
          '{{application_title}}', c.`value`)
    
    FROM `users_profile` up 
    JOIN `users` u ON u.user_id=up.user_id AND u.active=1
    JOIN `ww_system_template` st ON st.`code`='SMS-WELCOME'
    JOIN `ww_partners_personal` pp ON pp.`key`='mobile' AND pp.`partner_id`=up.`partner_id`
    LEFT JOIN `ww_config` c ON c.`key`='application_title' AND c.deleted=0
    WHERE 
       up.`user_id`=userid AND
       REPLACE(TRIM(pp.`key_value`),'-','')<>'' AND pp.`sequence`=1 AND
       pp.`created_on` >= '2014-11-24';
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_partners_subordinates` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_partners_subordinates` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_partners_subordinates`(IN immediateid INT(11), IN role INT(11))
BEGIN
    
    SELECT 
       `up`.`user_id`, 
       `p`.`id_number`, 
       CONCAT(`up`.`lastname`, ', ', `up`.`firstname`) `display_name`, 
       `p`.`shift_id`, 
       `ts`.`shift`,
       `p`.`calendar_id`, 
       `tsw`.`calendar`           
	
    FROM ww_users_profile up
    JOIN ww_partners p ON p.`user_id` = up.`user_id` 
    LEFT JOIN ww_time_shift ts ON ts.`shift_id` = p.`shift_id`
    LEFT JOIN ww_time_shift_weekly tsw ON tsw.`calendar_id` = p.`calendar_id`
    
    WHERE 
       IF(role IN (2,6), 1, up.`reports_to_id`=immediateid OR 
                            up.`project_hr_id`=immediateid OR 
                            FIND_IN_SET(immediateid, up.`coordinator_id`) ) AND 
       p.status_id < 8
    ORDER BY display_name;
    
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_bir_diminimis` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_bir_diminimis` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_bir_diminimis`( IN nUserID INT(11), IN nYear INT(11), IN nType INT(1) )
BEGIN
	SET @nLastPay = 0;
	-- previous employer 
	SET @sPrevEmployer = '';
	SET @sPrevTin = '';
	SET @sPrevAddress = '';
	SET @sPrevZipCode = '';
	SET @nPrevTax = 0.00;
	-- Dependent 
	-- to create function on how to get the dependet
	-- to create function / trigger when dependent child reach 21
	SET @sDepName1 = '';
	SET @dtBirthDay1 = '0000-00-00';
	SET @sDepName2 = '';
	SET @dtBirthDay2 = '0000-00-00';
	SET @sDepName3 = '';
	SET @dtBirthDay3 = '0000-00-00';
	SET @sDepName4 = '';
	SET @dtBirthDay4 = '0000-00-00';
	SET @nMinwageFlag = 0;
	SET @nMinwageMonth = 0.00;
	IF nType = 1 THEN
		SET @nLastPay = 1;
	END IF;	
	
	UPDATE `ww_payroll_bir` set
            `min_deminimis` = (IFNULL(get_bir_is_deminimis( nYear, nUserID ),0))
            WHERE user_id = nUserID;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_bir_manual_insert` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_bir_manual_insert` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_bir_manual_insert`(
	IN nYear INT(11),
	IN nCompID INT(11)
	)
BEGIN
	DECLARE birDone  TINYINT(1) DEFAULT 0;
	DECLARE nUser INT(11);
	
	DECLARE dataUser CURSOR FOR 
		SELECT DISTINCT employee_id, nYear, nCompID 
		FROM ww_payroll_closed_transaction 
		WHERE `deleted` = 0 AND YEAR( `payroll_date` ) = nYear AND company_id = nCompID;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET birDone = 1;
	-- select overtime;
	
	OPEN dataUser;
	myBirLoop: LOOP
		FETCH dataUser INTO nUser, nYear, nCompID ;
		
		IF birDone THEN
		    CLOSE dataUser;
		    LEAVE myBirLoop;
		END IF;
		CALL `sp_payroll_bir_record`( nUser, nYear, 0 );
		SET @nUser = nUser;
		SET @birDone = birDone;
		
	END LOOP;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_bir_record` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_bir_record` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_bir_record`( IN nUserID INT(11), IN nYear INT(11), IN nType INT(1) )
BEGIN
	SET @nLastPay = 0;
	-- previous employer 
	SET @sPrevEmployer = '';
	SET @sPrevTin = '';
	SET @sPrevAddress = '';
	SET @sPrevZipCode = '';
	SET @nPrevTax = 0.00;
	-- Dependent 
	-- to create function on how to get the dependet
	-- to create function / trigger when dependent child reach 21
	SET @sDepName1 = '';
	SET @dtBirthDay1 = '0000-00-00';
	SET @sDepName2 = '';
	SET @dtBirthDay2 = '0000-00-00';
	SET @sDepName3 = '';
	SET @dtBirthDay3 = '0000-00-00';
	SET @sDepName4 = '';
	SET @dtBirthDay4 = '0000-00-00';
	SET @nMinwageFlag = 0;
	SET @nMinwageMonth = 0.00;
	IF nType = 1 THEN
		SET @nLastPay = 1;
	END IF;	
	
	-- remove record if exist
	DELETE FROM ww_payroll_bir WHERE user_id = nUserID AND pay_year = nYear;
	-- insert record
	INSERT INTO `ww_payroll_bir`
            (`user_id`, `id_number`, `lastname`, `firstname`, `suffix`, `middlename`, `tin`, `birth_date`, `address`,
		`pay_year`, `company_id`, `employed_date`, `resigned_date`, `civil_status_id`, `depend`, `exempt`, `exempt_code`,
             `prev_employer`, `prev_tin`, `prev_address`, `prev_zip`, `prev_wtax`,
             `dep_name1`, `dep_bday1`, `dep_name2`, `dep_bday2`, `dep_name3`, `dep_bday3`, `dep_name4`, `dep_bday4`,
             `min_basic`, `min_holpay`, `min_overtime`, `min_ndiff`, `min_deminimis`, `min_hazardpay`, 
             `govt_contri`, `bonus_nontax`, `bonus_tax`, `benefit`, `allow`,
             `tax_basic`,`representation`, `transportation`, `cost_living`, `fixed_housing`,`tempo_allowance`,`service_allowance`,
	     `commission`, `profit_sharing`, `fees`, `tax_hazardpay`, `tax_overtime`, 
	     `gross_compensation`, `total_non_tax`, `total_taxable`, `net_taxable`, `wtax`, `taxdue`,
             `minwageflag`, `minwage_amt`, `minwage_day`, `minwage_month`, `total_year_days`,`if_lastpay`, `deleted`)
	-- get records of employee
	SELECT 
	u.`user_id`, p.`id_number`, up.`lastname`, up.`firstname`, up.`suffix`, up.`middlename`, pp.`tin`, up.`birth_date`, get_address(u.user_id),
	nYear, u.`company_id`, p.`effectivity_date`, p.`resigned_date`, get_civil_status(u.`user_id`), 
	t.`dependent`, t.`amount`, CONCAT( IF(get_civil_status(u.`user_id`) = 1,'S','M') , t.`dependent` ),
	@sPrevEmployer, @sPrevTin, @sPrevAddress, @sPrevZipCode, @nPrevTax,
	@sDepName1, @dtBirthday1, @sDepName2, @dtBirthday2, @sDepName3, @dtBirthday3, @sDepName4, @dtBirthday4,
	IFNULL(get_bir_min_basic( nYear, nUserID ),0), 
	IFNULL(get_bir_min_holidaypay( nYear, nUserID ),0), 
	IFNULL(get_bir_min_overtime( nYear, nUserID ),0), 
	IFNULL(get_bir_min_ndiff( nYear, nUserID ),0),	 
	IFNULL(get_bir_is_deminimis( nYear, nUserID ),0), 
	IFNULL(get_bir_min_hazardpay( nYear, nUserID ),0), 
	IFNULL(get_bir_govt_contri( nYear, nUserID ),0), 
	IFNULL(get_bir_bonus_nt( nYear, nUserID ),0), 
	IFNULL(get_bir_bonus_tax( nYear, nUserID ),0), 
	IFNULL(get_bir_benefit( nYear, nUserID ),0), 
	IFNULL(get_bir_allow( nYear, nUserID ),0), 
	IFNULL(get_bir_tax_basic( nYear, nUserID ),0), 	
	IFNULL(get_bir_is_representation( nYear, nUserID ),0), 
	IFNULL(get_bir_is_transportation( nYear, nUserID ),0), 
	IFNULL(get_bir_is_cost_living( nYear, nUserID ),0), 
	IFNULL(get_bir_is_fixed_housing( nYear, nUserID ),0), 
	ifnull(get_bir_is_tempo_allowance( nYear, nUserID ),0),
	IFNULL(get_bir_is_service_allowance( nYear, nUserID ),0),
	IFNULL(get_bir_is_commission( nYear, nUserID ),0), 
	IFNULL(get_bir_is_profit_sharing( nYear, nUserID ),0), 
	IFNULL(get_bir_is_fees( nYear, nUserID ),0), 
	IFNULL(get_bir_is_hazardpay( nYear, nUserID ),0), 
	IFNULL(get_bir_overtime( nYear, nUserID ),0), 
	IFNULL(get_bir_gross_compensation( nYear, nUserID ),0),
	IFNULL(get_bir_total_non_tax( nYear, nUserID ),0), 
	IFNULL(get_bir_total_taxable( nYear, nUserID ),0), 	
	IFNULL(get_bir_net_taxable( nYear, nUserID, t.`amount` ),0), 	
	IFNULL(get_wtax( nYear, nUserID ),0), 
	IFNULL(get_taxdue( nYear, nUserID, t.`amount` ),0), 
	is_minimum_wage_earner(nUserID), 
	IF(pp.`location_id` IS NULL OR pp.`location_id` = 0, get_config('Payroll','minwage_amount'), get_minwage(pp.`location_id`)),
	ROUND( ( CASE payroll_rate_type_id 
		WHEN 2 THEN ( AES_DECRYPT( `p`.`salary`, encryption_key() ) / ( `total_year_days` / 12 ) )
		WHEN 6 THEN ( AES_DECRYPT( `p`.`salary`, encryption_key()) )
		END ), 2 ),
	0.00, 
	pp.`total_year_days`,
	@nLastPay, 0
	FROM ww_users u
	INNER JOIN ww_users_profile up ON u.user_id = up.user_id
	INNER JOIN ww_partners p ON p.`user_id` = u.`user_id`
	INNER JOIN ww_payroll_partners pp ON pp.`user_id` = u.`user_id`
	LEFT JOIN ww_taxcode t ON pp.`taxcode_id` = t.`taxcode_id`
	WHERE u.user_id = nUserID;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_bonus_insert` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_bonus_insert` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_bonus_insert`(
	in puserid int(11),
	in periodid int(11),
	in paydate date,
	in processing_type_id int(11),
	in tran_id int(11),
	in tran_class_id int(11),
	in tran_code varchar(32),
	in qty decimal(12,2),
	in amount decimal(12,2),
	in tran_type_id int(11),
	in rec_id int(11),
	in ins_from varchar(32)
    
    )
BEGIN
	INSERT INTO `ww_payroll_current_transaction`
	    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
	     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
	     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
	     `created_by`, `deleted`)
	SELECT periodid, processing_type_id, paydate, user_id, tran_id, tran_class_id,
	     tran_code, AES_ENCRYPT(qty, encryption_key()), 
	     AES_ENCRYPT( amount, encryption_key()) ,
	     AES_ENCRYPT( amount, encryption_key()), 
	     tran_type_id, 0,ins_from,rec_id,0,'',NOW(),0,0
	FROM ww_payroll_partners 
	WHERE user_id = puserid;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_closed_loan` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_closed_loan` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_closed_loan`(
	IN periodid INT(11),
	IN puserid INT(11)	
    )
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE emp_id INT(11);
	DECLARE ploan_id INT(11);
	DECLARE	paydate DATE;
	DECLARE pay_mode INT(11);
	DECLARE run_bal DECIMAL(12,2);
	DECLARE sys_amort DECIMAL(12,2);
	DECLARE user_amort DECIMAL(12,2);
	DECLARE ln_status_id INT(11);
	DECLARE tot_amt_pd DECIMAL(12,2);
	DECLARE no_pay_pd INT(11);
	DECLARE no_pay_rem INT(11);
	DECLARE loan CURSOR FOR
		SELECT pl.`user_id`, pl.`partner_loan_id`, pct.`payroll_date`, pl.`payment_mode_id`,
			ROUND(AES_DECRYPT(pl.`running_balance`, encryption_key ()),2),
			ROUND(AES_DECRYPT(pl.`system_amortization`, encryption_key ()),2),
			ROUND(AES_DECRYPT(pl.`user_amortization`, encryption_key ()),2),
			pl.`loan_status_id`, ROUND(AES_DECRYPT( pl.`total_amount_paid`, encryption_key ()),2),
			pl.`no_payments_paid`, pl.`no_payments_remaining`
		FROM ww_payroll_current_transaction pct
		INNER JOIN ww_payroll_partners_loan pl ON pct.`employee_id` = pl.user_id AND pl.`partner_loan_id` = pct.`record_id`
		INNER JOIN ww_payroll_transaction_class ptc ON ptc.`transaction_class_id` = pct.`transaction_class_id`
		WHERE ptc.`transaction_class_code` IN ('LOAN_AMORTIZATION')
			AND pct.`deleted` = 0 AND pl.`deleted` = 0
			AND pct.`period_id` = periodid AND pct.`employee_id` = puserid
			AND AES_DECRYPT( pl.`running_balance` , encryption_key() ) > 0 AND pl.`loan_status_id` = 2;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	
	OPEN loan;
	myLoop: LOOP
		FETCH loan INTO emp_id, ploan_id, paydate, pay_mode, run_bal, sys_amort, user_amort, ln_status_id, tot_amt_pd, no_pay_pd, no_pay_rem;
		
		IF done THEN
		    CLOSE loan;
		    LEAVE myLoop;
		END IF;
		-- get arrears
		SET @arrears = 0;
		SELECT SUM( AES_DECRYPT(pct.amount, encryption_key ()) ) INTO @arrears 
		FROM ww_payroll_current_transaction pct 
		INNER JOIN ww_payroll_transaction_class ptc ON pct.transaction_class_id = ptc.transaction_class_id 
		WHERE pct.`record_id` = ploan_id AND pct.`employee_id` = emp_id 
			  AND ptc.`transaction_class_code` IN ('LOAN_AMORTIZATION','LOAN_INTEREST') 
			  AND pct.`on_hold` = 1 AND pct.`deleted` = 0 ;
		
		IF @arrears IS NULL THEN
			SET @arrears = 0;
		END IF;
		-- get amortization
		SET @amor = 0;
		SELECT SUM( AES_DECRYPT(pct.amount, encryption_key ()) ) INTO @amor 
		FROM ww_payroll_current_transaction pct 
		INNER JOIN ww_payroll_transaction_class ptc ON pct.transaction_class_id = ptc.transaction_class_id 
		WHERE pct.`record_id` = ploan_id AND pct.`employee_id` = emp_id 
			  AND ptc.`transaction_class_code` IN ('LOAN_AMORTIZATION','LOAN_INTEREST') 
			  AND pct.`on_hold` = 0 AND pct.`deleted` = 0 ;
		
		IF @amor IS NULL THEN
			SET @amor = 0;
		END IF;
		
		IF @amor > 0 THEN
			BEGIN
				SET run_bal = run_bal - @amor;
				IF run_bal < sys_amort THEN
					SET sys_amort = run_bal;
				END IF;
				IF run_bal < user_amort THEN
					SET user_amort = run_bal;
				END IF;
				
				SET tot_amt_pd = tot_amt_pd + @amor;
				SET no_pay_pd = no_pay_pd + 1;
			END;
		END IF;
		
		IF pay_mode = 3 THEN
			SET pay_mode = 2;
		END IF;
		IF pay_mode = 4 THEN
			SET pay_mode = 1;
		END IF;
		
		IF run_bal <= 0.001 THEN
			SET ln_status_id = 4;
		END IF;
		
		IF pay_mode = 3 OR pay_mode = 2 THEN
			BEGIN
				IF @amor != 0 THEN
					SET no_pay_rem = ROUND(run_bal / user_amort);
				END IF;
				IF no_pay_rem * user_amort < run_bal THEN
					SET no_pay_rem = no_pay_rem + 1;
				END IF;
			END;
		END IF;
		
		IF pay_mode = 4 OR pay_mode = 1 THEN
			BEGIN
				IF @amor != 0 THEN
					SET no_pay_rem = ROUND(run_bal / sys_amort);
				END IF;
				IF no_pay_rem * sys_amort < run_bal THEN
					SET no_pay_rem = no_pay_rem + 1;
				END IF;
			END;
		END IF;
		
		UPDATE ww_payroll_partners_loan SET 
			`running_balance` = AES_ENCRYPT( ROUND( run_bal, 2) , encryption_key() ),
			`system_amortization` = AES_ENCRYPT( ROUND( sys_amort, 2) , encryption_key() ),
			`user_amortization` = AES_ENCRYPT( ROUND( user_amort, 2) , encryption_key() ),
			`total_arrears` = AES_ENCRYPT( ROUND( @arrears, 2) , encryption_key() ),
			`total_amount_paid` = AES_ENCRYPT( ROUND( tot_amt_pd, 2) , encryption_key() ),
			`last_payment_date` = paydate,
			`loan_status_id` = ln_status_id,
			`payment_mode_id` = pay_mode,
			`no_payments_paid` = no_pay_pd,
			`no_payments_remaining` = no_pay_rem
		WHERE partner_loan_id  = ploan_id AND `user_id` = emp_id;
		
		CALL sp_payroll_loan_payments(emp_id, ploan_id);
	END LOOP;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_closed_period` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_closed_period` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_closed_period`(
	IN periodid INT(11)
    )
BEGIN
	DECLARE closed_period_done TINYINT(11) DEFAULT 0;
	DECLARE emp_id INT(11);
	DECLARE per_id INT(11);
	DECLARE paydate DATE;
	DECLARE employee CURSOR FOR
		SELECT DISTINCT `period_id`, `employee_id`, `payroll_date`
		FROM `ww_payroll_current_transaction` 
		WHERE `deleted` = 0 AND `on_hold` = 0 AND `period_id` = periodid;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET closed_period_done = 1;
	OPEN employee;
	
	myLoop: LOOP
		FETCH employee INTO per_id, emp_id, paydate;
		
		IF closed_period_done THEN
		    SELECT COUNT(*) INTO @cls_cnt FROM ww_payroll_current_transaction WHERE deleted = 0 AND period_id = per_id AND on_hold = 0;
		    IF @cls_cnt = 0 THEN
			UPDATE `ww_payroll_period` SET `period_status_id` = 3 WHERE `payroll_period_id` = per_id;
			UPDATE `ww_payroll_leave_conversion_period` SET `status` = 3 WHERE `payroll_date` = paydate AND `status` = 2 AND deleted = 0;
		    END IF;
		    CLOSE employee;
		    LEAVE myLoop;
		END IF;
		-- transfer and update loans
		CALL sp_payroll_closed_loan(per_id, emp_id);
		
		-- employee summary
		-- check if has record on payroll_closed_summary
		SET @count = 0;
		SELECT COUNT(*) INTO @count FROM `ww_payroll_closed_summary` WHERE `user_id` = emp_id AND `year` = YEAR(paydate) AND `deleted` = 0;
		IF @count = 0 THEN
			-- insert record on payroll_closed_summary
			CALL sp_payroll_closed_summary_insert( emp_id, paydate);
		END IF;
		
		BEGIN
			DECLARE s_done TINYINT(1) DEFAULT 0;
			DECLARE tran_code VARCHAR(32);
			DECLARE summary CURSOR FOR
				SELECT `summary_code` FROM `ww_payroll_closed_summary`
				WHERE `user_id` = emp_id AND `year` = YEAR(paydate)
					AND deleted = 0;
			DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET s_done = 1;
			OPEN summary;
			
			mySummary: LOOP
				FETCH summary INTO tran_code;
				
				IF s_done THEN
					CLOSE summary;
					LEAVE mySummary;
				END IF;
				SET @amt = 0;
				CALL sp_payroll_closed_summary_amt( emp_id, paydate, tran_code, @result );
				SET @amt = @result;
				
				IF @amt IS NOT NULL THEN
					-- update payroll_closed_summary
					CALL sp_payroll_closed_summary_update( emp_id, paydate, tran_code, @amt );
				END IF;
				
			END LOOP;
		END;
		
		-- transfer transaction
		CALL sp_payroll_closed_transaction(per_id, emp_id);
		-- remove transaction
		DELETE FROM ww_payroll_current_transaction
		WHERE `deleted` = 0 AND `on_hold` = 0 AND `employee_id` = emp_id AND `period_id` = per_id;
		
		UPDATE ww_payroll_partners SET `remain` = `remain` - 1 WHERE user_id = emp_id;
		
		-- Insert Data to Payroll BIR
		-- CALL `sp_payroll_bir_record`( emp_id, YEAR(paydate), 0 );
		
	END LOOP;
	
	BEGIN
		DECLARE closed_bir_done TINYINT(11) DEFAULT 0;
		DECLARE bir_emp_id INT(11);
		DECLARE bir_per_id INT(11);
		DECLARE bir_paydate DATE;
		DECLARE bir_employee CURSOR FOR
			SELECT DISTINCT `period_id`, `employee_id`, `payroll_date`
			FROM `ww_payroll_closed_transaction` WHERE `deleted` = 0 AND `period_id` = periodid;
		DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET closed_bir_done = 1;
		OPEN bir_employee;
		mybirLoop: LOOP
			FETCH bir_employee INTO bir_per_id, bir_emp_id, bir_paydate;
	
			IF closed_bir_done THEN
				CLOSE bir_employee;
				LEAVE mybirLoop;
			END IF;
			-- Insert Data to Payroll BIR
			CALL `sp_payroll_bir_record`( bir_emp_id, YEAR(bir_paydate), 0 );
		END LOOP;
	END;
	
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_closed_summary_amt` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_closed_summary_amt` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_closed_summary_amt`(
	in puserid int(11),
	in paydate date,
	in tran_code varchar(32),
	out nAmount decimal(12,2)
    )
BEGIN
	    set @tran = tran_code;
		SELECT 
		  CASE @tran 
		    WHEN 'TAXABLE_INCOME' THEN SUM( AES_DECRYPT(amount, encryption_key ()) * (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'DEDUCTION_LATE' THEN - 1 
			  WHEN 'DEDUCTION_UNDERTIME' THEN - 1 
			  WHEN 'ABSENCES' THEN - 1 
			  WHEN 'TAXABLE_DEDUCTION' THEN - 1 
			  ELSE 1 
			END
		      )
		    ) 
		    WHEN 'SALARY' THEN SUM( AES_DECRYPT(amount, encryption_key ()) * (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'SALARY' THEN 1 ELSE - 1 
			END
		      )
		    ) 
		    ELSE SUM(
		      AES_DECRYPT(amount, encryption_key ())
		    ) 
		  END
		into nAmount
		FROM ww_payroll_current_transaction pct 
		LEFT JOIN ww_payroll_transaction_class ptc ON pct.transaction_class_id = ptc.transaction_class_id 
		WHERE pct.employee_id = puserid and pct.payroll_date = paydate
		  AND (
		    CASE @tran 
		      WHEN 'TAXABLE_INCOME' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'SALARY' THEN 1 WHEN 'OVERTIME' THEN 1 WHEN 'BONUS_TAXABLE' THEN 1 
			  WHEN 'ALLOWANCE_BATCH' THEN 1 WHEN 'ALLOWANCE_RECURRING' THEN 1 WHEN 'LEAVES' THEN 1 
			  WHEN 'ABSENCES' THEN 1 WHEN 'DEDUCTION_LATE' THEN 1 WHEN 'DEDUCTION_UNDERTIME' THEN 1 
			  WHEN 'TAXABLE_DEDUCTION' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'BONUS' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'BONUS' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'BONUS_TAXABLE' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'BONUS_TAXABLE' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'ADDITIONAL_EXCLUSION' THEN (
			CASE
			  ptc.government_mandated 
			  WHEN 1 THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'SALARY' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'SALARY' THEN 1 WHEN 'ABSENCES' THEN 1 WHEN 'DEDUCTION_LATE' THEN 1 
			  WHEN 'DEDUCTION_UNDERTIME' THEN 1 ELSE 0 
			END
		      ) 
		      
		      WHEN 'ALLOW_NSTD' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'ALLOWANCE_BATCH' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'BENEFIT_STD' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'BENEFIT_RECURRING' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'BENEFIT_NSTD' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'BENEFIT_BATCH' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'DEDUCTION_STD' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'DEDUCTION_RECURRING' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'DEDUCTION_NSTD' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'DEDUCTION_BATCH' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'OVERTIME' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'OVERTIME' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'DEMMINIMIS' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'DE_MINIMIS_BENEFIT_RECURRING' THEN 1 when 'DE_MINIMIS_BENEFIT_BATCH' then 1 ELSE 0 
			END
		      ) 
		      WHEN 'LEAVES' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'LEAVES' THEN 1 ELSE 0 
			END
		      ) 
		      ELSE (
			CASE
			  @tran 
			  WHEN ptc.transaction_class_code THEN 1 ELSE 0 
			END
		      ) 
		    END
		  ) = 1 ;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_closed_summary_insert` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_closed_summary_insert` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_closed_summary_insert`(
	in puserid INT(11),
	in paydate date
    )
BEGIN
	
	set @comp_id = '';
	set @dept_id = '';
	SELECT ifnull(p.`company_id`, u.company_id), u.`department_id`
	into @comp_id, @dept_id
	FROM ww_users_profile u	
	INNER join ww_payroll_partners p on p.user_id = u.user_id
	where u.`user_id` = puserid;
	
	insert into ww_payroll_closed_summary(
		`user_id`, `company_id`, `department_id`, `type`, `year`, `summary_id`, `summary_code`, `created_on`,
		`january`, `february`, `march`, `april`, `may`, `june`, `july`, `august`, `september`, `october`,
		`november`, `december`, `ytd`) 
	select puserid, @comp_id, @dept_id, 'C', year(paydate), `summary_id`, `summary_code`, now(),
		aes_encrypt( 0.00, encryption_key()),AES_ENCRYPT( 0.00, encryption_key()),AES_ENCRYPT( 0.00, encryption_key()),
		AES_ENCRYPT( 0.00, encryption_key()),AES_ENCRYPT( 0.00, encryption_key()),AES_ENCRYPT( 0.00, encryption_key()),
		AES_ENCRYPT( 0.00, encryption_key()),AES_ENCRYPT( 0.00, encryption_key()),AES_ENCRYPT( 0.00, encryption_key()),
		AES_ENCRYPT( 0.00, encryption_key()),AES_ENCRYPT( 0.00, encryption_key()),AES_ENCRYPT( 0.00, encryption_key()),AES_ENCRYPT( 0.00, encryption_key())
	from ww_payroll_closed_summary_id
	order by summary_id;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_closed_summary_update` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_closed_summary_update` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_closed_summary_update`(
	in puserid int(11),
	in paydate date,
	in tran_code varchar(32),
	in amount decimal(12,2)
    )
BEGIN
	
	set @nMonth = 0;
	set @nYear = 0;
	set @nMonth = month( paydate );
	set @nYear = year( paydate );
	If @nMonth = 1 then
		update ww_payroll_closed_summary set 
			ytd = aes_encrypt( aes_decrypt( ytd, encryption_key() ) + amount, encryption_key() ), 
			january = AES_ENCRYPT( AES_DECRYPT( january, encryption_key() ) + amount, encryption_key() )
		where user_id = puserid and summary_code = tran_code and type = 'C' and `year` = @nYear;
	ELSEIF @nMonth = 2 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			february = AES_ENCRYPT( AES_DECRYPT( february, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 3 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			march = AES_ENCRYPT( AES_DECRYPT( march, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 4 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			april= AES_ENCRYPT( AES_DECRYPT( april, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 5 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			may = AES_ENCRYPT( AES_DECRYPT( may, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 6 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			june = AES_ENCRYPT( AES_DECRYPT( june, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 7 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			july = AES_ENCRYPT( AES_DECRYPT( july, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 8 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			august = AES_ENCRYPT( AES_DECRYPT( august, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 9 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			september = AES_ENCRYPT( AES_DECRYPT( september, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 10 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			october = AES_ENCRYPT( AES_DECRYPT( october, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 11 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			november = AES_ENCRYPT( AES_DECRYPT( november, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 12 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) + amount, encryption_key() ), 
			december = AES_ENCRYPT( AES_DECRYPT( december, encryption_key() ) + amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	end if;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_closed_summary_update_correction` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_closed_summary_update_correction` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_closed_summary_update_correction`(
	in puserid int(11),
	in paydate date,
	in tran_code varchar(32),
	in amount decimal(12,2)
    )
BEGIN
	
	set @nMonth = 0;
	set @nYear = 0;
	set @nMonth = month( paydate );
	set @nYear = year( paydate );
	If @nMonth = 1 then
		update ww_payroll_closed_summary set 
			ytd = aes_encrypt( aes_decrypt( ytd, encryption_key() ) - amount, encryption_key() ), 
			january = AES_ENCRYPT( AES_DECRYPT( january, encryption_key() ) - amount, encryption_key() )
		where user_id = puserid and summary_code = tran_code and type = 'C' and `year` = @nYear;
	ELSEIF @nMonth = 2 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			february = AES_ENCRYPT( AES_DECRYPT( february, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 3 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			march = AES_ENCRYPT( AES_DECRYPT( march, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 4 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			april= AES_ENCRYPT( AES_DECRYPT( april, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 5 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			may = AES_ENCRYPT( AES_DECRYPT( may, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 6 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			june = AES_ENCRYPT( AES_DECRYPT( june, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 7 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			july = AES_ENCRYPT( AES_DECRYPT( july, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 8 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			august = AES_ENCRYPT( AES_DECRYPT( august, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 9 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			september = AES_ENCRYPT( AES_DECRYPT( september, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 10 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			october = AES_ENCRYPT( AES_DECRYPT( october, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 11 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			november = AES_ENCRYPT( AES_DECRYPT( november, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	ELSEIF @nMonth = 12 THEN
		UPDATE ww_payroll_closed_summary SET 
			ytd = AES_ENCRYPT( AES_DECRYPT( ytd, encryption_key() ) - amount, encryption_key() ), 
			december = AES_ENCRYPT( AES_DECRYPT( december, encryption_key() ) - amount, encryption_key() )
		WHERE user_id = puserid AND summary_code = tran_code AND TYPE = 'C' AND `year` = @nYear;
	end if;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_closed_transaction` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_closed_transaction` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_closed_transaction`( 
	IN periodid INT(11),
	IN puserid INT(11)
    )
BEGIN
	-- transfer current transaction to closed transaction table
	INSERT INTO `ww_payroll_closed_transaction`
            (`period_id`, `processing_type_id`, `payroll_date`, `company_id`, `employee_id`, `transaction_id`,`transaction_class_id`,
             `transaction_code`, `quantity`, `unit_rate`, `amount`, `transaction_type_id`,
             `inserted_from_id`, `record_from`, `record_id`, `on_hold`, `remarks`, 
             branch_id, group_id, department_id, section_id, division_id, position_id, location_id, payment_type_id, minwageflag,
             `created_by`, `created_on`, `modified_by`, `modified_on`)
        SELECT `period_id`, `processing_type_id`, `payroll_date`, `company_id`, `employee_id`, `transaction_id`,`transaction_class_id`,
             `transaction_code`, `quantity`, `unit_rate`, `amount`, `transaction_type_id`,
             `inserted_from_id`, `record_from`, `record_id`, `on_hold`, `remarks`, 
             branch_id, group_id, department_id, section_id, division_id, position_id, location_id, payment_type_id, minwageflag,
             `created_by`, `created_on`, `modified_by`, `modified_on`
	FROM `ww_payroll_current_transaction`
	WHERE `deleted` = 0 AND `on_hold` = 0 AND `period_id` = periodid AND `employee_id` = puserid;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_employee_info` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_employee_info` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_employee_info`(
	IN puserid INT(11),
	OUT nStatus INT(11), 
	OUT nEmp_type_id INT(11), 
	OUT dtEff DATE,
	OUT dtRes DATE,
	OUT nShift INT(11),
	OUT nTaxcode INT(11), 
	OUT nPayrate INT(11), 
	OUT nPaysched INT(11), 
	OUT nTotal_year_days DECIMAL(5,2), 
	OUT nSalary DECIMAL(12,2),
	OUT nMin_takehome DECIMAL(12,2), 
	OUT sBank_acct VARCHAR(32), 
	OUT nPayLocation INT(11), 
	OUT sSSS_no VARCHAR(16), 
	OUT nSSS_mode INT(11), 
	OUT sSSS_week VARCHAR(32),
	OUT nSSS_amount DECIMAL(12,2), 
	OUT sHDMF_no VARCHAR(16), 
	OUT nHDMF_mode INT(11), 
	OUT sHDMF_week VARCHAR(32),
	OUT nHDMF_amount DECIMAL(12,2), 
	OUT sPHIC_no VARCHAR(16), 
	OUT nPHIC_mode INT(11), 
	OUT sPHIC_week VARCHAR(32),
	OUT nPHIC_amount DECIMAL(12,2), 
	OUT sEcola_week VARCHAR(32),
	OUT sTIN VARCHAR(32),
	OUT nTax_mode INT(11),
	OUT nTax_amount DECIMAL(12,2),
	OUT sTax_week VARCHAR(32),
	OUT nSensitivity INT(11),
	OUT nDivisor INT(11),
	OUT nCompany INT(11),
	OUT nGroup INT(11),
	OUT nDivision INT(11),
	OUT nDepartment INT(11),
	OUT nSection INT(11),
	OUT nPosition INT(11),
	OUT nProject INT(11),
	OUT nReports_to INT(11),
	OUT nJobtitle INT(11),
	OUT nLocation INT(11),
	OUT nRemain INT(11),
	OUT nAttendanceBase TINYINT(1),
	OUT nHold TINYINT(1),
	OUT nPaymentType TINYINT(1)
    )
BEGIN
	SELECT 
		b.`status_id`, b.`employment_type_id`, b.`effectivity_date`, b.`resigned_date`, b.`shift_id`,
		a.`taxcode_id`, a.`payroll_rate_type_id`, a.`payroll_schedule_id`, a.`total_year_days`, 
		AES_DECRYPT(a.`salary`, encryption_key()),
		AES_DECRYPT(a.`minimum_takehome`, encryption_key()), a.`bank_account`, a.`location_id`, 
		a.`sss_no`, a.`sss_mode`, a.`sss_week`, AES_DECRYPT(a.`sss_amount`, encryption_key()), 
		a.`hdmf_no`, a.`hdmf_mode`, a.`hdmf_week`, AES_DECRYPT(a.`hdmf_amount`, encryption_key()),
		a.`phic_no`, a.`phic_mode`, a.`phic_week`, AES_DECRYPT(a.`phic_amount`, encryption_key()),
		a.`ecola_week`, a.`tin`, a.`tax_mode`, AES_DECRYPT(a.`tax_amount`, encryption_key()), a.`tax_week`, a.`sensitivity`, d.`divisor`,
		a.`company_id`, c.`group_id`, c.`division_id`, c.`department_id`, s.`section_id`,c.`position_id`, c.project_id,
		c.`reports_to_id`, c.`job_title_id`, c.`location_id`, a.`remain`, a.`attendance_base`, a.`on_hold`, a.payment_type_id
	INTO
		nStatus, nEmp_type_id, dtEff, dtRes, nShift, nTaxcode, nPayrate, nPaysched,
		nTotal_year_days, nSalary, nMin_takehome, sBank_acct, nPayLocation,
		sSSS_no, nSSS_mode, sSSS_week, nSSS_amount,
		sHDMF_no, nHDMF_mode, sHDMF_week, nHDMF_amount,
		sPHIC_no, nPHIC_mode, sPHIC_week, nPHIC_amount,
		sEcola_week, sTIN, nTax_mode, nTax_amount, sTax_week, nSensitivity, nDivisor,
		nCompany, nGroup, nDivision, nDepartment, nSection, nPosition, nProject, 
		nReports_to, nJobtitle, nLocation, nRemain, nAttendanceBase, nHold, nPaymentType
	FROM ww_payroll_partners a
	INNER JOIN ww_partners b ON a.`user_id` = b.`user_id`
	INNER JOIN ww_users_profile c ON c.`user_id` = a.`user_id`
	LEFT JOIN ww_payroll_schedule_rate_divisor d ON a.`payroll_schedule_id` = d.`payroll_schedule_id` 
		AND a.`payroll_rate_type_id` = d.`payroll_rate_type_id`
	LEFT JOIN ww_users_section s ON get_partners_personal(a.user_id,'section') = s.`section`
	WHERE a.`user_id` = puserid ;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_final_pay` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_final_pay` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_final_pay`(
	IN periodid int(11),
	IN puserid int(11)
    )
BEGIN
	/*
	step 1: Compute remaining Attendance
	step 2: Allowances / Tenure
	step 3: Bonuses
	step 4: Annualized Tax
	step 5: Loans / other deductions
	1. Computation of Tenure ( if Applicable )
	2. Computation of Bonus
	       Bonus = ( Salary / 12 ) * No. of Months
	3. Loans Condition
	   - If last pay Running Balance to be deduct
	    ex: Stanford Salary Loan
		 Running Balance = 8,000.00
		 * 8,000.00 will be deduction on the last pay to settle the loan
         */
        
        DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
	    -- ERROR
	  ROLLBACK;
	END;
	START TRANSACTION;
	-- employee info
	SET @sSSS_week = '';
	SET @nStatus = '';
	SET @nEmp_type_id = '';
	SET @dtEff = '';
	SET @dtRes = '';
	SET @nShift = '';
	SET @nTaxcode = '';
	SET @nPayrate = '';
	SET @nPaysched = '';
	SET @nTotal_year_days = '';
	SET @nSalary = '';
	SET @nMin_takehome = '';
	SET @sBank_acct = '';
	SET @nPayLocation = '';
	SET @sSSS_no = '';
	SET @nSSS_mode = '';
	SET @sSSS_week = '';
	SET @nSSS_amount = '';
	SET @sHDMF_no = '';
	SET @nHDMF_mode = '';
	SET @sHDMF_week = '';
	SET @nHDMF_amount = '';
	SET @sPHIC_no = '';
	SET @nPHIC_mode = '';
	SET @sPHIC_week = '';
	SET @nPHIC_amount = '';
	SET @sEcola_week = '';
	SET @sTIN = '';
	SET @nTax_mode = '';
	SET @sTax_week = '';
	SET @nSensitivity = '';
	SET @nDivisor = '';
	SET @nCompany = '';
	SET @nGroup = '';
	SET @nDivision = '';
	SET @nDepartment = '';
	SET @nPosition = '';
	SET @nReports_to = '';
	SET @nJobtitle = '';
	SET @nLocation = '';
	SET @nRemain = '';
	SET @nAttendanceBase = '';
	SET @nHold = '';
	-- period info
	SET @period_status_id = 0;
	SET @payroll_date = '';
	SET @date_from = '';
	SET @date_to = '';
	SET @date_closing = '';
	SET @sweek = '';
	SET @payroll_schedule_id = 0;
	SET @period_processing_type_id = 0;
	set @basic_allowances = 0;
	set @include_13th_month_pay = 0;
	SET @apply_to_id = 0;
	set @nTax_amount = 0;
    -- employee info
	CALL `sp_payroll_employee_info`(puserid, 
		@nStatus, @nEmp_type_id, @dtEff, @dtRes, @nShift, 
		@nTaxcode, @nPayrate, @nPaysched, @nTotal_year_days, @nSalary, 
		@nMin_takehome, @sBank_acct, @nPayLocation, @sSSS_no, @nSSS_mode, 
		@sSSS_week, @nSSS_amount, @sHDMF_no, @nHDMF_mode, @sHDMF_week, 
		@nHDMF_amount, @sPHIC_no, @nPHIC_mode, @sPHIC_week, @nPHIC_amount, 
		@sEcola_week, @sTIN, @nTax_mode, @nTax_amount, @sTax_week, @nSensitivity, @nDivisor, 
		@nCompany, @nGroup, @nDivision, @nDepartment, @nSection, @nPosition, @nProject, @nReports_to,
		@nJobtitle, @nLocation, @nRemain, @nAttendanceBase, @nHold, @nPaymentType);
		
	-- period info
	SELECT `period_status_id`, `payroll_date`, `date_from`, `date_to`, `date_closing`, `week`, 
		`payroll_schedule_id`, `period_processing_type_id`, `include_basic_and_allowances`, `include_13th_month_pay`, `apply_to_id`
	INTO @period_status_id, @payroll_date, @date_from, @date_to, @date_closing, @sweek, 
		@payroll_schedule_id, @period_processing_type_id, @basic_allowances, @include_13th_month_pay, @apply_to_id
	FROM ww_payroll_period WHERE payroll_period_id = periodid AND deleted = 0;
	
	-- select @period_status_id, @payroll_date, @date_from, @date_to, @date_closing, @sweek;
	IF @period_status_id != 3 THEN
		DELETE FROM ww_payroll_current_transaction WHERE `employee_id` = puserid AND `period_id` = periodid;
	END IF;
	
	-- get hourly rate
	set @nHourlyRate = 0;
	IF @nPayrate = 2 THEN
		SET @DailySalary = 0;
		SET @DailySalary = @nSalary / ( @nTotal_year_days / 12 );
		set @nHourlyRate = round( @DailySalary / 8 , 2);
	-- weekly
	ELSEIF @nPayrate = 6 THEN
		SET @DailySalary = 0;	
		SET @DailySalary = @nSalary;
		SET @nHourlyRate = ROUND( @DailySalary / 8 , 2);
	END IF;
	
	if @basic_allowances != 0 then
		-- compute last period
		call sp_payroll_final_pay_last_period( puserid, @nCompany, @nHourlyRate, @dtRes, periodid, @payroll_date, @period_processing_type_id);
		-- compute recurring
		-- CALL sp_payroll_get_recurring(puserid, periodid, @sweek, @payroll_date, @period_processing_type_id);
	end if;	
	-- compute overtime
	 
	CALL sp_payroll_final_pay_overtime( puserid, @dtRes, @payroll_date, periodid, @period_processing_type_id );
		
	-- compute late approve overtime
	CALL sp_payroll_final_pay_overtime_lf( puserid, @dtRes, @payroll_date, periodid, @period_processing_type_id );	
	
	-- compute late, undertime and absences
	CALL `sp_payroll_get_absences`( puserid, @payroll_date, periodid, @period_processing_type_id );
	CALL `sp_payroll_get_lates`( puserid, @payroll_date, periodid, @period_processing_type_id );
	CALL `sp_payroll_get_undertime`( puserid, @payroll_date, periodid, @period_processing_type_id );
	
		-- latefile = 1
	CALL `sp_payroll_get_absences_adj`( puserid, @payroll_date, periodid, @period_processing_type_id );
	CALL `sp_payroll_get_lates_adj`( puserid, @payroll_date, periodid, @period_processing_type_id );
	CALL `sp_payroll_get_undertime_adj`( puserid, @payroll_date, periodid, @period_processing_type_id );
						
	-- compute loan amortization
	CALL sp_payroll_get_loan_amortization( puserid, periodid, @payroll_date, @period_processing_type_id, @sweek );
	
	-- compute loan interest
	CALL sp_payroll_get_loan_interest( puserid, periodid, @payroll_date, @period_processing_type_id, @sweek );
	-- compute batch entry
	CALL sp_payroll_get_batch(puserid, periodid, @payroll_date, @period_processing_type_id);
			
	-- compute bonus
	IF @include_13th_month_pay != 0 THEN
		CALL sp_payroll_final_pay_bonus(puserid, periodid, @dtRes, @payroll_date, @period_processing_type_id);
	end if;
	
	-- force convert SL/VL and SIL
	-- IF @nStatus != 2 and @nStatus != 12 THEN
	IF @nStatus != 2 THEN
		-- if final pay does not execute it is one of the possible error due to there was multiple leave balance record with in a year. check if error occured
		CALL sp_payroll_final_pay_leave_conversion(puserid, periodid, @nCompany, @payroll_date, @dtRes, @DailySalary, @nEmp_type_id, @period_processing_type_id);
	end if;
	
	SET @Not_MinWage = 0;
	SET @min_wage_amt = 0;
	SET @ecola_amt = 0;
	SELECT `min_wage_amt`, `ecola_amt` 
	INTO @min_wage_amt, @ecola_amt
	FROM ww_users_location WHERE `location_id` = @nPayLocation AND `deleted` = 0;
	IF @min_wage_amt >= @DailySalary THEN
		-- CALL sp_payroll_get_ecola(puserid, periodid, @payroll_date, @ecola_amt, @period_processing_type_id);
		SET @Not_MinWage = 1;
	END IF;
	-- compute/update amount = base_on_earning
	SET @cur_tran_id = 0;
	SELECT `id` INTO @cur_tran_id
	FROM ww_payroll_current_transaction WHERE AES_DECRYPT( `amount`, encryption_key() ) = 'base_on_earning' 
		AND `employee_id` = puserid AND `payroll_date` = @payroll_date AND `deleted` = 0;
	IF @cur_tran_id > 0 THEN
		SET @result = 0.00;
		CALL sp_payroll_get_transaction(puserid,periodid,'1,5',1,1,1,0,@result);
		UPDATE ww_payroll_current_transaction SET `unit_rate` = AES_ENCRYPT( @result, encryption_key() ), `amount` = AES_ENCRYPT( @result, encryption_key() )
			WHERE `id` = @cur_tran_id;
	END IF;
	
	-- compute wtax
	-- Based on Tax Table
	IF @Not_MinWage = 0 THEN
		-- Annualized		
		 CALL sp_payroll_get_tax_annualize( puserid, periodid, @payroll_date, @dtRes, @period_processing_type_id, @payroll_schedule_id, @nTaxcode, @nRemain );
	END IF;
	-- compute netpay
	CALL sp_payroll_get_netpay( periodid, puserid, @payroll_date, @period_processing_type_id ) ;
	-- update payroll details
	UPDATE ww_payroll_current_transaction a, ww_users_profile b SET 
		a.company_id = @nCompany,
		a.branch_id = b.branch_id,
		a.group_id = @nGroup,
		a.department_id = @nDepartment,
		a.section_id = @nSection,
		a.division_id = @nDivision,
		a.position_id = @nPosition,
		a.location_id = @nLocation,
		a.payment_type_id = @nPaymentType,
		a.minwageflag = @Not_MinWage
	WHERE a.employee_id = puserid AND a.employee_id = b.user_id AND a.period_id = periodid AND a.payroll_date = @payroll_date;
		
	UPDATE ww_payroll_period SET `period_status_id` = 2 WHERE payroll_period_id = periodid ;
	COMMIT;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_final_pay_backup` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_final_pay_backup` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_final_pay_backup`(
	IN periodid int(11),
	IN puserid int(11)
    )
BEGIN
	/*
	step 1: Compute remaining Attendance
	step 2: Allowances / Tenure
	step 3: Bonuses
	step 4: Annualized Tax
	step 5: Loans / other deductions
	1. Computation of Tenure ( if Applicable )
	2. Computation of Bonus
	       Bonus = ( Salary / 12 ) * No. of Months
	3. Loans Condition
	   - If last pay Running Balance to be deduct
	    ex: Stanford Salary Loan
		 Running Balance = 8,000.00
		 * 8,000.00 will be deduction on the last pay to settle the loan
         */
        
        DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
	    -- ERROR
	  ROLLBACK;
	END;
	START TRANSACTION;
	-- employee info
	SET @sSSS_week = '';
	SET @nStatus = '';
	SET @nEmp_type_id = '';
	SET @dtEff = '';
	SET @dtRes = '';
	SET @nShift = '';
	SET @nTaxcode = '';
	SET @nPayrate = '';
	SET @nPaysched = '';
	SET @nTotal_year_days = '';
	SET @nSalary = '';
	SET @nMin_takehome = '';
	SET @sBank_acct = '';
	SET @nPayLocation = '';
	SET @sSSS_no = '';
	SET @nSSS_mode = '';
	SET @sSSS_week = '';
	SET @nSSS_amount = '';
	SET @sHDMF_no = '';
	SET @nHDMF_mode = '';
	SET @sHDMF_week = '';
	SET @nHDMF_amount = '';
	SET @sPHIC_no = '';
	SET @nPHIC_mode = '';
	SET @sPHIC_week = '';
	SET @nPHIC_amount = '';
	SET @sEcola_week = '';
	SET @sTIN = '';
	SET @nTax_mode = '';
	SET @sTax_week = '';
	SET @nSensitivity = '';
	SET @nDivisor = '';
	SET @nCompany = '';
	SET @nGroup = '';
	SET @nDivision = '';
	SET @nDepartment = '';
	SET @nPosition = '';
	SET @nReports_to = '';
	SET @nJobtitle = '';
	SET @nLocation = '';
	SET @nRemain = '';
	SET @nAttendanceBase = '';
	SET @nHold = '';
	-- period info
	SET @period_status_id = 0;
	SET @payroll_date = '';
	SET @date_from = '';
	SET @date_to = '';
	SET @date_closing = '';
	SET @sweek = '';
	SET @payroll_schedule_id = 0;
	SET @period_processing_type_id = 0;
	SET @apply_to_id = 0;
	
    -- employee info
	CALL `sp_payroll_employee_info`(puserid, 
		@nStatus, @nEmp_type_id, @dtEff, @dtRes, @nShift, 
		@nTaxcode, @nPayrate, @nPaysched, @nTotal_year_days, @nSalary, 
		@nMin_takehome, @sBank_acct, @nPayLocation, @sSSS_no, @nSSS_mode, 
		@sSSS_week, @nSSS_amount, @sHDMF_no, @nHDMF_mode, @sHDMF_week, 
		@nHDMF_amount, @sPHIC_no, @nPHIC_mode, @sPHIC_week, @nPHIC_amount, 
		@sEcola_week, @sTIN, @nTax_mode, @sTax_week, @nSensitivity, @nDivisor, 
		@nCompany, @nGroup, @nDivision, @nDepartment, @nPosition, @nReports_to,
		@nJobtitle, @nLocation, @nRemain, @nAttendanceBase, @nHold);
		
    -- period info
	SELECT `period_status_id`, `payroll_date`, `date_from`, `date_to`, `date_closing`, `week`, 
		`payroll_schedule_id`, `period_processing_type_id`, `apply_to_id`
	INTO @period_status_id, @payroll_date, @date_from, @date_to, @date_closing, @sweek, 
		@payroll_schedule_id, @period_processing_type_id, @apply_to_id
	FROM ww_payroll_period WHERE payroll_period_id = periodid AND deleted = 0;
	
	IF @period_status_id != 3 THEN
		DELETE FROM ww_payroll_current_transaction WHERE `employee_id` = puserid AND `period_id` = periodid;
	END IF;
	
	-- compute overtime
	CALL sp_payroll_get_overtime( puserid, @payroll_date, periodid, @period_processing_type_id );
	
	-- compute late approve overtime
	CALL sp_payroll_get_overtime_lf( puserid, @payroll_date, periodid, @period_processing_type_id );	
	
	-- compute loan amortization
	CALL sp_payroll_get_loan_amortization( puserid, periodid, @payroll_date, @period_processing_type_id, @sweek );
	
	-- compute loan interest
	CALL sp_payroll_get_loan_interest( puserid, periodid, @payroll_date, @period_processing_type_id, @sweek );
	
	-- compute recurring
	CALL sp_payroll_get_recurring(puserid, periodid, @sweek, @payroll_date, @period_processing_type_id);
	
	-- compute batch entry
	CALL sp_payroll_get_batch(puserid, periodid, @payroll_date, @period_processing_type_id);
	
	-- compute bonus
	CALL sp_payroll_get_bonus(puserid, periodid, @payroll_date, @nSalary, @period_processing_type_id);
	
	SET @Not_MinWage = 0;
	SET @min_wage_amt = 0;
	SET @ecola_amt = 0;
	
	SELECT `min_wage_amt`, `ecola_amt` 
	INTO @min_wage_amt, @ecola_amt
	FROM ww_payroll_location WHERE `payroll_location_id` = @nPayLocation AND `deleted` = 0;
	
	IF @min_wage_amt >= @DailySalary THEN
		CALL sp_payroll_get_ecola(puserid, periodid, @payroll_date, @ecola_amt, @period_processing_type_id);
		SET @Not_MinWage = 1;
	END IF;
	-- compute/update amount = base_on_earning
	SET @cur_tran_id = 0;
	SELECT `id` INTO @cur_tran_id
	FROM ww_payroll_current_transaction WHERE AES_DECRYPT( `amount`, encryption_key() ) = 'base_on_earning' 
		AND `employee_id` = puserid AND `payroll_date` = @payroll_date AND `deleted` = 0;
	IF @cur_tran_id > 0 THEN
		SET @result = 0.00;
		CALL sp_payroll_get_transaction(puserid,periodid,'1,5',1,1,1,0,@result);
		UPDATE ww_payroll_current_transaction SET `unit_rate` = AES_ENCRYPT( @result, encryption_key() ), `amount` = AES_ENCRYPT( @result, encryption_key() )
			WHERE `id` = @cur_tran_id;
	END IF;
	
	-- compute wtax
	-- Based on Tax Table
	IF @Not_MinWage = 0 THEN
		IF @nTax_mode = 1 THEN
			CALL sp_payroll_get_tax_table( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTaxcode );
		-- Annualized
		ELSEIF @nTax_mode = 2 THEN
			 CALL sp_payroll_get_tax_annualize( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTaxcode, @nRemain );
		END IF;
		/*
		-- Manual
		elseif @nTax_mode = 3 THEN	
		
		-- Cummulative
		elseif @nTax_mode = 4 THEN
		
		else
		
		end if;
		*/
	END IF;
	-- compute netpay
	CALL sp_payroll_get_netpay( periodid, puserid, @payroll_date, @period_processing_type_id ) ;
	
	UPDATE ww_payroll_period SET `period_status_id` = 2 WHERE payroll_period_id = periodid ;
	COMMIT;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_final_pay_bonus` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_final_pay_bonus` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_final_pay_bonus`( 
	IN puserid INT(11),
	IN periodid INT(11),
	in dtResigned date,
	IN paydate DATE,
	IN processing_type_id INT(11) 
    )
BEGIN
	SET @NTax_bonus = 0.00;
	SET @nNonTax = 0.00;
	SET @max_rule = 0;
	-- get ytd bonus
	SET @ytd_bonus = 0;
	SELECT sum(AES_DECRYPT( ytd, encryption_key() )) INTO @ytd_bonus
	FROM ww_payroll_closed_summary WHERE user_id = puserid AND `type` = 'C' AND deleted = 0 AND summary_code = 'BONUS';
	
	-- get current bonus
	SET @current_bonus = 0;
	SELECT sum(AES_DECRYPT( amount, encryption_key() )) INTO @current_bonus
	FROM ww_payroll_current_transaction pct
	LEFT JOIN ww_payroll_transaction_class ptc ON pct.`transaction_class_id` = ptc.`transaction_class_id`
	WHERE pct.employee_id = puserid AND pct.payroll_date = paydate 
		AND pct.deleted = 0 AND pct.on_hold = 0 AND ptc.`transaction_class_code` = 'BONUS';
	
	-- sum ytd and current
	SET @ytd_bonus = @ytd_bonus + @current_bonus;	
	
	-- get prorated bonus
	SET @nBonus = 0;
	SET @Tax_Bonus = 0;
	CALL sp_payroll_get_bonus_prorated( puserid, dtResigned, @nBonus);
	IF (@nBonus > 0) THEN
		IF @max_rule = 1 THEN
			IF @ytd_bonus >= get_max_bonus() THEN
				SET @Tax_Bonus = @nBonus;
				SET @NTax_Bonus = 0;
			ELSEIF @ytd_bonus + @nBonus > get_max_bonus() THEN
				SET @NTax_bonus = get_max_bonus() - @ytd_bonus ;
				SET @Tax_Bonus = @nBonus - @NTax_bonus;
				SET @ytd_bonus = @ytd_bonus + @NTax_bonus;
			ELSE
				SET @NTax_bonus = @nBonus;
				SET @Tax_Bonus = 0;
				SET @ytd_bonus = @ytd_bonus + @NTax_bonus;
			END IF;
		ELSE
			SET @Tax_bonus = 0;
			SET @NTax_Bonus = @nBonus;
		END IF;
		
		
		SET @qty = 1.00;
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SET @bonus_id = 0;
		
		IF @Tax_Bonus != 0 THEN
			SELECT `transaction_code`, `transaction_id` , `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_code =  '13TH MONTH PAY NT';
			
			CALL sp_payroll_bonus_insert( puserid, periodid, paydate, processing_type_id, @tran_id, @tran_class_id, @tran_code, @qty, @Tax_Bonus, @tran_type_id, @bonus_id, 'Bonus Taxable' );
		END IF;
		IF @NTax_Bonus != 0 THEN 
			SELECT `transaction_code`, `transaction_id` , `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_code =  '13THMNT_NT';
			
			CALL sp_payroll_bonus_insert( puserid, periodid, paydate, processing_type_id, @tran_id, @tran_class_id, @tran_code, @qty, @NTax_Bonus, @tran_type_id, @bonus_id, 'Bonus Non-Taxable' );
		END IF;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_final_pay_last_period` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_final_pay_last_period` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_final_pay_last_period`(
	IN puserid INT(11),
	IN nCompany INT(11),
	IN nHourlyRate DECIMAL(12,2),
	IN dtResigned DATE,
	IN periodid INT(11),
	IN dtPay DATE,
	IN processing_type_id INT(11)   
    )
BEGIN
	-- INSERT INTO `logtable` (`log`) VALUES (CONCAT(dtResigned,' ',nHourlyRate,' ',nCompany));
	-- get total hours render
	SET @nSalary = 0;
	SET @nQuantity = 0;
	SELECT ROUND(( SUM(hrs_actual) * nHourlyRate ),2), sum(hrs_actual) INTO @nSalary, @nQuantity
	FROM ww_time_record_summary s
	LEFT JOIN ww_payroll_period pp ON s.payroll_date = pp.payroll_date
	LEFT JOIN ww_time_period t ON pp.payroll_date = t.payroll_date
	WHERE t.deleted = 0 AND s.deleted = 0 AND
		dtResigned BETWEEN t.date_from AND t.date_to AND
		s.user_id = puserid AND
		t.company_id = nCompany and
		pp.payroll_period_id = periodid;
	
	IF @nSalary > 0 THEN
		CALL sp_payroll_insert('SALARY', puserid, periodid, processing_type_id, dtPay, @nQuantity, nHourlyRate, @nSalary, 1, '',0,'Final Pay' );	
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_final_pay_leave_conversion` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_final_pay_leave_conversion` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_final_pay_leave_conversion`(
	IN nUserID INT(11),
	IN nPeriodID INT(11),
	IN nCompID INT(11),	
	IN dtPay DATE,
	IN dtRes DATE,
	IN nDailySalary DECIMAL(12,2),
	IN nEmpTypeID INT(11),
	IN nProcTypeID INT(11)
    )
BEGIN
	SET @nontax_leave_id = 0;
	SET @taxable_leave_id = 0;
	SET @convertible = 0;
	SET @nontax = 0;
	SET @taxable = 0;
	set @carryover = 0;
	SET @forfeited = 0;
	SET @balance = 0;
	SET @year = '';
	SET @form_id = 0;
	SET @form_code = '';
	
	SELECT 224, 225,tfb.`form_code`, 
		tfb.`previous` + tfb.`current` - ( tfb.`used` + tfb.`used_insert` + tfb.`forfeited`),
		YEAR(dtRes), tfb.form_id
	INTO @nontax_leave_id, @taxable_leave_id,@form_code, @balance,
		@year, @form_id
	FROM ww_time_form_balance tfb
	WHERE tfb.`deleted` = 0
		AND tfb.`year` = YEAR(dtRes)
		AND tfb.user_id = nUserID
		and (tfb.form_code = 'LIP' OR tfb.form_code = 'SIL');
	
	IF @balance > 0 THEN
		-- INSERT TRANSACTION 
		-- TAXABLE
		IF @balance > 0 THEN
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SET @tran_type_id = 0;
			SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_id = @nontax_leave_id;
			
			INSERT INTO `ww_payroll_current_transaction`
				    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
				     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
				     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
				     `created_by`, `deleted`)
			SELECT nPeriodID, nProcTypeID, dtPay, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT( @balance, encryption_key() ), 
			     AES_ENCRYPT( ROUND( nDailySalary, 2 ), encryption_key() ) ,
			     AES_ENCRYPT( ROUND( (@balance * nDailySalary), 2 ), encryption_key() ),
			     @tran_type_id, 0,'leave_conversion',0,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = nUserID;
		END IF;
		UPDATE ww_time_form_balance SET paid_unit = @balance WHERE user_id = nUserID AND form_id = @form_id AND `year` = @year;
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_final_pay_overtime` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_final_pay_overtime` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_final_pay_overtime`(
	IN puserid INT(11),
	in dtResigned Date,
	IN paydate DATE,	
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE tran_code VARCHAR(32);
	DECLARE tran_id INT(11);
	DECLARE tran_class_id INT(11);
	DECLARE ot_rate DECIMAL(5,2);
	DECLARE qty DECIMAL(5,2);
	DECLARE ot_rate_amount DECIMAL(5,2);
	DECLARE employment_type VARCHAR(32);
	DECLARE tran_type_id INT(11);
	DECLARE rec_id INT(11);
	
	DECLARE overtime CURSOR FOR 
		SELECT p.`transaction_id`, t.`transaction_class_id`, p.`transaction_code`, r.`overtime_rate`, ra.`overtime_amount`, IF(up.employment_type_id = 5,'supervisor','') AS employee_type, SUM( p.`quantity` ), t.`transaction_type_id`,p.`record_id`
		FROM ww_time_record_process p
		LEFT JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		LEFT JOIN ww_partners up ON u.`user_id` = up.`user_id`
		LEFT JOIN ww_payroll_partners pp ON pp.`user_id` = u.`user_id`
		LEFT JOIN ww_payroll_overtime_rates r ON p.`transaction_code` = r.`overtime_code` AND u.`company_id` = r.`company_id` AND r.deleted = 0
		LEFT JOIN ww_payroll_overtime_rates_amount ra ON p.`transaction_code` = ra.`overtime_code` AND ra.deleted = 0 AND u.`company_id` = ra.`company_id` AND pp.`location_id` = ra.`overtime_location_id`
		LEFT JOIN ww_payroll_transaction t ON p.`transaction_id` = t.`transaction_id`
		LEFT JOIN ww_time_period tp ON tp.period_id = p.time_period_id
		WHERE r.`deleted` = 0 AND p.`deleted` = 0 AND p.`latefile` = 0 AND tp.`deleted` = 0
			AND p.`user_id` = puserid AND p.`payroll_date` = paydate AND dtResigned BETWEEN tp.`date_from` AND tp.`date_to`
		GROUP BY p.`transaction_code`;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	-- select overtime;
	
	OPEN overtime;
	REPEAT
		FETCH overtime INTO tran_id, tran_class_id, tran_code, ot_rate, ot_rate_amount, employment_type, qty, tran_type_id, rec_id ;
		
		IF NOT done THEN
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, tran_id, tran_class_id,
			     tran_code, AES_ENCRYPT( qty, encryption_key() ), 
			     CASE
				WHEN payroll_rate_type_id = 2 AND employment_type != 'supervisor' THEN AES_ENCRYPT( ROUND( ( ( (AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) / 8 ) * ot_rate ),2), encryption_key() ) 
				WHEN payroll_rate_type_id = 2 AND employment_type = 'supervisor' THEN AES_ENCRYPT( ROUND(ot_rate_amount,2), encryption_key() ) 
				WHEN payroll_rate_type_id = 6 THEN AES_ENCRYPT( ROUND( ( (AES_DECRYPT(`salary`, encryption_key()) / 8 ) * ot_rate ),2), encryption_key() ) 
				ELSE 0 
			     END,
			     CASE
				WHEN payroll_rate_type_id = 2 AND employment_type != 'supervisor' THEN AES_ENCRYPT( ROUND( ( qty * ( ( ( ( AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ) * ot_rate ) ), 2 ), encryption_key() )
				WHEN payroll_rate_type_id = 2 AND employment_type = 'supervisor' THEN AES_ENCRYPT( ROUND((qty * ot_rate_amount),2), encryption_key() ) 
				WHEN payroll_rate_type_id = 6 THEN AES_ENCRYPT( ROUND( ( qty * ( (AES_DECRYPT(`salary`, encryption_key()) / 8 ) * ot_rate ) ),2), encryption_key() ) 
				ELSE 0
			     END,
			     tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
	UNTIL done END REPEAT;
    
	CLOSE overtime;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_final_pay_overtime_lf` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_final_pay_overtime_lf` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_final_pay_overtime_lf`(
	IN puserid INT(11),
	IN dtResigned DATE,
	iN paydate DATE,
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE tran_code VARCHAR(32);
	DECLARE ot_rate DECIMAL(3,2);
	DECLARE qty DECIMAL(3,2);
	DECLARE ot_rate_amount DECIMAL(5,2);
	DECLARE employment_type VARCHAR(32);	
	DECLARE tran_type_id INT(11);
	DECLARE rec_id INT(11);
	
	DECLARE overtime CURSOR FOR 
		SELECT p.`transaction_code`, r.`overtime_rate`, ra.`overtime_amount`, IF(up.employment_type_id = 5,'supervisor','') AS employee_type, SUM(p.`quantity`), t.`transaction_type_id`,p.`record_id`
		FROM ww_time_record_process p
		LEFT JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		LEFT JOIN ww_partners up ON u.`user_id` = up.`user_id`
		LEFT JOIN ww_payroll_partners pp ON pp.`user_id` = u.`user_id`	
		LEFT JOIN ww_payroll_overtime_rates r ON p.`transaction_code` = CONCAT(r.`overtime_code`,'_ADJ') AND u.`company_id` = r.`company_id` AND r.deleted = 0	
		LEFT JOIN ww_payroll_overtime_rates_amount ra ON p.`transaction_code` = ra.`overtime_code` AND ra.deleted = 0 AND u.`company_id` = ra.`company_id` AND pp.`location_id` = ra.`overtime_location_id`
		LEFT JOIN ww_payroll_transaction t ON p.`transaction_id` = t.`transaction_id`
		LEFT JOIN ww_time_period tp ON tp.period_id = p.time_period_id
		WHERE r.`deleted` = 0 AND p.`deleted` = 0 AND tp.deleted = 0
			AND p.`payroll_date` = paydate 
			AND dtResigned BETWEEN tp.`date_from` AND tp.`date_to`
			AND p.`latefile` = 1 AND p.`user_id` = puserid
		GROUP BY p.`transaction_code`;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	-- select overtime;
	
	OPEN overtime;
	REPEAT
		FETCH overtime INTO tran_code, ot_rate, ot_rate_amount, employment_type, qty, tran_type_id, rec_id ;
		
		IF NOT done THEN
			
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_code = CONCAT(tran_code,'_LF');
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT( qty, encryption_key() ), 
			     CASE
				WHEN payroll_rate_type_id = 2 AND employment_type != 'supervisor' THEN AES_ENCRYPT( ROUND( ( ( (AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) / 8 ) * ot_rate ),2), encryption_key() ) 
				WHEN payroll_rate_type_id = 2 AND employment_type = 'supervisor' THEN AES_ENCRYPT( ROUND(ot_rate_amount,2), encryption_key() ) 
				WHEN payroll_rate_type_id = 6 THEN AES_ENCRYPT( ROUND( ( (AES_DECRYPT(`salary`, encryption_key()) / 8 ) * ot_rate ),2), encryption_key() ) 
				ELSE 0 
			     END,
			     CASE
				WHEN payroll_rate_type_id = 2 AND employment_type != 'supervisor' THEN AES_ENCRYPT( ROUND( ( qty * ( ( ( ( AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ) * ot_rate ) ), 2 ), encryption_key() )
				WHEN payroll_rate_type_id = 2 AND employment_type = 'supervisor' THEN AES_ENCRYPT( ROUND((qty * ot_rate_amount),2), encryption_key() ) 
				WHEN payroll_rate_type_id = 6 THEN AES_ENCRYPT( ROUND( ( qty * ( (AES_DECRYPT(`salary`, encryption_key()) / 8 ) * ot_rate ) ),2), encryption_key() ) 
				ELSE 0
			     END,
			     tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
	UNTIL done END REPEAT;
    
	CLOSE overtime;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_absences` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_absences` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_absences`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @absent = 0;
	
	SELECT  SUM(`quantity`) INTO @absent
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate
		AND `transaction_code` = 'ABSENCES' AND latefile = 0 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @absent > 0 THEN 
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT `transaction_code`, `transaction_id` , `transaction_type_id`, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'ABSENCES';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT(@absent, encryption_key()), 
		     AES_ENCRYPT( ROUND( (AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8, 2), encryption_key()) ,
		     AES_ENCRYPT( ROUND( ( @absent * ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) /8 ) ),2), encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_absences_adj` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_absences_adj` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_absences_adj`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @absent = 0;
	
	SELECT  SUM(`quantity`) INTO @absent
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate
		AND `transaction_code` = 'ABSENCES_ADJ' AND latefile = 1 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @absent != 0 THEN 
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'ABSENCES_ADJ';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT(@absent, encryption_key()), 
		     AES_ENCRYPT( ROUND( (AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ,2), encryption_key()) ,
		     AES_ENCRYPT( ROUND( ( @absent * ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ) ),2), encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_absences_lf` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_absences_lf` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_absences_lf`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @absent = 0;
	
	SELECT  SUM(`quantity`) INTO @absent
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate
		AND `transaction_code` = 'ABSENCES' AND latefile = 1 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @absent > 0 THEN 
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = CONCAT('ABSENCES','_LF');
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT(@absent, encryption_key()), 
		     AES_ENCRYPT( ROUND( (AES_DECRYPT(salary, encryption_key()) / ( 313 /12 ) ),2), encryption_key()) ,
		     AES_ENCRYPT( ROUND( ( @absent * ( AES_DECRYPT(salary, encryption_key()) / ( 313 /12 ) ) ),2), encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_batch` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_batch` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_batch`(
		IN puserid INT(11), 
		IN periodid INT(11), 
		IN paydate DATE,
		IN processing_type_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE rec_id INT(11);
	DECLARE amount DECIMAL(12,2);
	DECLARE quantity DECIMAL(12,2);
	DECLARE unit_rate DECIMAL(12,2);
	DECLARE tran_id INT(11);
	DECLARE tran_class_id INT(11);
	DECLARE tran_type_id INT(11);
	DECLARE tran_code VARCHAR(32);
	
	DECLARE batch CURSOR FOR
		SELECT b.`batch_entry_id`, aes_decrypt(e.`amount`,encryption_key()),aes_decrypt(e.`quantity`,encryption_key())
			, aes_decrypt(e.`unit_rate`,encryption_key()), b.`transaction_id`
			, t.`transaction_class_id`, t.`transaction_type_id`, t.`transaction_code`
		FROM ww_payroll_entry_batch b
		LEFT JOIN ww_payroll_entry_batch_employee e ON b.`batch_entry_id` = e.`batch_entry_id`
		LEFT JOIN ww_payroll_transaction t ON t.`transaction_id` = b.`transaction_id`
		WHERE b.`deleted` = 0 AND e.deleted = 0 AND e.`employee_id` = puserid 
			AND b.payroll_date = paydate;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	
	OPEN batch;
	REPEAT
		FETCH batch INTO rec_id, amount, quantity, unit_rate, tran_id, tran_class_id, tran_type_id, tran_code;
		
		-- INSERT INTO `logtablecheck` (`log`) VALUES (puseridconcat(puserid,' - ',tran_id));
		
		IF NOT done THEN
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, tran_id, tran_class_id,
			     tran_code, AES_ENCRYPT( quantity, encryption_key() ), 
			     AES_ENCRYPT( ROUND( unit_rate, 2 ), encryption_key() ) ,
			     AES_ENCRYPT( ROUND( (quantity * unit_rate), 2 ), encryption_key() ),
			     tran_type_id, 0,'batch_entry',rec_id,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
			
		END IF;
			
	UNTIL done END REPEAT;
    
	CLOSE batch;
	-- 
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_bonus` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_bonus` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_bonus`(
	IN puserid INT(11),
	IN periodid INT(11),
	IN paydate DATE,
	IN sal_amount DECIMAL(12,2),
	IN processing_type_id INT(11) 
    )
BEGIN
	SET @NTax_bonus = 0.00;
	SET @nNonTax = 0.00;
	SET @max_rule = 0;
	-- get ytd bonus
	SET @ytd_bonus = 0;
	SELECT AES_DECRYPT( ytd, encryption_key() ) INTO @ytd_bonus
	FROM ww_payroll_closed_summary WHERE user_id = puserid AND `type` = 'C' AND deleted = 0 AND summary_code = 'BONUS' AND `year` = YEAR(paydate);
	
	-- get current bonus
	SET @current_bonus = 0;
	SELECT AES_DECRYPT( amount, encryption_key() ) INTO @current_bonus
	FROM ww_payroll_current_transaction pct
	LEFT JOIN ww_payroll_transaction_class ptc ON pct.`transaction_class_id` = ptc.`transaction_class_id`
	WHERE pct.employee_id = puserid AND pct.payroll_date = paydate 
		AND pct.deleted = 0 AND pct.on_hold = 0 AND ptc.`transaction_class_code` = 'BONUS';
	
	-- sum ytd and current
	SET @ytd_bonus = @ytd_bonus + @current_bonus;	
	
	SET @bonus_id = 0;
	SET @bonus_tran_id = 0;
	SET @bonus_tax_tran_id = 0;
	SET @dtFrom = '0000-00-00';
	SET @dtTo = '0000-00-00';
	SET @pDate = '0000-00-00';
	SET @tran_method_id = 0;
	SET @period = 0;
	SET @amount = 0.00;
	SET @max_rule = 0;
	SET @dtStart = '0000-00-00';
	SET @dtEnd = '0000-00-00';
	SET @current_bonus = 0.00;
	SET @salary = 0;
	-- get bonus setup
	SELECT b.`bonus_id`, b.`bonus_transaction_id`,b.`taxable_bonus_transaction_id`, b.`date_from`, b.`date_to`, b.`payroll_date`, 
		b.`transaction_method_id`, b.`period`, AES_DECRYPT( e.`amount`, encryption_key() ), b.`apply_maxbonus_rule`
	INTO @bonus_id, @bonus_tran_id, @bonus_tax_tran_id, @dtFrom, @dtTo, @pDate, @tran_method_id, @period, @amount, @max_rule
	FROM ww_payroll_bonus b
	INNER JOIN ww_payroll_bonus_employee e ON b.`bonus_id` = e.`bonus_id`
	WHERE e.`employee_id` = puserid AND b.`payroll_date` = paydate;
	
	-- Earnings (%)
	IF @tran_method_id = 1 THEN
		SET @current_bonus = 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;
	-- Period Salary (%)
	ELSEIF @tran_method_id = 2 THEN
		CALL sp_payroll_get_bonus_period( puserid, @salary, @eff_date, @res_date);
		SET @current_bonus = ( @salary * @amount ) / 100 ;
	-- Fixed
	ELSEIF @tran_method_id = 3 THEN
		SET @current_bonus = @amount;
	-- 13th Month Pay with deduction
	ELSEIF @tran_method_id = 4 THEN
		CALL sp_payroll_get_bonus_period( puserid, @salary, @eff_date, @res_date);
		IF @eff_date > @dtFrom THEN
			SET @dtStart = @eff_date;
		ELSE
			SET @dtStart = @dtFrom;
		END IF;
		
		IF @res_date < @dtTo THEN
			SET @dtEnd = @res_date;
		ELSE
			SET @dtEnd = @dtTo;
		END IF;
		
		SET @nDiv = get_bonus_divisor(@dtStart, @dtEnd);
		
		IF @nDiv > 12 THEN
			SET @nDiv = 12;
		END IF;
		SET @closed_attnd_ded = 0;
		
		SELECT IFNULL( ROUND( SUM( AES_DECRYPT( amount, encryption_key() ) ), 2 ), 0.00)
		INTO @closed_attnd_ded
		FROM ww_payroll_closed_transaction
		WHERE transaction_code IN ('ABSSENCES','DEDUCTION_LATE','DEDUCTION_UNDERTIME')
			AND employee_id = puserid AND payroll_date BETWEEN @dtFrom AND @dtTo AND deleted = 0;
		
		SET @current_attnd_ded = 0;
		SELECT IFNULL( ROUND( SUM( AES_DECRYPT( amount, encryption_key() ) ), 2 ), 0.00)
		INTO @current_attnd_ded
		FROM ww_payroll_current_transaction
		WHERE transaction_code IN ('ABSSENCES','DEDUCTION_LATE','DEDUCTION_UNDERTIME')
			AND employee_id = puserid AND payroll_date BETWEEN @dtFrom AND @dtTo AND deleted = 0 AND on_hold = 0;
		SET @tot_attnd_ded = 0;
		SET @tot_attnd_ded = @current_attnd_ded + @closed_attnd_ded;
		SET @current_bonus = ( ( @salary * @nDiv ) - @tot_attnd_ded );
		
	-- Actual Salary (%)
	ELSEIF @tran_method_id = 5 THEN
		CALL sp_payroll_get_bonus_period( puserid, @salary, @eff_date, @res_date);
		SET @current_bonus = @salary;
	-- 13th month pay without deduction for abcenses
	ELSEIF @tran_method_id = 6 THEN
		SET @nDeduct = 0;
		
		CALL sp_payroll_get_bonus_period( puserid, @salary, @eff_date, @res_date);
		
		IF @eff_date < @dtFrom THEN
			SET @dtStart = @dtFrom;
		ELSE
			SET @dtStart = @eff_date;
			
			IF DAY(@eff_date) > 1 THEN
				SET @nDeduct = 1;
			END IF;			
		END IF;
		
		IF @res_date < @dtTo AND @res_date != '0000-00-00' THEN
			SET @dtEnd = @res_date;
		ELSE
			SET @dtEnd = @dtTo;
		END IF;
		
		SET @nDiv = get_bonus_divisor(@dtStart, @dtEnd) - @nDeduct;
		
		IF @nDiv > 12 THEN
			SET @nDiv = 12;
		END IF;
		
		SET @current_bonus = ((@salary / 12) * @nDiv);
			
	END IF;
	SET @max_rule = 1;
	IF @max_rule = 1 THEN
		IF @ytd_bonus >= get_max_bonus() THEN
			SET @Tax_Bonus = @current_bonus;
			SET @NTax_Bonus = 0;
		ELSEIF @ytd_bonus + @current_bonus > get_max_bonus() THEN
			SET @NTax_bonus = get_max_bonus() - @ytd_bonus ;
			SET @Tax_Bonus = @current_bonus - @NTax_bonus;
			SET @ytd_bonus = @ytd_bonus + @NTax_bonus;
		ELSE
			SET @NTax_bonus = @current_bonus;
			SET @Tax_Bonus = 0;
			SET @ytd_bonus = @ytd_bonus + @NTax_bonus;
		END IF;
	ELSE
		SET @Tax_bonus = 0;
		SET @NTax_Bonus = @current_bonus;
	END IF;
	
	IF paydate = @pDate THEN
		SET @qty = 1.00;
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		
		IF @Tax_Bonus != 0 THEN
			SELECT `transaction_code`, `transaction_id` , `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_id =  @bonus_tax_tran_id;
			
			CALL sp_payroll_bonus_insert( puserid, periodid, paydate, processing_type_id, @tran_id, @tran_class_id, @tran_code, @qty, @Tax_Bonus, @tran_type_id, @bonus_id, 'Bonus Taxable' );
			UPDATE ww_payroll_period SET `bonus_tag` = 1 WHERE payroll_period_id = periodid ;
		END IF;
		IF @NTax_Bonus != 0 THEN 
			SELECT `transaction_code`, `transaction_id` , `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_id =  @bonus_tran_id;
			
			CALL sp_payroll_bonus_insert( puserid, periodid, paydate, processing_type_id, @tran_id, @tran_class_id, @tran_code, @qty, @NTax_Bonus, @tran_type_id, @bonus_id, 'Bonus Non-Taxable' );
			UPDATE ww_payroll_period SET `bonus_tag` = 1 WHERE payroll_period_id = periodid ;
		END IF;
	END IF;
	
	-- SELECT @Tax_Bonus;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_bonus_period` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_bonus_period` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_bonus_period`(
	IN puserid INT(11),
	OUT salary DECIMAL(12,2),
	OUT eff_date DATE,
	OUT resigned_date DATE
    )
BEGIN
	SELECT CASE a.`payroll_schedule_id` 
		WHEN 4 THEN IFNULL( AES_DECRYPT( a.`salary`, encryption_key() ), 0.00)
		WHEN 5 THEN IFNULL( AES_DECRYPT( a.`salary`, encryption_key() ), 0.00) * 2
		WHEN 6 THEN IFNULL( AES_DECRYPT( a.`salary`, encryption_key() ), 0.00) * ( a.`total_year_days` / 12 )
		ELSE IFNULL( AES_DECRYPT( a.`salary`, encryption_key() ), 0.00) END, 
		b.`effectivity_date`, b.`resigned_date`
	INTO salary, eff_date, resigned_date
	FROM ww_payroll_partners a, ww_partners b
	WHERE a.`user_id` = b.`user_id`
		AND a.`user_id` = puserid;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_bonus_prorated` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_bonus_prorated` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_bonus_prorated`( 
	IN nUserID int(11), 
	IN dtResigned date, 
	out nBonus decimal(18,2))
BEGIN
	SET @nBonusClosed = 0;
	SET @nBonusCurrent = 0;
	
	select ROUND( IFNULL(SUM(AES_DECRYPT(amount, encryption_key()) ) ,0),2) / 12 into @nBonusClosed
	from ww_payroll_closed_transaction 
	WHERE deleted = 0 AND transaction_code = 'SALARY'
	-- where deleted = 0 and transaction_code in ('SALARY','MPCCMPC','RICEALLOW','LAUNDRYALLOW','MEDICINEALLOW')
		AND employee_id = nUserID
		and year(payroll_date) = year(dtResigned);
	SELECT ROUND( IFNULL(SUM(AES_DECRYPT(amount, encryption_key()) ) ,0),2) / 12 INTO @nBonusCurrent
	FROM ww_payroll_current_transaction 
	WHERE deleted = 0 AND transaction_code = 'SALARY'
	-- WHERE deleted = 0 AND transaction_code in ('SALARY','MPCCMPC','RICEALLOW','LAUNDRYALLOW','MEDICINEALLOW')
		AND employee_id = nUserID
		AND YEAR(payroll_date) = YEAR(dtResigned);
		
	set nBonus = @nBonusClosed + @nBonusCurrent;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_ecola` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_ecola` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_ecola`(
	in puserid int(11), 
	in periodid int(11), 
	in paydate date, 
	in cola_amt decimal(12,2),
	in processing_type_id int(11)
    )
BEGIN
	SET @tran_code = '';
	SET @tran_id = 0;
	SET @tran_class_id = 0;
	SET @tran_type_id = 0;
	SELECT `transaction_code`, `transaction_id` , `transaction_type_id`, `transaction_class_id`
	INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
	FROM ww_payroll_transaction WHERE transaction_code = 'ECOLA';
	
	INSERT INTO `ww_payroll_current_transaction`
	    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
	     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
	     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
	     `created_by`, `deleted`)
	SELECT periodid, processing_type_id, paydate, t.`user_id`, @tran_id, @tran_class_id,
	     @tran_code, AES_ENCRYPT(SUM(t.`hrs_actual`), encryption_key()), 
	     AES_ENCRYPT( cola_amt, encryption_key() ) ,
	     AES_ENCRYPT( round ( ( ( SUM(t.`hrs_actual`) / 8 ) * cola_amt),2 ), encryption_key() ) ,
	     @tran_type_id, 0,'ECOLA',0,0,'',NOW(),0,0
	FROM ww_payroll_partners p, ww_time_record_summary t
	WHERE p.`user_id` = t.`user_id` AND 
		p.`user_id` = puserid AND
		t.`payroll_date` = paydate
	GROUP BY t.`user_id`, t.`payroll_date`;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_hdmf_contribution` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_hdmf_contribution` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_hdmf_contribution`(
	IN periodid INT(11), 
	IN paydate DATE,
	IN pay_sched_id INT(11),
	IN processing_type_id INT(11) ,
	IN nweek INT(1),
	IN puserid INT(11),
	IN salary DECIMAL(12,2),
	IN hdmf_mode INT(11),
	IN hdmf_amount decimal(12,2),
	IN hdmf_week VARCHAR(11)
	)
BEGIN
	SET @employee_id = 0;
	SET @cnt_week = '';
	SET @salary = 0.00;
	
	SET @eeshare = 0.00;
	SET @ershare = 0.00;
	
	SET @prev_eeshare = 0.00;
	SET @prev_ershare = 0.00;
	
	SET @prev_salary = 0.00;
	SET @earnings = 0.00;
	SET @bracket = 0.00;
		
	-- get assing salary or basic rate
	SELECT `user_id`, LENGTH(REPLACE(`hdmf_week`,',','')) INTO @employee_id, @cnt_week
	FROM ww_payroll_partners
	WHERE `user_id` = puserid AND FIND_IN_SET(nweek,`hdmf_week`) AND `payroll_schedule_id` = pay_sched_id;
	
	IF @employee_id > 0 THEN
		-- check previous payment
		SELECT MAX(CASE WHEN (`c`.`transaction_code` = 'HDMF_EMP') THEN ROUND(AES_DECRYPT(`c`.`amount`,`encryption_key`()),2) END) AS `prev_eeshare`,MAX(CASE WHEN (`c`.`transaction_code` = 'HDMF_COM') THEN ROUND(AES_DECRYPT(`c`.`amount`,`encryption_key`()),2) END) AS `prev_ershare` INTO @prev_eeshare, @prev_ershare
		FROM ww_payroll_closed_transaction c
		WHERE c.`employee_id` = @employee_id AND (MONTH(c.`payroll_date`) = MONTH(paydate) AND YEAR(c.`payroll_date`) = YEAR(MONTH(paydate)))
			AND c.`transaction_code` IN ('HDMF_EMP','HDMF_COM');			
					
		/*SELECT SUM(`employee`), SUM(`company`) INTO @prev_eeshare, @prev_ershare
		FROM ww_payroll_partners_contribution c
		LEFT JOIN ww_payroll_transaction t ON c.`transaction_id` = t.`transaction_id`
		WHERE c.`user_id` = @employee_id AND MONTH(c.`payroll_date`) = MONTH(paydate) 
			AND t.`transaction_code` = 'HDMF_EMP';*/
		
		IF @cnt_week > 1 THEN
		    IF hdmf_mode = 1 THEN
			    -- previous salary
			    SELECT ROUND(SUM(AES_DECRYPT(`amount`, encryption_key())),2) INTO @prev_salary 
			    FROM ww_payroll_closed_transaction WHERE (MONTH(`payroll_date`) = MONTH(paydate) AND YEAR(`payroll_date`) = YEAR(paydate))
				AND `transaction_code` = 'SALARY' AND `deleted` = 0 AND `employee_id` = @employee_id;
				
		    ELSEIF hdmf_mode = 5 THEN
			    -- previous actual earning
			    SET @result = 0;
			    SET @prev_actual_earning = 0.00;
			    CALL sp_payroll_get_transaction(@employee_id,periodid,'1,5',1,0,0,3,@result);
			    SET @prev_actual_earning = @result;				
	            END IF;
	              
		END IF;
		
		-- monthly
		IF pay_sched_id = 4 THEN
		    
		    
		    if hdmf_mode = 3 then
			-- manual
			set @eeshare = hdmf_amount;
		    else 
			-- default / actual
			SET @eeshare = 100.00; 
		    end if;
		    SET @ershare = 100.00;
			
		-- semi-monthly
		ELSEIF pay_sched_id = 5 THEN
		    
		    -- default
		    IF hdmf_mode = 1 THEN
			
			SET @eeshare = 100 / @cnt_week;
			SET @ershare = @eeshare;
			
			IF @prev_salary > 0 THEN
				SET @eeshare = 100.00 - IFNULL(@prev_eeshare,0.00);
				SET @ershare = 100.00 - IFNULL(@prev_ershare,0.00);
				
			END IF;
			
		    -- actual
		    ELSEIF hdmf_mode = 5 THEN
			
			-- get actual earning
			SET @result = 0;
			CALL sp_payroll_get_transaction(@employee_id,periodid,'1,2,5',1,1,1,0,@result);
			SET @earnings = @result;
			
			SET @bracket = @earnings * 0.02;
			
			IF @bracket >= 100 THEN
				SET @eeshare = 100.00;
				SET @ershare = 100.00;
			ELSE
				SET @eeshare = @bracket;
				SET @ershare = @bracket;
				
			END IF;
			
			IF (@prev_eeshare + @eeshare) >= 100 THEN
				SET @eeshare = 0;
				SET @ershare = 0;
			ELSE
				SET @eeshare = 100.00 - IFNULL(@prev_eeshare,0.00);
				SET @ershare = 100.00 - IFNULL(@prev_ershare,0.00);
			END IF;
		    elseif hdmf_mode = 3 then
			set @eeshare = hdmf_amount / @cnt_week;	
			SET @ershare = 100.00;
		    ELSE
			SET @eeshare = 0;
			SET @ershare = 0;
		    END IF;
		    
		-- weekly
		ELSEIF pay_sched_id = 6 THEN
		    
		    -- default
		    IF hdmf_mode = 1 THEN
			IF @cnt_week > 4 THEN
				SET @cnt_week = 4;
			END IF;
			
			SET @eeshare = 100.00 / @cnt_week;
			SET @ershare = @eeshare;
			
		    -- actual
		    ELSEIF hdmf_mode = 5 THEN
			
			-- get actual earning
			SET @result = 0;
			CALL sp_payroll_get_transaction(@employee_id,periodid,'1,2,5',1,1,1,0,@result);
			SET @earnings = @result;
			
			SET @bracket = @earnings * 0.02;
			
			IF @bracket >= 100 THEN
				SET @eeshare = 100.00;
				SET @ershare = 100.00;
			ELSE
				SET @eeshare = @bracket;
				SET @ershare = @bracket;
				
			END IF;
			
			IF (@prev_eeshare + @eeshare) >= 100 THEN
				IF @prev_eeshare < 100 THEN
					SET @eeshare = 100.00 - @prev_eeshare;
					SET @ershare = 100.00 - @prev_ershare;
				ELSE
					SET @eeshare = 0;
					SET @ershare = 0;
				END IF;
			ELSE
				SET @eeshare = @eeshare;
				SET @ershare = @ershare;
			END IF;
		    ELSEIF hdmf_mode = 3 THEN
			SET @eeshare = hdmf_amount / @cnt_week;	
			SET @ershare = 100.00;
		    ELSE
			SET @eeshare = 0;
			SET @ershare = 0;
			
		    END IF;
		    
		END IF;
		
		if @eeshare > 0 then
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SET @tran_type_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE `transaction_code` = 'HDMF_EMP';
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
			     AES_ENCRYPT( @eeshare, encryption_key()) ,
			     AES_ENCRYPT( @eeshare, encryption_key()), 
			     @tran_type_id, 0,'',0,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		end if;
	
		IF @ershare > 0 THEN
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SET @tran_type_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE `transaction_code` = 'HDMF_COM';
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
			     AES_ENCRYPT( round(@ershare,2), encryption_key()) ,
			     AES_ENCRYPT( round(@ershare,2), encryption_key()), 
			     @tran_type_id, 0,'',0,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
		
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_lates` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_lates` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_lates`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @late = 0;
	
	SELECT  SUM(`quantity`) INTO @late
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate
		AND `transaction_code` = 'DEDUCTION_LATE' AND latefile = 0 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @late > 0 THEN 
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'DEDUCTION_LATE';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT( @late, encryption_key()) , 
		     AES_ENCRYPT( ROUND( ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ),2), encryption_key() ),
		     AES_ENCRYPT( ROUND( ( @late * ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ) ), 2), encryption_key() ),
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_lates_adj` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_lates_adj` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_lates_adj`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @late = 0;
	
	SELECT  SUM(`quantity`) INTO @late
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate
		AND `transaction_code` = 'DEDUCTION_LATE_ADJ' AND latefile = 1 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @late != 0 THEN 
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'DEDUCTION_LATE_ADJ';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT( @late, encryption_key()) , 
		     AES_ENCRYPT( ROUND( ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ),2), encryption_key() ),
		     AES_ENCRYPT( ROUND( ( @late * ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ) ), 2), encryption_key() ),
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_lates_lf` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_lates_lf` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_lates_lf`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @late = 0;
	
	SELECT  SUM(`quantity`) INTO @late
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate
		AND `transaction_code` = 'DEDUCTION_LATE' AND latefile = 1 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @late > 0 THEN 
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = CONCAT('DEDUCTION_LATE','_LF');
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT( @late, encryption_key()) , 
		     AES_ENCRYPT( ROUND( ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ),2), encryption_key() ),
		     AES_ENCRYPT( ROUND( ( @late * ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ) ), 2), encryption_key() ),
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_leave_adj` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_leave_adj` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_leave_adj`(
	IN puserid INT(11),
	IN paydate DATE,
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE tran_code VARCHAR(32);
	DECLARE qty DECIMAL(5,2);
	DECLARE tran_type_id INT(11);
	DECLARE rec_id INT(11);
	
	DECLARE leave_adj CURSOR FOR 
		SELECT p.`transaction_code`, SUM(p.`quantity`), t.`transaction_type_id`,p.`record_id`
		FROM ww_time_record_process p
		LEFT JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		LEFT JOIN ww_payroll_transaction t ON p.`transaction_id` = t.`transaction_id`
		LEFT JOIN ww_time_form f ON CONCAT(f.`form_code`,'_ADJ') = p.`transaction_code`
		WHERE f.`is_leave` = 1 AND p.`deleted` = 0 AND p.`payroll_date` = paydate AND p.`latefile` = 1 AND p.`user_id` = puserid
		GROUP BY p.`transaction_code`;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	-- select overtime;
	
	OPEN leave_adj;
	REPEAT
		FETCH leave_adj INTO tran_code, qty, tran_type_id, rec_id ;
		
		IF NOT done THEN
			
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_code = tran_code;
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT( qty, encryption_key() ), 
			     AES_ENCRYPT( ROUND( ( (AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) / 8 ) ,2), encryption_key() ) ,
			     AES_ENCRYPT( ROUND( qty * ( ( ( ( AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ) ), 2 ), encryption_key() ),
			     tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
	UNTIL done END REPEAT;
    
	CLOSE leave_adj;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_leave_adjustment` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_leave_adjustment` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_leave_adjustment`(
	IN puserid INT(11),
	IN paydate DATE,
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE tran_code VARCHAR(32);
	DECLARE tran_id INT(11);
	DECLARE tran_class_id INT(11);
	DECLARE qty DECIMAL(3,2);
	DECLARE tran_type_id INT(11);
	DECLARE rec_id INT(11);
	
	DECLARE emp_leave CURSOR FOR 
		SELECT p.`transaction_id`, t.`transaction_class_id`, p.`transaction_code`, p.`quantity`, t.`transaction_type_id`,p.`record_id`
		FROM ww_time_record_process p
		LEFT JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		LEFT JOIN ww_payroll_transaction t ON p.`transaction_id` = t.`transaction_id`
		LEFT JOIN ww_payroll_transaction_class c ON c.`transaction_class_id` = t.`transaction_class_id`
		WHERE p.`deleted` = 0 AND p.`payroll_date` = paydate AND p.`latefile` = 0 AND p.`user_id` = puserid
			AND c.`transaction_class_code` = 'LEAVES' AND t.`transaction_code` NOT IN ('LWOP_LF','LWOP');
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	-- select overtime;
	
	OPEN emp_leave;
	myLoop: LOOP
		FETCH emp_leave INTO tran_id, tran_class_id, tran_code, qty, tran_type_id, rec_id ;
		
		
			
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, tran_id, tran_class_id,
		     tran_code, AES_ENCRYPT( qty, encryption_key() ), 
		     AES_ENCRYPT( ROUND( ( (AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) / 8 ),2), encryption_key() ) ,
		     AES_ENCRYPT(  ROUND( ( qty * ( ( ( AES_DECRYPT(`salary`, encryption_key ()) / (total_year_days / 12) ) ) / 8 ) ), 2 ), encryption_key () ),
		     tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	
	END LOOP;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_loan_amortization` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_loan_amortization` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_loan_amortization`(
	in puserid int(11),
	in periodid int(11),
	in paydate date,
	IN processing_type_id INT(11),
	in nweek int(11)
    )
BEGIN
	
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE amort_tran_id INT(11);
	DECLARE payment_mode INT(11);
	DECLARE sys_amort DECIMAL(12,2);
	DECLARE user_amort DECIMAL(12,2);
	DECLARE rec_id INT(11);
	declare status_id int(11);
	
	DECLARE loan CURSOR FOR 
		SELECT 
			l.`partner_loan_id`, l.`payment_mode_id`, 
			AES_DECRYPT( l.`system_amortization`, encryption_key() ),
			AES_DECRYPT( l.`user_amortization`, encryption_key() ),
			pl.`amortization_transid`, l.`loan_status_id`
		FROM ww_payroll_partners_loan l
		INNER JOIN ww_payroll_loan pl ON l.`loan_id` = pl.`loan_id`
		WHERE l.`loan_status_id` IN ( 1, 2 ) AND l.`deleted` = 0 
			AND l.`user_id` = puserid AND l.`start_date` <= paydate AND FIND_IN_SET( nweek,l.`week`);
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	
	OPEN loan;
	REPEAT
		FETCH loan INTO rec_id, payment_mode, sys_amort, user_amort, amort_tran_id, status_id;
		
		IF NOT done THEN
			-- insert transaction of user and user to always system
			if payment_mode in (2,3) then
				
				SET @tran_code = '';
				SET @tran_id = 0;
				SET @tran_class_id = 0;
				SET @tran_type_id = 0;
				SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
				INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
				FROM ww_payroll_transaction WHERE transaction_id = amort_tran_id;
				
				INSERT INTO `ww_payroll_current_transaction`
				    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
				     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
				     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
				     `created_by`, `deleted`)
				SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
				     @tran_code, AES_ENCRYPT( 1.00, encryption_key() ), 
				     AES_ENCRYPT( user_amort, encryption_key() ) ,
				     AES_ENCRYPT( user_amort, encryption_key() ),
				     @tran_type_id, 0,'employee_loan',rec_id,0,'',NOW(),0,0
				FROM ww_payroll_partners 
				WHERE user_id = puserid;
			-- insert transaction system or system to always user
			elseif payment_mode in (1,4) then
			
				SET @tran_code = '';
				SET @tran_id = 0;
				SET @tran_class_id = 0;
				SET @tran_type_id = 0;
				SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
				INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
				FROM ww_payroll_transaction WHERE transaction_id = amort_tran_id;
				
				INSERT INTO `ww_payroll_current_transaction`
				    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
				     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
				     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
				     `created_by`, `deleted`)
				SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
				     @tran_code, AES_ENCRYPT( 1.00, encryption_key() ), 
				     AES_ENCRYPT( sys_amort, encryption_key() ) ,
				     AES_ENCRYPT( sys_amort, encryption_key() ),
				     @tran_type_id, 0,'employee_loan',rec_id,0,'',NOW(),0,0
				FROM ww_payroll_partners 
				WHERE user_id = puserid;
				
			end if;
			
		END IF;
		
		if payment_mode = 3 then
			-- user to always system
			update ww_payroll_partners_loan set `payment_mode_id` = 1 where `partner_loan_id` = rec_id;
		elseif payment_mode = 4 then
			-- system to always user
			UPDATE ww_payroll_partners_loan SET `payment_mode_id` = 2 WHERE `partner_loan_id` = rec_id;
		end if;
		
		if status_id = 1 then
			-- set status to active if entered
			UPDATE ww_payroll_partners_loan SET `loan_status_id` = 2 WHERE `partner_loan_id` = rec_id;
		end if;
		
	UNTIL done END REPEAT;
    
	CLOSE loan;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_loan_interest` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_loan_interest` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_loan_interest`(
	IN puserid INT(11),
	IN periodid INT(11),
	IN paydate DATE,
	IN processing_type_id INT(11),
	IN nweek INT(11)
    )
BEGIN
		
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE interest_tran_id INT(11);
	DECLARE payment_mode INT(11);
	DECLARE sys_amort DECIMAL(12,2);
	DECLARE user_amort DECIMAL(12,2);
	DECLARE rec_id INT(11);
	DECLARE status_id INT(11);
	
	DECLARE loan CURSOR FOR 
		SELECT 
			l.`partner_loan_id`, l.`payment_mode_id`, 
			AES_DECRYPT( l.`system_interest`, encryption_key() ),
			AES_DECRYPT( l.`user_interest`, encryption_key() ),
			pl.`interest_transid`, l.`loan_status_id`
		FROM ww_payroll_partners_loan l
		INNER JOIN ww_payroll_loan pl ON l.`loan_id` = pl.`loan_id`
		WHERE l.`loan_status_id` IN ( 1, 2 ) AND l.`deleted` = 0 
			AND l.`user_id` = puserid AND l.`start_date` <= paydate AND find_in_set( nweek,l.`week`);
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	
	OPEN loan;
	REPEAT
		FETCH loan INTO rec_id, payment_mode, sys_amort, user_amort, interest_tran_id, status_id;
		
		IF NOT done THEN
			-- insert transaction of user and user to always system
			IF payment_mode IN (2,3) THEN
				if user_amort > 0 then
					SET @tran_code = '';
					SET @tran_id = 0;
					SET @tran_class_id = 0;
					SET @tran_type_id = 0;
					SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
					INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
					FROM ww_payroll_transaction WHERE transaction_id = interest_tran_id;
					
					INSERT INTO `ww_payroll_current_transaction`
					    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
					     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
					     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
					     `created_by`, `deleted`)
					SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
					     @tran_code, AES_ENCRYPT( 1.00, encryption_key() ), 
					     AES_ENCRYPT( user_amort, encryption_key() ) ,
					     AES_ENCRYPT( user_amort, encryption_key() ),
					     @tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
					FROM ww_payroll_partners 
					WHERE user_id = puserid;
				end if;
			-- insert transaction system or system to always user
			ELSEIF payment_mode IN (1,4) THEN
				if sys_amort > 0 then
					SET @tran_code = '';
					SET @tran_id = 0;
					SET @tran_class_id = 0;
					SET @tran_type_id = 0;
					SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
					INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
					FROM ww_payroll_transaction WHERE transaction_id = interest_tran_id;
					
					INSERT INTO `ww_payroll_current_transaction`
					    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
					     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
					     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
					     `created_by`, `deleted`)
					SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
					     @tran_code, AES_ENCRYPT( 1.00, encryption_key() ), 
					     AES_ENCRYPT( sys_amort, encryption_key() ) ,
					     AES_ENCRYPT( sys_amort, encryption_key() ),
					     @tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
					FROM ww_payroll_partners 
					WHERE user_id = puserid;
				end if;
			END IF;
			
		END IF;
		
		IF payment_mode = 3 THEN
			-- user to always system
			UPDATE ww_payroll_partners_loan SET `payment_mode_id` = 1 WHERE `partner_loan_id` = rec_id;
		ELSEIF payment_mode = 4 THEN
			-- system to always user
			UPDATE ww_payroll_partners_loan SET `payment_mode_id` = 2 WHERE `partner_loan_id` = rec_id;
		END IF;
		
		IF status_id = 1 THEN
			-- set status to active if entered
			UPDATE ww_payroll_partners_loan SET `loan_status_id` = 2 WHERE `partner_loan_id` = rec_id;
		END IF;
		
	UNTIL done END REPEAT;
    
	CLOSE loan;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_lwop` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_lwop` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_lwop`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11),
	in dailyRate DECIMAL(12,2)
	)
BEGIN
	
	SET @lwop = 0;
	
	SELECT  SUM(`quantity`) INTO @lwop
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate 
		AND `transaction_code` = 'LWOP' AND latefile = 0 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @lwop > 0 THEN 
		
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'LWOP';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT( @lwop, encryption_key() ),
		     AES_ENCRYPT( ROUND( ( dailyRate / 8 ) ,2), encryption_key() ) ,
		     AES_ENCRYPT( ROUND( ( @lwop * ( dailyRate / 8 ) ) ,2), encryption_key() ),
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_lwop_adj` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_lwop_adj` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_lwop_adj`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @lwop = 0;
	
	SELECT  SUM(`quantity`) INTO @lwop
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate 
		AND `transaction_code` = 'LWOP_ADJ' AND latefile = 1 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @lwop != 0 THEN 
		
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'LWOP_ADJ';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT( @lwop, encryption_key() ),
		     AES_ENCRYPT( ROUND( (AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ,2), encryption_key() ) ,
		     AES_ENCRYPT( ROUND( ( @lwop * ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ) ),2) , encryption_key() ),
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_lwop_lf` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_lwop_lf` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_lwop_lf`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @lwop = 0;
	
	SELECT  SUM(`quantity`) INTO @lwop
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate 
		AND `transaction_code` = 'LWOP' AND latefile = 1 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @lwop > 0 THEN 
		
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = CONCAT('LWOP','_LF');
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT( @lwop, encryption_key() ),
		     AES_ENCRYPT( ROUND( (AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ),2), encryption_key() ) ,
		     AES_ENCRYPT( ROUND( ( @lwop * ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) ),2) , encryption_key() ),
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_nd` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_nd` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_nd`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @nd = 0;
	
	SELECT  SUM(`quantity`) INTO @nd
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate
		AND `transaction_code` = 'REGND' AND latefile = 0 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @nd > 0 THEN 
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'REGND';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT( @nd, encryption_key()) , 
		     AES_ENCRYPT( ROUND( ( ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ) * .1 ),2), encryption_key() ),
		     AES_ENCRYPT( ROUND( ( @nd * ( ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ) ) * .1 ), 2), encryption_key() ),
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_netpay` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_netpay` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_netpay`( 
	IN periodid INT(11), 
	IN puserid INT(11),
	IN paydate date,
	IN processing_type_id INT(11)
	)
BEGIN
	/* to do */
	-- modify on hold
	
	SET @netpay = 0.00;
	
	SELECT ROUND( SUM( IF( 
		ptt.`operation` = '-',
		AES_DECRYPT(pct.`amount`, encryption_key ()) * - 1,
		AES_DECRYPT(pct.`amount`, encryption_key ())
		) ), 2 ) 
	INTO @netpay
	FROM ww_payroll_current_transaction pct 
	INNER JOIN ww_payroll_transaction pt ON pt.`transaction_id` = pct.`transaction_id` 
	INNER JOIN ww_payroll_transaction_type ptt ON pct.`transaction_type_id` = ptt.`transaction_type_id` 
	INNER JOIN ww_payroll_transaction_class pc ON pc.`transaction_class_id` = pt.`transaction_class_id`
	WHERE pct.`employee_id` = puserid AND pct.`period_id` = periodid AND pct.`deleted` = 0 AND pct.`on_hold` = 0 and
	      pt.transaction_id NOT IN ( 
			SELECT pt.transaction_id
			FROM ww_payroll_transaction pt
			INNER JOIN ww_payroll_transaction_class pc ON pt.`transaction_class_id` = pc.`transaction_class_id`
			INNER JOIN ww_payroll_transaction_type tt ON tt.`transaction_type_id` = pt.`transaction_type_id`
			-- WHERE pc.`transaction_class_code` = 'LEAVES' AND pt.transaction_code NOT LIKE '%_ADJ'  AND operation = '+' );
			WHERE pc.`transaction_class_code` = 'LEAVES' AND (pt.transaction_code NOT LIKE '%_ADJ' AND pt.transaction_code NOT IN ('SLVLTAX','VLSLNT')) AND operation = '+' );
	
	SET @tran_code = '';
	SET @tran_id = 0;
	SET @tran_class_id = 0;
	SET @tran_type_id = 0;
	
	SELECT `transaction_code`, `transaction_id`, `transaction_type_id`, `transaction_class_id`
	INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
	FROM ww_payroll_transaction WHERE `transaction_code` = 'NETPAY';
	
	IF @netpay > 0 THEN
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
		     AES_ENCRYPT( @netpay, encryption_key()) ,
		     AES_ENCRYPT( @netpay, encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	end if;	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_overtime` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_overtime` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_overtime`(
	IN puserid INT(11),
	IN paydate DATE,
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE tran_code VARCHAR(32);
	DECLARE tran_id INT(11);
	DECLARE tran_class_id INT(11);
	DECLARE ot_rate DECIMAL(5,2);
	DECLARE qty DECIMAL(5,2);
	DECLARE ot_rate_amount DECIMAL(5,2);
	Declare employment_type varchar(32);
	DECLARE tran_type_id INT(11);
	DECLARE rec_id INT(11);
	
	DECLARE overtime CURSOR FOR 
		SELECT p.`transaction_id`, t.`transaction_class_id`, p.`transaction_code`, r.`overtime_rate`, ra.`overtime_amount`, IF(up.employment_type_id = 5,'supervisor','') AS employee_type, suM( p.`quantity` ), t.`transaction_type_id`,p.`record_id`
		FROM ww_time_record_process p
		LEFT JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		LEFT JOIN ww_partners up ON u.`user_id` = up.`user_id`
		LEFT JOIN ww_payroll_partners pp ON pp.`user_id` = u.`user_id`
		LEFT JOIN ww_payroll_overtime_rates r ON p.`transaction_code` = r.`overtime_code` AND u.`company_id` = r.`company_id` AND r.deleted = 0
		LEFT JOIN ww_payroll_overtime_rates_amount ra ON p.`transaction_code` = ra.`overtime_code` and ra.deleted = 0 AND u.`company_id` = ra.`company_id` AND pp.`location_id` = ra.`overtime_location_id`
		LEFT JOIN ww_payroll_transaction t ON p.`transaction_id` = t.`transaction_id`
		WHERE r.`deleted` = 0 AND p.`deleted` = 0 AND p.`payroll_date` = paydate AND p.`latefile` = 0 AND p.`transaction_code` != 'REGND' AND p.`user_id` = puserid
		GROUP BY p.`transaction_code`;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	-- select overtime;
	
	OPEN overtime;
	REPEAT
		FETCH overtime INTO tran_id, tran_class_id, tran_code, ot_rate, ot_rate_amount, employment_type, qty, tran_type_id, rec_id ;
		
		IF NOT done THEN
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, tran_id, tran_class_id,
			     tran_code, AES_ENCRYPT( qty, encryption_key() ), 
			     case
				when payroll_rate_type_id = 2 and employment_type != 'supervisor' then AES_ENCRYPT( ROUND( ( ( (AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) / 8 ) * ot_rate ),2), encryption_key() ) 
				WHEN payroll_rate_type_id = 2 AND employment_type = 'supervisor' THEN AES_ENCRYPT( ROUND(ot_rate_amount,2), encryption_key() ) 
				when payroll_rate_type_id = 6 then AES_ENCRYPT( ROUND( ( (AES_DECRYPT(`salary`, encryption_key()) / 8 ) * ot_rate ),2), encryption_key() ) 
				else 0 
			     end,
			     CASE
				WHEN payroll_rate_type_id = 2 AND employment_type != 'supervisor' THEN AES_ENCRYPT( ROUND( ( qty * ( ( ( ( AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ) * ot_rate ) ), 2 ), encryption_key() )
				WHEN payroll_rate_type_id = 2 AND employment_type = 'supervisor' THEN AES_ENCRYPT( ROUND((qty * ot_rate_amount),2), encryption_key() ) 
				when payroll_rate_type_id = 6 then AES_ENCRYPT( ROUND( ( qty * ( (AES_DECRYPT(`salary`, encryption_key()) / 8 ) * ot_rate ) ),2), encryption_key() ) 
				ELSE 0
			     END,
			     tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
	UNTIL done END REPEAT;
    
	CLOSE overtime;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_overtime_adj` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_overtime_adj` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_overtime_adj`(
	IN puserid INT(11),
	IN paydate DATE,
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE tran_code VARCHAR(32);
	DECLARE ot_rate DECIMAL(5,2);
	DECLARE qty DECIMAL(5,2);
	DECLARE ot_rate_amount DECIMAL(5,2);
	DECLARE employment_type VARCHAR(32);
	DECLARE tran_type_id INT(11);
	DECLARE rec_id INT(11);
	
	DECLARE overtime CURSOR FOR 
		SELECT p.`transaction_code`, r.`overtime_rate`, ra.`overtime_amount`, IF(up.employment_type_id = 5,'supervisor','') AS employee_type, SUM(p.`quantity`), t.`transaction_type_id`,p.`record_id`
		FROM ww_time_record_process p
		LEFT JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		LEFT JOIN ww_partners up ON u.`user_id` = up.`user_id`
		LEFT JOIN ww_payroll_partners pp ON pp.`user_id` = u.`user_id`		
		LEFT JOIN ww_payroll_overtime_rates r ON p.`transaction_code` = CONCAT(r.`overtime_code`,'_ADJ') AND u.`company_id` = r.`company_id` AND r.deleted = 0
		LEFT JOIN ww_payroll_overtime_rates_amount ra ON p.`transaction_code` = ra.`overtime_code` AND ra.deleted = 0 AND u.`company_id` = ra.`company_id` AND pp.`location_id` = ra.`overtime_location_id`
		LEFT JOIN ww_payroll_transaction t ON p.`transaction_id` = t.`transaction_id`
		WHERE r.`deleted` = 0 AND p.`deleted` = 0 AND p.`payroll_date` = paydate AND p.`transaction_code` != 'REGND' AND p.`latefile` = 1 AND p.`user_id` = puserid
		GROUP BY p.`transaction_code`;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	-- select overtime;
	
	OPEN overtime;
	REPEAT
		FETCH overtime INTO tran_code, ot_rate, ot_rate_amount, employment_type, qty, tran_type_id, rec_id ;
		
		IF NOT done THEN
			
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_code = tran_code;
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT( qty, encryption_key() ),
			     CASE
				WHEN payroll_rate_type_id = 2 AND employment_type != 'supervisor' THEN AES_ENCRYPT( ROUND( ( ( (AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) / 8 ) * ot_rate ),2), encryption_key() ) 
				WHEN payroll_rate_type_id = 2 AND employment_type = 'supervisor' THEN AES_ENCRYPT( ROUND(ot_rate_amount,2), encryption_key() ) 
				WHEN payroll_rate_type_id = 6 THEN AES_ENCRYPT( ROUND( ( (AES_DECRYPT(`salary`, encryption_key()) / 8 ) * ot_rate ),2), encryption_key() ) 
				ELSE 0 
			     END,
			     CASE
				WHEN payroll_rate_type_id = 2 AND employment_type != 'supervisor' THEN AES_ENCRYPT( ROUND( ( qty * ( ( ( ( AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ) * ot_rate ) ), 2 ), encryption_key() )
				WHEN payroll_rate_type_id = 2 AND employment_type = 'supervisor' THEN AES_ENCRYPT( ROUND((qty * ot_rate_amount),2), encryption_key() ) 
				WHEN payroll_rate_type_id = 6 THEN AES_ENCRYPT( ROUND( ( qty * ( (AES_DECRYPT(`salary`, encryption_key()) / 8 ) * ot_rate ) ),2), encryption_key() ) 
				ELSE 0
			     END,			      
			     tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
	UNTIL done END REPEAT;
    
	CLOSE overtime;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_overtime_lf` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_overtime_lf` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_overtime_lf`(
	IN puserid INT(11),
	IN paydate DATE,
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE tran_code VARCHAR(32);
	DECLARE ot_rate DECIMAL(3,2);
	DECLARE qty DECIMAL(3,2);
	DECLARE ot_rate_amount DECIMAL(5,2);
	DECLARE employment_type VARCHAR(32);	
	DECLARE tran_type_id INT(11);
	DECLARE rec_id INT(11);
	
	DECLARE overtime CURSOR FOR 
		SELECT p.`transaction_code`, r.`overtime_rate`, ra.`overtime_amount`, IF(up.employment_type_id = 5,'supervisor','') AS employee_type, sum(p.`quantity`), t.`transaction_type_id`,p.`record_id`
		FROM ww_time_record_process p
		LEFT JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		LEFT JOIN ww_partners up ON u.`user_id` = up.`user_id`
		LEFT JOIN ww_payroll_partners pp ON pp.`user_id` = u.`user_id`	
		LEFT JOIN ww_payroll_overtime_rates r ON p.`transaction_code` = CONCAT(r.`overtime_code`,'_ADJ') AND u.`company_id` = r.`company_id` AND r.deleted = 0	
		LEFT JOIN ww_payroll_overtime_rates_amount ra ON p.`transaction_code` = ra.`overtime_code` AND ra.deleted = 0 AND u.`company_id` = ra.`company_id` AND pp.`location_id` = ra.`overtime_location_id`
		LEFT JOIN ww_payroll_transaction t ON p.`transaction_id` = t.`transaction_id`
		WHERE r.`deleted` = 0 AND p.`deleted` = 0 AND p.`payroll_date` = paydate AND p.`latefile` = 1 AND p.`user_id` = puserid
		GROUP BY p.`transaction_code`;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	-- select overtime;
	
	OPEN overtime;
	REPEAT
		FETCH overtime INTO tran_code, ot_rate, ot_rate_amount, employment_type, qty, tran_type_id, rec_id ;
		
		IF NOT done THEN
			
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_code = CONCAT(tran_code,'_LF');
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT( qty, encryption_key() ), 
			     CASE
				WHEN payroll_rate_type_id = 2 AND employment_type != 'supervisor' THEN AES_ENCRYPT( ROUND( ( ( (AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) / 8 ) * ot_rate ),2), encryption_key() ) 
				WHEN payroll_rate_type_id = 2 AND employment_type = 'supervisor' THEN AES_ENCRYPT( ROUND(ot_rate_amount,2), encryption_key() ) 
				WHEN payroll_rate_type_id = 6 THEN AES_ENCRYPT( ROUND( ( (AES_DECRYPT(`salary`, encryption_key()) / 8 ) * ot_rate ),2), encryption_key() ) 
				ELSE 0 
			     END,
			     CASE
				WHEN payroll_rate_type_id = 2 AND employment_type != 'supervisor' THEN AES_ENCRYPT( ROUND( ( qty * ( ( ( ( AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ) * ot_rate ) ), 2 ), encryption_key() )
				WHEN payroll_rate_type_id = 2 AND employment_type = 'supervisor' THEN AES_ENCRYPT( ROUND((qty * ot_rate_amount),2), encryption_key() ) 
				WHEN payroll_rate_type_id = 6 THEN AES_ENCRYPT( ROUND( ( qty * ( (AES_DECRYPT(`salary`, encryption_key()) / 8 ) * ot_rate ) ),2), encryption_key() ) 
				ELSE 0
			     END,
			     tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
	UNTIL done END REPEAT;
    
	CLOSE overtime;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_phic_contribution` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_phic_contribution` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_phic_contribution`(
	IN periodid INT(11), 
	IN paydate DATE,
	IN pay_sched_id INT(11),
	IN processing_type_id INT(11),
	IN nweek INT(1),
	IN puserid INT(11),
	IN salary DECIMAL(12,2),
	IN phic_mode INT(11),
	IN phic_week VARCHAR(11)
	)
BEGIN
	SET @employee_id = 0;
	SET @cnt_week = '';
	SET @salary = 0.00;
	
	SET @eeshare = 0.00;
	SET @ershare = 0.00;
	
	SET @prev_eeshare = 0.00;
	SET @prev_ershare = 0.00;
	
	SET @prev_salary = 0.00;
	
	SET @earnings = 0.00;
	SET @bracket = 0.00;
	
	-- get assing salary or basic rate
	SELECT `user_id`, LENGTH(REPLACE(`phic_week`,',','')) INTO @employee_id, @cnt_week
	FROM ww_payroll_partners
	WHERE `user_id` = puserid AND FIND_IN_SET(nweek,`phic_week`) AND `payroll_schedule_id` = pay_sched_id;
	
	IF @employee_id > 0 THEN
		-- check previous payment
		SELECT MAX(CASE WHEN (`c`.`transaction_code` = 'PHIC_EMP') THEN ROUND(AES_DECRYPT(`c`.`amount`,`encryption_key`()),2) END) AS `prev_eeshare`,MAX(CASE WHEN (`c`.`transaction_code` = 'PHIC_COM') THEN ROUND(AES_DECRYPT(`c`.`amount`,`encryption_key`()),2) END) AS `prev_ershare` INTO @prev_eeshare, @prev_ershare
		FROM ww_payroll_closed_transaction c
		WHERE c.`employee_id` = @employee_id AND MONTH(c.`payroll_date`) = MONTH(paydate)
			AND c.`transaction_code` IN ('PHIC_EMP','PHIC_COM');
					
		/*SELECT SUM(`employee`), SUM(`company`) INTO @prev_eeshare, @prev_ershare
		FROM ww_payroll_partners_contribution c
		LEFT JOIN ww_payroll_transaction t ON c.`transaction_id` = t.`transaction_id`
		WHERE c.`user_id` = @employee_id AND MONTH(c.`payroll_date`) = MONTH(paydate) 
			AND t.`transaction_code` = 'PHIC_EMP';*/
		
		IF @cnt_week > 1 THEN
		    IF phic_mode = 1 THEN
			    -- previous salary
			    SELECT ROUND(SUM(AES_DECRYPT(`amount`, encryption_key())),2) INTO @prev_salary 
			    FROM ww_payroll_closed_transaction WHERE MONTH(`payroll_date`) = MONTH(@paydate) 
				AND `transaction_code` = 'SALARY' AND `deleted` = 0 AND `employee_id` = @employee_id;
				
		    ELSEIF phic_mode = 5 THEN
			    -- previous actual earning
			    set @result = 0.00;
			    SET @prev_actual_earning = 0.00;
			    CALL sp_payroll_get_transaction(@employee_id,periodid,'1,5',1,0,0,3,@result);
			    SET @prev_actual_earning = @result;
			    
	            END IF;
	              
		END IF;
		
		-- monthly
		IF pay_sched_id = 4 THEN
		    
		    -- default
		    IF phic_mode = 1 THEN
			-- get bracket
			-- SELECT `eeshare`, `ershare` INTO @eeshare, @ershare
			select IF(`eeshare` < 100,ROUND((salary * (`eeshare` / 2) / 100),2),`eeshare`), IF(`ershare` < 100,ROUND((salary * (`ershare` / 2) / 100),2),`ershare`) INTO @eeshare, @ershare
			FROM ww_payroll_phic_table 
			WHERE salary BETWEEN `from` AND `to`;
		
		    -- actual	
		    ELSEIF phic_mode = 5 THEN
		    
			-- get actual earning
			SET @result = 0.00;
			CALL sp_payroll_get_transaction(@employee_id,periodid,'1,5',1,1,1,0,@result);
			SET @earnings = @result;
			-- get bracket
			-- SELECT `eeshare`, `ershare` INTO @eeshare, @ershare
			SELECT IF(`eeshare` < 100,ROUND((@earnings * (`eeshare` / 2) / 100),2),`eeshare`), IF(`ershare` < 100,ROUND((@earnings * (`ershare` / 2) / 100),2),`ershare`) INTO @eeshare, @ershare
			FROM ww_payroll_phic_table 
			WHERE @earnings BETWEEN `from` AND `to`;
			
		    ELSE
			SET @eeshare = 0.00; 
			SET @ershare = 0.00;
		    
		    END IF;
		    
		-- semi-monthly
		ELSEIF pay_sched_id = 5 THEN
		    
		    -- default
		    IF phic_mode = 1 THEN
			IF @payrate = 6 THEN 
				SET @salary = ( salary * (@total_year_days/12 ) ) /@cnt_week;
			ELSE 
				SET @salary = salary/@cnt_week;
			END IF;
						
			-- get total salary if has previous payment
			SET @bracket =  @salary + IFNULL(@prev_salary,0.00);
			-- get bracket
			
			-- SELECT `eeshare`, `ershare` INTO @eeshare, @ershare
			SELECT IF(`eeshare` < 100,ROUND((@bracket * (`eeshare` / 2) / 100),2),`eeshare`), IF(`ershare` < 100,ROUND((@bracket * (`ershare` / 2) / 100),2),`ershare`) INTO @eeshare, @ershare
			FROM ww_payroll_phic_table 
			WHERE @bracket BETWEEN `from` AND `to`;
			
			IF @prev_salary > 0 THEN
				SET @eeshare = @eeshare - IFNULL(@prev_eeshare,0.00);
				SET @ershare = @ershare - IFNULL(@prev_ershare,0.00);
				
			END IF;
			
		    -- actual
		    ELSEIF phic_mode = 5 THEN
			
			-- get actual earning
			SET @result = 0.00;
			CALL sp_payroll_get_transaction(@employee_id,periodid,'1,5',1,1,1,0,@result);
			SET @earnings = @result;
			
			-- get total earnings if has previous payment
			SET @bracket = @earnings + IFNULL(@prev_actual_earning,0.00);
			 
			-- get bracket
			-- SELECT `eeshare`, `ershare` INTO @eeshare, @ershare
			SELECT IF(`eeshare` < 100,ROUND((@bracket * (`eeshare` / 2) / 100),2),`eeshare`), IF(`ershare` < 100,ROUND((@bracket * (`ershare` / 2) / 100),2),`ershare`) INTO @eeshare, @ershare
			FROM ww_payroll_phic_table 
			WHERE @bracket BETWEEN `from` AND `to`;
			
			IF @prev_actual_earning > 0 THEN
				SET @eeshare = @eeshare - IFNULL(@prev_eeshare,0.00);
				SET @ershare = @ershare - IFNULL(@prev_ershare,0.00);
			END IF;
			
		    ELSE
			SET @eeshare = 0.00; 
			SET @ershare = 0.00;
		    END IF;
		    
		-- weekly
		ELSEIF pay_sched_id = 6 THEN
		    
		    -- default
		    IF phic_mode = 1 THEN
		    
			SET @salary = salary/@cnt_week;
			-- get total salary if has previous payment
			SET @bracket =  @salary + IFNULL(@prev_salary,0.00);
			-- get bracket
			-- SELECT `eeshare`, `ershare` INTO @eeshare, @ershare
			SELECT IF(`eeshare` < 100,ROUND((@bracket * (`eeshare` / 2) / 100),2),`eeshare`), IF(`ershare` < 100,ROUND((@bracket * (`ershare` / 2) / 100),2),`ershare`) INTO @eeshare, @ershare
			FROM ww_payroll_phic_table 
			WHERE @bracket BETWEEN `from` AND `to`;
			
			IF @prev_salary > 0 THEN
				SET @eeshare = @eeshare - IFNULL(@prev_eeshare,0.00);
				SET @ershare = @ershare - IFNULL(@prev_ershare,0.00);
				
			END IF;
		    
		    -- actual
		    ELSEIF phic_mode = 5 THEN
		    
			-- get actual earning
			SET @result = 0.00;
			CALL sp_payroll_get_transaction(@employee_id,periodid,'1,5',1,1,1,0,@result);
			SET @earnings = @result;
			
			-- get total earnings if has previous payment
			SET @bracket = @earnings + IFNULL(@prev_actual_earning,0.00);
			
			-- get bracket
			-- SELECT `eeshare`, `ershare` INTO @eeshare, @ershare
			SELECT IF(`eeshare` < 100,ROUND((@bracket * (`eeshare` / 2) / 100),2),`eeshare`), IF(`ershare` < 100,ROUND((@bracket * (`ershare` / 2) / 100),2),`ershare`) INTO @eeshare, @ershare
			FROM ww_payroll_phic_table 
			WHERE @bracket BETWEEN `from` AND `to`;
			
			IF @prev_actual_earning > 0 THEN
				SET @eeshare = @eeshare - IFNULL(@prev_eeshare,0.00);
				SET @ershare = @ershare - IFNULL(@prev_ershare,0.00);
			END IF;
			
		    ELSE
			SET @eeshare = 0.00; 
			SET @ershare = 0.00;
		    END IF;
		    
		END IF;
		
		IF @eeshare > 0 THEN
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SET @tran_type_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE `transaction_code` = 'PHIC_EMP';
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
			     AES_ENCRYPT( @eeshare, encryption_key()) ,
			     AES_ENCRYPT( @eeshare, encryption_key()), 
			     @tran_type_id, 0,'',0,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
		
		IF @ershare > 0 THEN
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SET @tran_type_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE `transaction_code` = 'PHIC_COM';
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
			     AES_ENCRYPT( @ershare, encryption_key()) ,
			     AES_ENCRYPT( @ershare, encryption_key()), 
			     @tran_type_id, 0,'',0,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
		
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_recurring` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_recurring` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_recurring`(
		in puserid int(11), 
		in periodid int(11), 
		in sweek varchar(5), 
		in paydate date,
		in processing_type_id int(11)
	)
BEGIN
	
	DECLARE done TINYINT(1) DEFAULT 0;
	declare rec_id int(11);
	declare amount decimal(12,2);
	declare quantity decimal(12,2);
	declare tran_id int(11);
	DECLARE tran_class_id INT(11);
	declare tran_type_id int(11);
	declare tran_method int(11); 
	declare tran_code varchar(32);
	declare salary decimal(12,2);
	declare year_days decimal(5,2);
	declare divisor decimal(5,2);
	declare comp_id int(11);
	
	declare recurring cursor for
		
		SELECT  r.`recurring_id`, aes_decrypt( e.`amount`, encryption_key() ), 
			aes_decrypt( e.`quantity`, encryption_key() ), r.`transaction_id`, 
			t.`transaction_class_id`, t.`transaction_type_id`, r.`transaction_method_id`, 
			t.`transaction_code`,AES_DECRYPT( p.`salary`, encryption_key() ),
			p.`total_year_days`, d.`divisor`, p.company_id
		FROM
		  ww_payroll_entry_recurring r 
		  LEFT JOIN ww_payroll_entry_recurring_employee e 
		    ON r.`recurring_id` = e.`recurring_id` 
		  LEFT JOIN ww_payroll_transaction t 
		    ON t.`transaction_id` = r.`transaction_id` 
		  LEFT JOIN ww_payroll_partners p 
		    ON p.`user_id` = e.`employee_id` 
		  LEFT JOIN ww_payroll_schedule_rate_divisor d
		    ON p.`payroll_schedule_id` = d.`payroll_schedule_id` AND p.`payroll_rate_type_id` = d.`payroll_rate_type_id`
		where r.`deleted` = 0 and e.deleted = 0 and e.`employee_id` = puserid 
			and paydate between r.`date_from` and r.`date_to`
			and find_in_set( sweek, r.`week` ); 
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	OPEN recurring;
	REPEAT
		FETCH recurring INTO rec_id, amount, quantity, tran_id, tran_class_id, tran_type_id, tran_method, tran_code, salary, year_days, divisor, comp_id;
		
		if not done then
			SET @amount = 0.00;
			SET @remarks = '';
			-- Earnings (%)
			if tran_method = 1 then
				set @amount = 'base_on_earnings';
			-- Period Salary (%)
			elseif tran_method = 2 then
				set @amount = round( ( salary / divisor ) * ( amount / 100 ),2 );
			-- Fixed
			elseif tran_method = 3 then
				SET @amount = amount;
			-- Period Salary and Attendance (%)
			elseif tran_method = 4 then
				SET @absent = 0.00;
				SET @absent_adj = 0.00;
				
				SELECT SUM(`ww_time_record_process`.`quantity`) / 8 INTO @absent FROM ww_time_record_process
				WHERE `user_id` = puserid AND `payroll_date` = paydate AND transaction_code IN ('ABSENCES','LWOP');
				-- SET @amount = amount * @hrs;
				SET @amount = amount - ((amount / (year_days / 12 )) * IFNULL(@absent,0));
				
				SELECT SUM(`ww_time_record_process`.`quantity`) / 8 INTO @absent_adj FROM ww_time_record_process
				WHERE `user_id` = puserid AND `payroll_date` = paydate AND transaction_code IN ('ABSENCES_ADJ','LWOP_ADJ');
				SET @amount = @amount - ((amount / (year_days / 12 )) * IFNULL(@absent_adj,0));
			-- Actual Salary (%)
			elseif tran_method = 5 then
				SET @amount = ROUND( ( salary * ( amount / 100 ) ),2 );
			-- ADDITIONAL For BAYLEAF SERVICE CHARGE
			ELSEIF tran_method = 6 then
				set @nDays = 0.00;
				SET @nLess = 0;
				set @nValue = 0;
				SET @nPrevTimeID = 0;
				SET @nCurTimeID = 0;
				set @dtPrevPayDate = '';
				set @dtStart = '';
				set @dtEnd = '';
				
				-- Get Previous Period
				select period_id, date_from, date_to into @nCurTimeID, @dtStart, @dtEnd 
				FROM ww_time_period where company_id = comp_id and payroll_date = paydate;
				set @nPrevTimeID = `time_get_previous_period`(@nCurTimeID);
				if @nPrevTimeID > 0 then
					-- SET START DATE
					select payroll_date, date_from into @dtPrevPayDate, @dtStart 
					FROM ww_time_period WHERE period_id = @nPrevTimeID;
				end if;
				-- Get Number of Days
				SELECT `value` into @nValue FROM ww_config WHERE `key` = 'service_charge_days';
				SELECT ROUND(SUM(absent) + SUM(IFNULL(lwop/hrs_rendered,0)) + SUM(IFNULL(late/hrs_rendered,0)) + SUM(IFNULL(undertime/hrs_rendered,0)),2)
				into @nLess
				FROM ww_time_record_summary 
				where payroll_date in (@dtPrevPayDate, paydate) AND user_id = puserid and deleted = 0 
					and `date` between @dtStart and @dtEnd ;
					
				set @nDays = ifnull(@nValue,0) - ifnull(@nLess,0);
				SET @amount = ROUND( ( ( amount * @nDays) / 2 ),2 );
				set @remarks = 'service_charge';
			-- daily rate
			ELSEIF tran_method = 7 THEN
				SET @day_work = 0.00;
				
				SELECT SUM(`ww_time_record_summary`.`hrs_actual`) / 8 INTO @day_work FROM ww_time_record_summary
				WHERE `user_id` = puserid AND `payroll_date` = paydate AND day_type in ('REGULAR');
				-- SET @amount = amount * @hrs;
				SET @amount = amount * IFNULL(@day_work,0);				
			end if;
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, `user_id`, tran_id, tran_class_id,
			     tran_code, AES_ENCRYPT( quantity, encryption_key() ), 
			     AES_ENCRYPT( round( @amount, 2 ), encryption_key() ) ,
			     AES_ENCRYPT( round( @amount, 2 ), encryption_key() ),
			     tran_type_id, 0,'recurring',rec_id,0,@remarks,NOW(),0,0
			FROM ww_payroll_partners 
			WHERE `user_id` = puserid;
			
		end if;
			
	UNTIL done END REPEAT;
    
	CLOSE recurring;
	-- 
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_salary_monthly` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_salary_monthly` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_salary_monthly`(
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	INSERT INTO `ww_payroll_current_transaction`
	    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
	     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
	     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
	     `created_by`, `deleted`)
	SELECT periodid, processing_type_id, paydate, user_id, 1, 1,
	     'SALARY', AES_ENCRYPT(1.00, encryption_key()), 
	     AES_ENCRYPT( 
		round(
		(AES_DECRYPT(salary, encryption_key()) / ( 
			CASE `payroll_schedule_id` WHEN 4 THEN 1 WHEN 5 THEN 2 WHEN 6 THEN 4 ELSE 2 END)
		),2), encryption_key()
	     ) ,
	     AES_ENCRYPT( 
		round(
		(AES_DECRYPT(salary, encryption_key()) / ( 
			CASE `payroll_schedule_id` WHEN 4 THEN 1 WHEN 5 THEN 2 WHEN 6 THEN 4 ELSE 2 END)
		),2), encryption_key()
	     ) ,
	     1, 0,'',0,0,'',NOW(),0,0
	FROM ww_payroll_partners 
	WHERE user_id = puserid;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_salary_weekly` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_salary_weekly` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_salary_weekly`(
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	SET @tran_code = '';
	SET @tran_id = 0;
	SET @tran_class_id = 0;
	SET @tran_type_id = 0;
	SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
	INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
	FROM ww_payroll_transaction WHERE transaction_code = 'SALARY';
	
	INSERT INTO `ww_payroll_current_transaction`
	    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
	     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
	     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
	     `created_by`, `deleted`)
	SELECT periodid, processing_type_id, paydate, puserid, @tran_id, @tran_class_id,
	       @tran_code, AES_ENCRYPT(SUM(t.`hrs_actual`), encryption_key()), 
	       AES_ENCRYPT( ( AES_DECRYPT(`salary`, encryption_key()) / 8 ), encryption_key() ) ,
	       AES_ENCRYPT( SUM(t.`hrs_actual`) * ( AES_DECRYPT(`salary`, encryption_key()) / 8 ), encryption_key() ) ,
	       @tran_type_id, 0,'',0,0,'',NOW(),0,0
	FROM ww_payroll_partners p, ww_time_record_summary t
	WHERE p.`user_id` = t.`user_id` AND 
	      p.`user_id` = puserid AND
	      t.`payroll_date` = paydate
	GROUP BY t.`user_id`, t.`payroll_date`;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_sss_contribution` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_sss_contribution` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_sss_contribution`(
	IN periodid INT(11), 
	IN paydate DATE,
	IN pay_sched_id INT(11),
	IN processing_type_id INT(11) ,
	IN nweek INT(1),
	IN puserid INT(11),
	IN salary DECIMAL(12,2),
	IN sss_mode INT(11),
	IN sss_week VARCHAR(11)
	)
BEGIN
	SET @employee_id = 0;
	SET @cnt_week = '';
	SET @salary = 0.00;
	
	SET @eeshare = 0.00;
	SET @ershare = 0.00;
	SET @ec = 0.00;
	
	SET @prev_eeshare = 0.00;
	SET @prev_ershare = 0.00;
	SET @prev_ec = 0.00;
	SET @prev_salary = 0.00;
	
	SET @earnings = 0.00;
	SET @bracket = 0.00;
	SET @cola = 0.00;
	SET @total_year_days = 0;
	SET @payrate = 0;
	SELECT `user_id`, LENGTH(REPLACE(`sss_week`,',','')), total_year_days, payroll_rate_type_id INTO @employee_id, @cnt_week, @total_year_days, @payrate 
	FROM ww_payroll_partners
	WHERE `user_id` = puserid AND FIND_IN_SET(nweek,`sss_week`) 
	AND `payroll_schedule_id` = pay_sched_id;
	
	IF @employee_id > 0 THEN
		
		-- set cola 
		SET @cola = get_cola(@employee_id, paydate);
		-- check previous payment
		SELECT MAX(CASE WHEN (`c`.`transaction_code` = 'SSS_EMP') THEN ROUND(AES_DECRYPT(`c`.`amount`,`encryption_key`()),2) END) AS `prev_eeshare`,MAX(CASE WHEN (`c`.`transaction_code` = 'SSS_COM') THEN ROUND(AES_DECRYPT(`c`.`amount`,`encryption_key`()),2) END) AS `prev_ershare`,MAX(CASE WHEN (`c`.`transaction_code` = 'SSS_ECC') THEN ROUND(AES_DECRYPT(`c`.`amount`,`encryption_key`()),2) END) AS `prev_ec` INTO @prev_eeshare, @prev_ershare, @prev_ec
		FROM ww_payroll_closed_transaction c
		WHERE c.`employee_id` = @employee_id AND (MONTH(c.`payroll_date`) = MONTH(paydate) AND YEAR(c.`payroll_date`) = YEAR(paydate))
			AND c.`transaction_code` IN ('SSS_EMP','SSS_COM','SSS_ECC');
					
		/*SELECT SUM(c.`employee`), SUM(c.`company`), SUM(c.`ec`) INTO @prev_eeshare, @prev_ershare, @prev_ec
		FROM ww_payroll_partners_contribution c
		LEFT JOIN ww_payroll_transaction t ON c.`transaction_id` = t.`transaction_id`
		WHERE c.`user_id` = @employee_id AND MONTH(c.`payroll_date`) = MONTH(paydate) 
			AND t.`transaction_code` = 'SSS_EMP';*/
		
		IF @cnt_week > 1 THEN
		    IF sss_mode = 1 THEN
			    -- previous salary
			    SELECT ROUND(SUM(AES_DECRYPT(`amount`, encryption_key())),2) INTO @prev_salary 
			    FROM ww_payroll_closed_transaction 
			    WHERE (MONTH(`payroll_date`) = MONTH(paydate) AND YEAR(`payroll_date`) = YEAR(paydate)) 
				AND `transaction_code` = 'SALARY' AND deleted = 0 AND `employee_id` = @employee_id;
				
		    ELSEIF sss_mode = 5 THEN
			    -- previous actual earning
			    SET @result = 0.00;
			    SET @prev_actual_earning = 0.00;
			    CALL sp_payroll_get_transaction(@employee_id,periodid,'1,5',1,0,0,3,@result);
			    SET @prev_actual_earning = @result;
			    
	            END IF;
	              
		END IF;
		
		-- monthly
		IF pay_sched_id = 4 THEN
		    -- default
		    IF sss_mode = 1 THEN
			
			-- with cola
			IF @cola > 0 THEN
				SET salary = salary + @cola;
			END IF;
			
			-- get bracket
			SELECT `eeshare`, `ershare`, `ec` INTO @eeshare, @ershare, @ec
			FROM ww_payroll_sss_table 
			WHERE salary BETWEEN `from` AND `to`;
		
		    -- actual	
		    ELSEIF sss_mode = 5 THEN
			-- get actual earning
			SET @result = 0.00;
			CALL sp_payroll_get_transaction(@employee_id,periodid,'1,2,5,6',1,1,1,0,@result);
			SET @earnings = @result;
			
			-- get bracket
			SELECT `eeshare`, `ershare`, `ec` INTO @eeshare, @ershare, @ec
			FROM ww_payroll_sss_table 
			WHERE @earnings BETWEEN `from` AND `to`;
			
		    ELSE
			SET @eeshare = 0.00; 
			SET @ershare = 0.00;
			SET @ec = 0.00;
			
		    END IF;
		-- semi-monthly
		ELSEIF pay_sched_id = 5 THEN
		    
		    -- default
		    IF sss_mode = 1 THEN
			IF @payrate = 6 THEN 
				SET @salary = ( salary * (@total_year_days/12 ) ) /@cnt_week;
			ELSE 
				SET @salary = salary/@cnt_week;
			END IF;
			-- get total salary if has previous payment
			SET @bracket =  @salary + IFNULL(@prev_salary,0.00);
			-- with cola
			IF @cola > 0 THEN
				SET @bracket = @bracket + @cola;
			END IF;
			-- get bracket 
			SELECT `eeshare`, `ershare`, `ec` INTO @eeshare, @ershare, @ec
			FROM ww_payroll_sss_table 
			WHERE @bracket BETWEEN `from` AND `to`;
			
			IF @prev_salary > 0 THEN
				SET @eeshare = @eeshare - IFNULL(@prev_eeshare,0.00);
				SET @ershare = @ershare - IFNULL(@prev_ershare,0.00);
				SET @ec = @ec - IFNULL(@prev_ec,0.00);
			END IF;
			
		    -- actual
		    ELSEIF sss_mode = 5 THEN
			
			-- get actual earning
			SET @result = 0.00;
			CALL sp_payroll_get_transaction(@employee_id,periodid,'1,2,5,6',1,1,1,0,@result);
			SET @earnings = @result;
			
			-- get total earnings if has previous payment
			SET @bracket = @earnings + IFNULL(@prev_actual_earning,0.00);
									
			-- get bracket
			SELECT `eeshare`, `ershare`, `ec` INTO @eeshare, @ershare, @ec
			FROM ww_payroll_sss_table 
			WHERE @bracket BETWEEN `from` AND `to`;
			
			IF @prev_actual_earning > 0 THEN
				SET @eeshare = @eeshare - IFNULL(@prev_eeshare,0.00);
				SET @ershare = @ershare - IFNULL(@prev_ershare,0.00);
				SET @ec = @ec - IFNULL(@prev_ec,0.00);
			END IF;
			
		    ELSE
			SET @eeshare = 0.00; 
			SET @ershare = 0.00;
			SET @ec = 0.00;
			
		    END IF;
		    
		-- weekly
		ELSEIF pay_sched_id = 6 THEN
		    
		    -- default
		    IF sss_mode = 1 THEN
			
			SET @salary = ( salary * (@total_year_days/12 ) ) /@cnt_week;
			-- get total salary if has previous payment
			SET @bracket =  @salary + IFNULL(@prev_salary,0.00);
			
			-- with cola
			IF @cola > 0 THEN
				SET @bracket = @bracket + @cola;
			END IF;
			
			-- get bracket
			SELECT `eeshare`, `ershare`, `ec` INTO @eeshare, @ershare, @ec
			FROM ww_payroll_sss_table 
			WHERE @bracket BETWEEN `from` AND `to`;
			
			IF @prev_salary > 0 THEN
				SET @eeshare = @eeshare - IFNULL(@prev_eeshare,0.00);
				SET @ershare = @ershare - IFNULL(@prev_ershare,0.00);
				SET @ec = @ec - IFNULL(@prev_ec,0.00);
			END IF;
		    
		    -- actual
		    ELSEIF sss_mode = 5 THEN
		    
			-- get actual earning
			SET @result = 0.00;
			CALL sp_payroll_get_transaction(@employee_id,periodid,'1,2,5,6',1,1,1,0,@result);
			SET @earnings = @result;
			
			-- get total earnings if has previous payment
			SET @bracket = @earnings + IFNULL(@prev_actual_earning,0.00);
			
			-- get bracket
			SELECT `eeshare`, `ershare`, `ec` INTO @eeshare, @ershare, @ec
			FROM ww_payroll_sss_table 
			WHERE @bracket BETWEEN `from` AND `to`;
			
			IF @prev_actual_earning > 0 THEN
				SET @eeshare = @eeshare - IFNULL(@prev_eeshare,0.00);
				SET @ershare = @ershare - IFNULL(@prev_ershare,0.00);
				SET @ec = @ec - IFNULL(@prev_ec,0.00);
			END IF;
			
		    ELSE
			SET @eeshare = 0.00; 
			SET @ershare = 0.00;
			SET @ec = 0.00;
			
		    END IF;
		    
		END IF;
		
		IF @eeshare > 0 THEN
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SET @tran_type_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE `transaction_code` = 'SSS_EMP';
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
			     AES_ENCRYPT( @eeshare, encryption_key()) ,
			     AES_ENCRYPT( @eeshare, encryption_key()), 
			     @tran_type_id, 0,'',0,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
		
		IF @ershare > 0 THEN
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SET @tran_type_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE `transaction_code` = 'SSS_COM';
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
			     AES_ENCRYPT( @ershare, encryption_key()) ,
			     AES_ENCRYPT( @ershare, encryption_key()), 
			     @tran_type_id, 0,'',0,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
		
		IF @ec > 0 THEN
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SET @tran_type_id = 0;
			SELECT `transaction_code`, `transaction_id`, `transaction_type_id`, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE `transaction_code` = 'SSS_ECC';
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
			     AES_ENCRYPT( @ec, encryption_key()) ,
			     AES_ENCRYPT( @ec, encryption_key()), 
			     @tran_type_id, 0,'',0,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
		
		
	
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_taxable_transaction` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_taxable_transaction` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_taxable_transaction`(
	IN puserid INT(11),
	in paydate date,
	OUT current_exclusion DECIMAL(12,2),
	OUT current_salary DECIMAL(12,2),
	OUT current_allow DECIMAL(12,2),
	OUT current_bonus_tax DECIMAL(12,2)
    )
BEGIN
	set @current_exclusion = 0.00;
	set @current_salary = 0.00;
	set @current_allow = 0.00;
	set @current_bonus_tax = 0.00;
	
	SELECT 
		SUM( ( CASE WHEN ptc.`government_mandated` = 1 or pct.transaction_code = 'VLSLNT' THEN 1 ELSE 0 END ) * AES_DECRYPT(pct.`amount`, encryption_key()) ),
		SUM( ( CASE WHEN ptc.`transaction_class_code` = 'SALARY' THEN 1 ELSE 0 END ) * AES_DECRYPT(pct.`amount`, encryption_key()) ),
		SUM( ( CASE WHEN ptc.`transaction_class_code` IN ('ALLOWANCE_BATCH', 'ALLOWANCE_RECURRING','E-COLA')THEN 1 ELSE 0 END ) * AES_DECRYPT(pct.`amount`, encryption_key()) ),
		SUM( ( CASE WHEN ptc.`transaction_class_code` = 'BONUS_TAXABLE' THEN 1 ELSE 0 END ) * AES_DECRYPT(pct.`amount`, encryption_key()) )
	into @current_exclusion, @current_salary, @current_allow, @current_bonus_tax
	FROM ww_payroll_current_transaction pct, ww_payroll_transaction_class ptc
	WHERE pct.`transaction_class_id` = ptc.`transaction_class_id`
		and pct.`employee_id` = puserid
		and pct.`payroll_date` = paydate;
		
	SET current_exclusion = @current_exclusion;
	SET current_salary = @current_salary;
	SET current_allow = @current_allow;
	SET current_bonus_tax = @current_bonus_tax;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_tax_annualize` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_tax_annualize` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_tax_annualize`(
	IN puserid INT(11),
	IN periodid INT(11),
	IN paydate DATE,
	IN dtRes DATE,
	IN processing_type_id INT(11),
	IN pay_sched_id INT(11),
	IN nTaxcode INT(11),
	IN remain INT(11)
    )
BEGIN
	SET @ytdGross = 0.00;
	SET @ytdExclusion = 0.00;
	SET @ytdTax = 0.00;
	SET @curExclusion = 0.00;
	SET @curSalary = 0.00;
	SET @curAllow = 0.00;
	SET @curBonusTax = 0.00;
	SET @projExclusion = 0.00;
	SET @nTax  = 0.00;
	IF remain = '' OR remain IS NULL OR remain <= 0 THEN
		SET remain = 1;
	END IF;
	
	set @year = year(paydate);
	if dtRes <> '' then
		SET @year = YEAR(dtRes);
	end if;
	
	-- get ytd total
	CALL sp_payroll_get_ytd_total( puserid, @year, @ytdGross, @ytdExclusion, @ytdTax );
	-- get current taxable transaction
	CALL sp_payroll_get_taxable_transaction( puserid, paydate, @curExclusion, @curSalary, @curAllow, @curBonusTax );
	-- get total exemptions
	SET @exempt = 0;
	SELECT amount INTO @exempt FROM ww_taxcode WHERE `taxcode_id` = nTaxcode;
	
	-- INSERT INTO `logtable` (`log`) VALUES (CONCAT(' user id',puserid,' ytdtax - ',@ytdTax));
	
	-- INSERT INTO `logtable` (`log`) VALUES (CONCAT(' user id',puserid,'ytdgross - ',@ytdGross,' ytdexclusion - ',@ytdExclusion,' ytdtax - ',@ytdTax,' cursalary - ',@curSalary,' curallowance - ',@curAllow,' curbonuxtax - ',@curBonusTax,' curexclusion - ',@curExclusion,' exempt - ',@exempt));
	
	SET @nAnnTax = 0;
	SET @nBasis = IFNULL(@ytdGross,0) + IFNULL(@curSalary,0) + IFNULL(@curAllow,0) + IFNULL(@curBonusTax,0) - IFNULL(@ytdExclusion,0) - IFNULL(@curExclusion,0) - IFNULL(@exempt,0);
	
	-- INSERT INTO `logtable` (`log`) VALUES (CONCAT('Basis - ',@nBasis,' user id',puserid));
	
	IF @nBasis > 0 THEN
		SELECT ROUND(((@nBasis - salary_from)*(rate/100))+amount,2) INTO @nAnnTax
		FROM ww_payroll_annual_tax 
		WHERE @nBasis > salary_from
		ORDER BY salary_from DESC
		LIMIT 1;
	END IF;
	
	-- INSERT INTO `logtable` (`log`) VALUES (CONCAT('aannual tax - ',@nAnnTax,' ytd tax - ',@ytdTax));
	
	IF remain = 1 THEN
		SET @nTax = @nAnnTax - IFNULL(@ytdTax,0);
	END IF;
	
	-- INSERT INTO `logtable` (`log`) VALUES (CONCAT('ntax - ',@nTax));
	
	IF @nTax > 0 OR ( @nTax !=0 AND remain = 1 ) THEN
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'WHTAX';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
		     AES_ENCRYPT( Round(@nTax,2), encryption_key()),
		     AES_ENCRYPT( ROUND(@nTax,2), encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_tax_bonus` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_tax_bonus` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_tax_bonus`(
	IN puserid INT(11),
	IN periodid INT(11),
	IN paydate DATE,
	IN processing_type_id INT(11)
	)
BEGIN
	SET @bonus_taxable = 0.00;
	
	SELECT 
		SUM( (CASE WHEN `transaction_code` = 'BONUS_TAXABLE' THEN 1 ELSE 0 END) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) )
	into @bonus_taxable
	FROM ww_payroll_current_transaction
	where `payroll_date` = paydate and `employee_id` = puserid and deleted = 0;
	
	set @wtax = 0.00;
	if @bonus_taxable > 0 then
		set @wtax = @bonus_taxable * .32;
	end if;
	
	IF @wtax > 0 THEN
	
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'WHTAX';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
		     AES_ENCRYPT( @wtax, encryption_key()),
		     AES_ENCRYPT( @wtax, encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_tax_bonus_rf` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_tax_bonus_rf` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_tax_bonus_rf`(
	IN puserid INT(11),
	IN periodid INT(11),
	IN paydate DATE,
	IN processing_type_id INT(11),
	IN pay_sched_id int(11),
	in nTaxcode INT(11),
	IN amount DECIMAL(12,2)
	)
BEGIN
	SET @exclusion = 0.00;
	set @salary = 0.00;
	set @oth_income = 0.00;
	set @earnings = 0.00;
	
	SELECT 
		SUM(( CASE `transaction_type_id` WHEN 5 THEN 1 ELSE 0 END ) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) ),
		SUM(( CASE `transaction_code` WHEN 'SALARY' THEN 1 ELSE 0 END ) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) ),
		SUM( (CASE WHEN `transaction_code` != 'SALARY' AND `transaction_type_id` IN (1,6) THEN 1 ELSE 0 END) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) )
	into @exclusion, @salary, @oth_income
	FROM ww_payroll_current_transaction
	where `payroll_date` = paydate and `employee_id` = puserid and deleted = 0;
	
	set @earnings = amount;
	
	set @wtax = 0.00;
	if @earnings > 0 then
		set @wtax = payroll_get_wtax( pay_sched_id, nTaxcode, @earnings );
	end if;
	
	IF @wtax > 0 THEN
	
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'WHTAX';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
		     AES_ENCRYPT( @wtax, encryption_key()),
		     AES_ENCRYPT( @wtax, encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_tax_bonus_sup` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_tax_bonus_sup` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_tax_bonus_sup`(
	IN puserid INT(11),
	IN periodid INT(11),
	IN paydate DATE,
	IN processing_type_id INT(11)
	)
BEGIN
	SET @bonus_taxable = 0.00;
	
	SELECT 
		SUM( (CASE WHEN `transaction_code` = 'BONUS_TAXABLE' THEN 1 ELSE 0 END) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) )
	into @bonus_taxable
	FROM ww_payroll_current_transaction
	where `payroll_date` = paydate and `employee_id` = puserid and deleted = 0;
	
	set @wtax = 0.00;
	if @bonus_taxable > 0 then
		set @wtax = @bonus_taxable * .30;
	end if;
	
	IF @wtax > 0 THEN
	
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'WHTAX';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
		     AES_ENCRYPT( @wtax, encryption_key()),
		     AES_ENCRYPT( @wtax, encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_tax_manual` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_tax_manual` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_tax_manual`(
	IN puserid INT(11),
	IN periodid INT(11),
	IN paydate DATE,
	IN processing_type_id INT(11),
	IN pay_sched_id int(11),
	in amount decimal(12,2)
	)
BEGIN
	IF amount > 0 THEN
	
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'WHTAX';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
		     AES_ENCRYPT( amount, encryption_key()),
		     AES_ENCRYPT( amount, encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_tax_table` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_tax_table` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_tax_table`(
	IN puserid INT(11),
	IN periodid INT(11),
	IN paydate DATE,
	IN processing_type_id INT(11),
	IN pay_sched_id int(11),
	in nTaxcode INT(11)
	)
BEGIN
	SET @exclusion = 0.00;
	set @salary = 0.00;
	set @oth_income = 0.00;
	set @earnings = 0.00;
	
	SELECT 
		SUM(( CASE `transaction_type_id` WHEN 5 THEN 1 ELSE 0 END ) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) ),
		SUM(( CASE `transaction_code` WHEN 'SALARY' THEN 1 ELSE 0 END ) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) ),
		SUM( (CASE WHEN `transaction_code` != 'SALARY' AND `transaction_type_id` IN (1,6) THEN 1 ELSE 0 END) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) )
	into @exclusion, @salary, @oth_income
	FROM ww_payroll_current_transaction
	where `payroll_date` = paydate and `employee_id` = puserid and deleted = 0;
	
	set @earnings = @salary + @oth_income - @exclusion;
	
	set @wtax = 0.00;
	if @earnings > 0 then
		set @wtax = payroll_get_wtax( pay_sched_id, nTaxcode, @earnings );
	end if;
	
	IF @wtax > 0 THEN
	
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'WHTAX';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
		     AES_ENCRYPT( @wtax, encryption_key()),
		     AES_ENCRYPT( @wtax, encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_transaction` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_transaction` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_transaction`(
	IN puserid int(11),
	in periodid int(11),
	in tran_type_id varchar(10),
	in exclude_govt_contribution tinyint(1),
	in current tinyint(1),
	in this_period_only tinyint(1),
	in scope tinyint(1),
	out result varchar(1000)
	)
BEGIN
	declare paydate date;
	declare proc_type_id int;
	declare tran_id int;
	declare quantity decimal(10,2);
	DECLARE unit_rate DECIMAL(10,2);
	DECLARE amount DECIMAL(10,2);
	DECLARE transaction_type_id int;
	DECLARE on_hold int;
	DECLARE deleted int;
	DECLARE operation varchar(1);
	
	set @result = 0.00;
	set @payroll_date = '';
	set @period_processing_type_id = '';
	set @tbl = '';
	set @proc_type_id = '';
	set @scope = '';
	set @exclude_govt_contribution = '';
	set @this_period = '';
	
	-- get period
	select payroll_date, period_processing_type_id into @payroll_date, @period_processing_type_id
	from ww_payroll_period where payroll_period_id = periodid;
	
	IF current = 1 then
		set @tbl = 'ww_payroll_current_transaction a ';
		set @proc_type_id = CONCAT(' AND d.period_processing_type_id = ',@period_processing_type_id,' AND a.on_hold = 0 ');
	else 
		set @tbl = 'ww_payroll_closed_transaction a ';
		
		if scope = 1 then
			set @scope = CONCAT(" AND MONTH(a.payroll_date) = MONTH('",@payroll_date,"') ");
		elseif scope = 2 then
			SET @scope = CONCAT(" AND MONTH(a.payroll_date) = YEAR('",@payroll_date,"') ");
		elseif scope = 3 then
			SET @scope = CONCAT(" AND MONTH(a.payroll_date) = MONTH('",@payroll_date,"') AND YEAR(a.payroll_date) = YEAR('",@payroll_date,"') ");
		else
			set @scope = '';
		end if;
	end if;
	
	IF exclude_govt_contribution = 1 then
		set @exclude_govt_contribution = ' AND e.government_mandated != 1 ';
	end if;
	
	if this_period_only = 1 then
		set @this_period = concat(' AND a.period_id = ',periodid);
	end if;
	
	SET @buffer = CONCAT_WS('',
        'SELECT ROUND(SUM(CASE operation WHEN "+" THEN AES_DECRYPT(amount, encryption_key()) 
		WHEN "-" THEN AES_DECRYPT(amount, encryption_key()) * -1 ELSE "" END),2) INTO @result
        FROM ', @tbl,
        'LEFT JOIN ww_payroll_transaction b on b.transaction_code = a.transaction_code
        LEFT JOIN ww_payroll_transaction_type c on c.transaction_type_id = b.transaction_type_id
	LEFT JOIN ww_payroll_period d on a.period_id = d.payroll_period_id
	LEFT JOIN ww_payroll_transaction_class e on e.transaction_class_id = b.transaction_class_id
        WHERE a.deleted = 0 AND b.deleted = 0 AND a.employee_id = ',puserid,
        ' AND a.transaction_type_id IN (',tran_type_id,') ',@exclude_govt_contribution, @proc_type_id, @scope, @this_period
	);
	
	PREPARE stmt FROM @buffer;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	SET result = @result;
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_undertime` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_undertime` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_undertime`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @under = 0;
	
	/* 2017-05-23 */
	/* Removal of undertime for Managers
	SELECT  SUM(`quantity`) INTO @under
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate 
		AND `transaction_code` = 'DEDUCTION_UNDERTIME' AND latefile = 0 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id; */
	SELECT SUM(
		CASE WHEN p.`employment_type_id` = 4 THEN -- For Managers
			IF(trp.`quantity` >= (trs.`hrs_rendered` / 2), (trs.`hrs_rendered` / 2), 0)
		ELSE trp.`quantity` END)
	INTO @under
	FROM ww_time_record_process trp
	JOIN ww_partners p ON p.user_id = trp.user_id
	JOIN ww_time_record_summary trs ON trs.user_id = p.user_id AND trs.`date` = trp.`date` AND trp.`payroll_date` = trs.`payroll_date`
	WHERE trp.`user_id` = puserid AND trp.payroll_date = paydate 
		AND `transaction_code` = 'DEDUCTION_UNDERTIME' AND latefile = 0 AND trp.deleted = 0
	GROUP BY trp.user_id, trp.payroll_date, transaction_id;
	
	IF @under > 0 THEN 
		
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'DEDUCTION_UNDERTIME';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT( @under, encryption_key() ), 
		     AES_ENCRYPT( ROUND( ( (AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ),2), encryption_key() ) ,
		     AES_ENCRYPT( ROUND( ( @under * ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ),2), encryption_key() ),
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_undertime_adj` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_undertime_adj` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_undertime_adj`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @under = 0;
	
	SELECT  SUM(`quantity`) INTO @under
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate 
		AND `transaction_code` = 'DEDUCTION_UNDERTIME_ADJ' AND latefile = 1 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @under != 0 THEN 
		
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = 'DEDUCTION_UNDERTIME_ADJ';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT( @under, encryption_key() ), 
		     AES_ENCRYPT( ROUND( ( (AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ),2), encryption_key() ) ,
		     AES_ENCRYPT( ROUND( ( @under * ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ),2), encryption_key() ),
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_undertime_lf` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_undertime_lf` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_undertime_lf`( 
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11) 
	)
BEGIN
	SET @under = 0;
	
	SELECT  SUM(`quantity`) INTO @under
	FROM ww_time_record_process
	WHERE `user_id` = puserid AND payroll_date = paydate 
		AND `transaction_code` = 'DEDUCTION_UNDERTIME' AND latefile = 1 AND deleted = 0
	GROUP BY user_id, payroll_date, transaction_id;
	
	IF @under > 0 THEN 
		
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_class_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
		INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
		FROM ww_payroll_transaction WHERE transaction_code = CONCAT('DEDUCTION_UNDERTIME','_LF');
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, employee_id, @tran_id, @tran_class_id,
		     @tran_code, AES_ENCRYPT( @under, encryption_key() ), 
		     AES_ENCRYPT( ROUND( ( (AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) / 8 ),2), encryption_key() ) ,
		     AES_ENCRYPT( ROUND( ( @under * ( ( AES_DECRYPT(salary, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ),2), encryption_key() ),
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE employee_id = puserid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_wtax_tbl` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_wtax_tbl` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_wtax_tbl`(
	IN puserid INT(11),
	IN periodid INT(11),
	IN paydate DATE,
	IN processing_type_id INT(11),
	IN pay_sched_id int(11),
	in nTaxcode INT(11)
	)
BEGIN
	SET @exclusion = 0.00;
	set @salary = 0.00;
	set @oth_income = 0.00;
	set @earnings = 0.00;
	
	SELECT 
		SUM(( CASE `transaction_type_id` WHEN 5 THEN 1 ELSE 0 END ) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) ),
		SUM(( CASE `transaction_code` WHEN 'SALARY' THEN 1 ELSE 0 END ) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) ),
		SUM( (CASE WHEN `transaction_code` != 'SALARY' AND `transaction_type_id` = 1 THEN 1 ELSE 0 END) * IFNULL(AES_DECRYPT(`amount`, encryption_key() ), 0.00) )
	into @exclusion, @salary, @oth_income
	FROM ww_payroll_current_transaction
	where `payroll_date` = paydate and `employee_id` = puserid and deleted = 0;
	
	set @earnings = @salary + @oth_income - @exclusion;
	
	set @wtax = 0.00;
	if @earnings > 0 then
		set @wtax = payroll_get_wtax( pay_sched_id, nTaxcode, @earnings );
	end if;
	
	IF @wtax > 0 THEN
	
		SET @tran_code = '';
		SET @tran_id = 0;
		SET @tran_type_id = 0;
		SELECT transaction_code, transaction_id , transaction_type_id
		INTO @tran_code, @tran_id, @tran_type_id
		FROM ww_payroll_transaction WHERE transaction_code = 'WHTAX';
		
		INSERT INTO `ww_payroll_current_transaction`
		    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`,
		     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
		     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		     `created_by`, `deleted`)
		SELECT periodid, processing_type_id, paydate, user_id, @tran_id, 
		     @tran_code, AES_ENCRYPT(1.00, encryption_key()), 
		     AES_ENCRYPT( @wtax, encryption_key()),
		     AES_ENCRYPT( @wtax, encryption_key()), 
		     @tran_type_id, 0,'',0,0,'',NOW(),0,0
		FROM ww_payroll_partners 
		WHERE user_id = puserid;
	
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_get_ytd_total` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_get_ytd_total` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_get_ytd_total`(
	in puserid int(11),
	IN nYear INT(11),
	out ytdGross decimal(12,2),
	out ytdExclusion Decimal(12,2),
	out ytdTax decimal(12,2)
    )
BEGIN
	set @payYear = '';
	set @ytdGross = 0.00;
	set @ytdExclusion = 0.00;
	set @ytdTax = 0.00;
	
	select `year` into @payYear from ww_payroll_closed_summary
	where `user_id` = puserid and `type` = 'C' and `year` = nYear and `summary_code` = 'TAXABLE_INCOME';
	
	select 
		sum( ( case when `summary_code` = 'TAXABLE_INCOME' then 1 else 0 end ) * aes_decrypt( `ytd`, encryption_key() ) )
		+ SUM( ( CASE WHEN `summary_code` = 'DEMMINIMIS' THEN 1 ELSE 0 END ) * AES_DECRYPT( `ytd`, encryption_key() ) )
		+ SUM( ( CASE WHEN `summary_code` = 'PREV_GROSS' THEN 1 ELSE 0 END ) * AES_DECRYPT( `ytd`, encryption_key() ) ), -- ytd gross
		sum( ( case when `summary_code` = 'ADDITIONAL_EXCLUSION' then 1 else 0 end ) * AES_DECRYPT( `ytd`, encryption_key() ) ), -- ytd exclusion
		SUM( ( CASE WHEN `summary_code` = 'WHTAX' THEN 1 ELSE 0 END ) * AES_DECRYPT( `ytd`, encryption_key() ) )
		+ SUM( ( CASE WHEN `summary_code` = 'PREV_WHTAX' THEN 1 ELSE 0 END ) * AES_DECRYPT( `ytd`, encryption_key() ) )-- ytd tax
	into @ytdGross, @ytdExclusion, @ytdTax
	from ww_payroll_closed_summary
	where `user_id` = puserid and `type` in ('C', 'P') and `year` = @payYear;
	
	set ytdGross = @ytdGross;
	set ytdExclusion = @ytdExclusion;
	set ytdTax = @ytdTax;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_insert` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_insert` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_insert`(
	IN sTransaction VARCHAR(180),
	IN nUserID INT(11),
	IN periodid INT(11),
	IN processing_type_id INT(11),
	IN dtPay DATE,
	IN nQuantity DECIMAL(12,2),
	IN nUnitRate DECIMAL(12,2),
	IN nAmount DECIMAL(12,2), 
	IN nInsertedFrom INT(11),
	IN sRecordFrom VARCHAR(60),
	IN nRecordID INT(11),
	IN sRemarks VARCHAR(180)
	
    )
BEGIN
	
	SET @tran_code = '';
	SET @tran_id = 0;
	SET @tran_class_id = 0;
	SET @tran_type_id = 0;
	SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
	INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
	FROM ww_payroll_transaction WHERE transaction_code = sTransaction AND deleted = 0;
	
	INSERT INTO `ww_payroll_current_transaction`(
		`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,
		`transaction_id`, `transaction_class_id`, `transaction_code`, `transaction_type_id`,
		`quantity`,`unit_rate`,`amount`,
		`inserted_from_id`, `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
		`created_by`, `deleted`)
	SELECT periodid, processing_type_id, dtPay, user_id, 
		@tran_id, @tran_class_id, @tran_code, @tran_type_id,
		AES_ENCRYPT( nQuantity, encryption_key() ), 
		AES_ENCRYPT( nUnitRate, encryption_key() ),
		AES_ENCRYPT( nAmount, encryption_key() ),
		nInsertedFrom, sRecordFrom, nRecordID,0, sRemarks,NOW(),
		0,0
	FROM ww_payroll_partners 
	WHERE user_id = nUserID;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_leave_conversion` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_leave_conversion` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_leave_conversion`(
	IN nUserID INT(11),
	IN nPeriodID INT(11),
	IN nCompID INT(11),	
	IN dtPay DATE,
	IN nDailySalary DECIMAL(12,2),
	IN nEmpTypeID INT(11),
	IN nStatusID INT(11),
	IN nProcTypeID INT(11),
	IN nNoDaysYear DECIMAL(12,2)
    )
BEGIN
	SET @nontax_leave_id = 0;
	SET @taxable_leave_id = 0;
	SET @convertible = 0;
	SET @nontax = 0;
	SET @taxable = 0;
	set @carryover = 0;
	SET @forfeited = 0;
	SET @balance = 0;
	SET @year = '';
	SET @form_id = 0;
	SET @form_code = '';
	
	/*
	SET @cnt = 0;
	SELECT COUNT(`id`) INTO @cnt FROM ww_payroll_leave_conversion 
	WHERE company_id = nCompID AND employment_type_id = nEmpTypeID AND deleted = 0;
	
	if @cnt > 0 then
		SELECT 224, 225,tfb.`form_code`, 
			lvc.`convertible`, lvc.nontax, lvc.taxable, lvc.`carry_over`, lvc.`forfeited`,
			tfb.`previous` + tfb.`current` - ( tfb.`used` + tfb.`used_insert`),
			YEAR(dtPay), lvc.form_id
		INTO @nontax_leave_id, @taxable_leave_id,@form_code, 
			@convertible, @nontax, @taxable, @carryover, @forfeited, @balance,
			@year, @form_id
		FROM ww_payroll_leave_conversion lvc
		LEFT JOIN ww_time_form_balance tfb ON lvc.form_id = tfb.`form_id`
		WHERE lvc.`deleted` = 0
			AND tfb.`year` = YEAR(dtPay)
			AND lvc.`company_id` = nCompID
			AND tfb.user_id = nUserID;	
	else
		SELECT 224, 225,tfb.`form_code`, 
			lvc.`convertible`, lvc.nontax, lvc.taxable, lvc.`carry_over`, lvc.`forfeited`,
			tfb.`previous` + tfb.`current` - ( tfb.`used` + tfb.`used_insert`),
			YEAR(dtPay), lvc.form_id
		INTO @nontax_leave_id, @taxable_leave_id,@form_code, 
			@convertible, @nontax, @taxable, @carryover, @forfeited, @balance,
			@year, @form_id
		FROM ww_payroll_leave_conversion lvc
		LEFT JOIN ww_time_form_balance tfb ON lvc.form_id = tfb.`form_id`
		WHERE lvc.`deleted` = 0
			AND tfb.`year` = YEAR(dtPay)
			AND lvc.`company_id` = nCompID
			AND lvc.`employment_type_id` = nEmpTypeID
			AND tfb.user_id = nUserID;
	end if;
	*/
        
	SELECT 224, 225,tfb.`form_code`, 
		lvc.`convertible`, lvc.nontax, lvc.taxable, lvc.`carry_over`, lvc.`forfeited`,
		tfb.`previous` + tfb.`current` - ( tfb.`forfeited` + tfb.`used` + tfb.`used_insert`),
		YEAR(dtPay), lvc.form_id
	INTO @nontax_leave_id, @taxable_leave_id,@form_code, 
		@convertible, @nontax, @taxable, @carryover, @forfeited, @balance,
		@year, @form_id
	FROM ww_payroll_leave_conversion lvc
	LEFT JOIN ww_time_form_balance tfb ON lvc.form_id = tfb.`form_id`
	WHERE lvc.`deleted` = 0
		AND tfb.`year` = YEAR(dtPay)
		AND lvc.`company_id` = nCompID
		AND FIND_IN_SET(nEmpTypeID,`lvc`.`employment_type_id`)
		AND tfb.user_id = nUserID;
	
	IF @balance > 0 THEN
		IF (nStatusID != 2 AND nStatusID != 5) OR (nCompID = 5 AND nStatusID = 2) THEN -- if not probationary
			SET @unit = 0;
			SET @nNonTax = 0;
			SET @nTaxable = 0;
			set @nToCarryOver = 0;
			set @nRemaining = 0;
			-- set number of unit to convert
			IF @balance > @convertible THEN 
				SET @unit = @convertible;
				set @nRemaining = @balance - @convertible;
				SET @nToCarryOver = @nRemaining;
				/*if @nRemaining > @carryover then
					set @nToCarryOver = @carryover;
				else
					set @nToCarryOver = @nRemaining;
				end if;*/
			ELSE 
				SET @unit = @balance;
			END IF;
			-- set number of nontax and taxable
			IF @unit > @nontax THEN
				SET @nNonTax = @nontax;
				SET @nTaxable = @unit - @nontax;
			ELSE
				SET @nNonTax = @unit;
				SET @nTaxable = 0;
			END IF;
			-- for executive and manager additional deminimis
			set @deminimis = 0;
			set @deminimis_amount = 0;
			if nEmpTypeID = 4 or nEmpTypeID = 9 then
				SELECT  sum(AES_DECRYPT( e.`amount`, encryption_key() ))
				into @deminimis
				FROM
				  ww_payroll_entry_recurring r 
				  LEFT JOIN ww_payroll_entry_recurring_employee e 
				    ON r.`recurring_id` = e.`recurring_id` 
				  LEFT JOIN ww_payroll_transaction t 
				    ON t.`transaction_id` = r.`transaction_id` 
				  LEFT JOIN ww_payroll_partners p 
				    ON p.`user_id` = e.`employee_id` 
				  LEFT JOIN ww_payroll_schedule_rate_divisor d
				    ON p.`payroll_schedule_id` = d.`payroll_schedule_id` AND p.`payroll_rate_type_id` = d.`payroll_rate_type_id`
				WHERE r.`deleted` = 0 AND e.deleted = 0 AND e.`employee_id` = nUserID 
					AND dtPay BETWEEN r.`date_from` AND r.`date_to` and t.transaction_id in (231,232,249); 
					
				SET @deminimis_amount = @deminimis / (nNoDaysYear / 12 );
			end if;
			
			-- INSERT TRANSACTION 
			-- NON TAX
			IF @nNonTax > 0 THEN
				SET @tran_code = '';
				SET @tran_id = 0;
				SET @tran_class_id = 0;
				SET @tran_type_id = 0;
				SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
				INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
				FROM ww_payroll_transaction WHERE transaction_id = @nontax_leave_id;
				
				INSERT INTO `ww_payroll_current_transaction`
					    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
					     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
					     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
					     `created_by`, `deleted`)
				SELECT nPeriodID, nProcTypeID, dtPay, user_id, @tran_id, @tran_class_id,
				     @tran_code, AES_ENCRYPT( @nNonTax, encryption_key() ), 
				     AES_ENCRYPT( ROUND( nDailySalary, 2 ) + @deminimis_amount, encryption_key() ) ,
				     AES_ENCRYPT( ROUND( (@nNonTax * (nDailySalary + @deminimis_amount)), 2 ), encryption_key() ),
				     @tran_type_id, 0,'leave_conversion',0,0,'',NOW(),0,0
				FROM ww_payroll_partners 
				WHERE user_id = nUserID;
			END IF;
			-- TAXABLE
			IF @nTaxable > 0 THEN
				SET @tran_code = '';
				SET @tran_id = 0;
				SET @tran_class_id = 0;
				SET @tran_type_id = 0;
				SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
				INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
				FROM ww_payroll_transaction WHERE transaction_id = @taxable_leave_id;
				
				INSERT INTO `ww_payroll_current_transaction`
					    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
					     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
					     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
					     `created_by`, `deleted`)
				SELECT nPeriodID, nProcTypeID, dtPay, user_id, @tran_id, @tran_class_id,
				     @tran_code, AES_ENCRYPT( @nTaxable, encryption_key() ), 
				     AES_ENCRYPT( ROUND( nDailySalary, 2 ) + @deminimis_amount, encryption_key() ) ,
				     AES_ENCRYPT( ROUND( (@nTaxable * (nDailySalary + @deminimis_amount)), 2 ), encryption_key() ),
				     @tran_type_id, 0,'leave_conversion',0,0,'',NOW(),0,0
				FROM ww_payroll_partners 
				WHERE user_id = nUserID;
			END IF;
			
			UPDATE ww_time_form_balance SET paid_unit = @unit WHERE user_id = nUserID AND form_id = @form_id AND `year` = @year;
			
			if @nToCarryOver > 0 then
			       SELECT COUNT(id) INTO @rec
			       FROM `ww_time_form_balance`
			       WHERE deleted=0 AND user_id=nUserID AND form_id = @form_id AND `year` = YEAR(dtPay)+1;				
				
				if @rec = 0 then
					INSERT INTO `ww_time_form_balance`
					(`year`, `user_id`, `form_id`, `form_code`, `previous`, `period_from`, `period_to`, `period_extension`)
					SELECT YEAR(dtPay)+1, nUserID, @form_id, @form_code, @nToCarryOver, MAKEDATE(YEAR(dtPay)+1,1), LAST_DAY(MAKEDATE(YEAR(dtPay)+1,365)), LAST_DAY(MAKEDATE(YEAR(dtPay)+2,90))
					ON DUPLICATE KEY UPDATE modified_on = NOW();							
				else
					UPDATE `ww_time_form_balance` SET previous = @nToCarryOver WHERE deleted=0 AND user_id=nUserID AND form_id = @form_id AND `year` = YEAR(dtPay)+1;
				end if;
			end if;
		else
		        SELECT COUNT(id) INTO @rec
		        FROM `ww_time_form_balance`
		        WHERE deleted=0 AND user_id=nUserID AND form_id = @form_id AND `year` = YEAR(dtPay)+1;						
		        
		        IF @rec = 0 THEN
				INSERT INTO `ww_time_form_balance`
				(`year`, `user_id`, `form_id`, `form_code`, `previous`, `period_from`, `period_to`, `period_extension`)
				SELECT YEAR(dtPay)+1, nUserID, @form_id, @form_code, @balance, MAKEDATE(YEAR(dtPay)+1,1), LAST_DAY(MAKEDATE(YEAR(dtPay)+1,365)), LAST_DAY(MAKEDATE(YEAR(dtPay)+2,90))
				ON DUPLICATE KEY UPDATE modified_on = NOW();			
			else
				UPDATE `ww_time_form_balance` SET previous = @balance WHERE deleted=0 AND user_id=nUserID AND form_id = @form_id AND `year` = YEAR(dtPay)+1;
			end if;
		END IF;
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_leave_conversion_org` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_leave_conversion_org` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_leave_conversion_org`(
	IN nUserID INT(11),
	IN nPeriodID INT(11),
	IN nCompID INT(11),	
	IN dtPay DATE,
	IN nDailySalary DECIMAL(12,2),
	IN nEmpTypeID INT(11),
	IN nProcTypeID INT(11)
    )
BEGIN
	SET @nontax_leave_id = 0;
	SET @taxable_leave_id = 0;
	SET @convertible = 0;
	SET @nontax = 0;
	SET @taxable = 0;
	SET @forfeited = 0;
	SET @balance = 0;
	SET @year = '';
	SET @form_id = 0;
	
	SELECT lvp.`leave_conversion_period_id`, lvp.nontax_leave_id, lvp.taxable_leave_id, 
		lvc.`convertible`, lvc.nontax, lvc.taxable, lvc.`forfeited`,
		tfb.`previous` + tfb.`current` - ( tfb.`used` + tfb.`used_insert`),
		lvp.`year`, lvp.form_id
	INTO @leave_conversion_period_id, @nontax_leave_id, @taxable_leave_id, 
		@convertible, @nontax, @taxable, @forfeited, @balance,
		@year, @form_id
	FROM ww_payroll_leave_conversion_period lvp
	LEFT JOIN ww_payroll_leave_conversion_period_apply_to lva ON lvp.`leave_conversion_period_id` = lva.`leave_conversion_id`
	LEFT JOIN ww_payroll_leave_conversion lvc ON lvp.form_id = lvc.`form_id`
	LEFT JOIN ww_time_form_balance tfb ON lvp.form_id = tfb.`form_id` AND lvp.`year` = tfb.`year`
	WHERE lvp.`deleted` = 0 AND lva.`deleted` = 0 AND lvc.`deleted` = 0
		AND lvp.`payroll_date` = dtPay
		AND lvc.`company_id` = nCompID
		AND tfb.user_id = nUserID;
	
	IF @balance > 0 THEN
		SET @unit = 0;
		SET @nNonTax = 0;
		SET @nTaxable = 0;
		-- set number of unit to convert
		IF @balance > @convertible THEN 
			SET @unit = @convertible;
		ELSE 
			SET @unit = @balance;
		END IF;
		-- set number of nontax and taxable
		IF @unit > @nontax THEN
			SET @nNonTax = @nontax;
			SET @nTaxable = @unit - @nontax;
		ELSE
			SET @nNonTax = @unit;
			SET @nTaxable = 0;
		END IF;
		
		-- INSERT TRANSACTION 
		-- NON TAX
		IF @nNonTax > 0 THEN
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SET @tran_type_id = 0;
			SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_id = @nontax_leave_id;
			
			INSERT INTO `ww_payroll_current_transaction`
				    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
				     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
				     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
				     `created_by`, `deleted`)
			SELECT nPeriodID, nProcTypeID, dtPay, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT( @nNonTax, encryption_key() ), 
			     AES_ENCRYPT( ROUND( nDailySalary, 2 ), encryption_key() ) ,
			     AES_ENCRYPT( ROUND( (@nNonTax * nDailySalary), 2 ), encryption_key() ),
			     @tran_type_id, 0,'leave_conversion',0,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = nUserID;
		END IF;
		-- TAXABLE
		IF @nTaxable > 0 THEN
			SET @tran_code = '';
			SET @tran_id = 0;
			SET @tran_class_id = 0;
			SET @tran_type_id = 0;
			SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
			INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
			FROM ww_payroll_transaction WHERE transaction_id = @taxable_leave_id;
			
			INSERT INTO `ww_payroll_current_transaction`
				    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
				     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
				     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
				     `created_by`, `deleted`)
			SELECT nPeriodID, nProcTypeID, dtPay, user_id, @tran_id, @tran_class_id,
			     @tran_code, AES_ENCRYPT( @nTaxable, encryption_key() ), 
			     AES_ENCRYPT( ROUND( nDailySalary, 2 ), encryption_key() ) ,
			     AES_ENCRYPT( ROUND( (@nTaxable * nDailySalary), 2 ), encryption_key() ),
			     @tran_type_id, 0,'leave_conversion',0,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = nUserID;
		END IF;
		UPDATE ww_time_form_balance SET paid_unit = @unit WHERE user_id = nUserID AND form_id = @form_id AND `year` = @year;
		UPDATE ww_payroll_leave_conversion_period SET `status` = 2 WHERE payroll_date = dtPay AND `year` = @year AND leave_conversion_period_id = @leave_conversion_period_id;
	END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_loan_payments` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_loan_payments` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_loan_payments`(
	IN puserid INT(11),
	IN rec_id INT(11)
    )
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE pl_loan_id INT(11);
	DECLARE pay_date DATE;
	DECLARE tran_class VARCHAR(32);
	DECLARE amt DECIMAL(12,2);
	DECLARE on_hold INT(11);
	DECLARE loan_pay CURSOR FOR
		SELECT pct.`record_id`, payroll_date, ptc.`transaction_class_code`, 
			AES_DECRYPT( pct.amount, encryption_key()), pct.`on_hold`
		FROM ww_payroll_current_transaction  pct
		INNER JOIN ww_payroll_transaction_class ptc ON pct.`transaction_class_id` = ptc.`transaction_class_id`
		WHERE pct.`deleted` = 0 AND ptc.`transaction_class_code` IN ('LOAN_AMORTIZATION','LOAN_INTEREST') 
			AND pct.`record_id` = rec_id AND pct.`employee_id` = puserid;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	OPEN loan_pay;
	
	myLoop: LOOP
		FETCH loan_pay INTO pl_loan_id, pay_date, tran_class, amt, on_hold;
		
		IF done THEN
		    CLOSE loan_pay;
		    LEAVE myLoop;
		END IF;
		
		SET @nType = 0;
		IF tran_class = 'LOAN_AMORTIZATION' THEN 
			SET @nType = 1;
		END IF;
		IF tran_class = 'LOAN_INTEREST' THEN 
			SET @nType = 2;
		END IF;
		SET @paid = '0';
		SET @dt_paid = '0000-00-00';
		IF on_hold = 0 THEN
			SET @paid = 1;
			SET @dt_paid = pay_date;
		ELSE
			SET @paid = 0;
		END IF;
		
		INSERT INTO ww_payroll_partners_loan_payment(`partner_loan_id`, `payroll_date`, `type`, `amount`, `paid`,`date_paid`)
		VALUES (pl_loan_id, pay_date, @nType, AES_ENCRYPT(amt, encryption_key()), @paid, @dt_paid);
	END LOOP;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_overtime` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_overtime` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_overtime`(
	IN puserid INT(11),
	IN paydate DATE,
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE tran_code VARCHAR(32);
	DECLARE tran_id INT(11);
	DECLARE ot_rate DECIMAL(3,2);
	DECLARE qty DECIMAL(3,2);
	DECLARE tran_type_id INT(11);
	DECLARE rec_id INT(11);
	
	DECLARE overtime CURSOR FOR 
		SELECT p.`transaction_id`, p.`transaction_code`, r.`overtime_rate`, p.`quantity`, t.`transaction_type_id`,p.`record_id`
		FROM ww_time_record_process p
		LEFT JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		LEFT JOIN ww_payroll_overtime_rates r ON p.`transaction_code` = r.`overtime_code` AND u.`company_id` = r.`company_id`
		LEFT JOIN ww_payroll_transaction t ON p.`transaction_id` = t.`transaction_id`
		WHERE r.`deleted` = 0 AND p.`deleted` = 0 AND p.`payroll_date` = paydate AND p.`latefile` = 0 AND p.`user_id` = puserid;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	-- select overtime;
	
	OPEN overtime;
	REPEAT
		FETCH overtime INTO tran_id, tran_code, ot_rate, qty, tran_type_id, rec_id ;
		
		IF NOT done THEN
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, tran_id, 
			     tran_code, AES_ENCRYPT( qty, encryption_key() ), 
			     AES_ENCRYPT( ROUND( ( ( (AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) / 8 ) * ot_rate ),2), encryption_key() ) ,
			     AES_ENCRYPT( ROUND( ( qty * ( ( ( ( AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ) * ot_rate ) ), 2 ), encryption_key() ),
			     tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
	UNTIL done END REPEAT;
    
	CLOSE overtime;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_overtime_lf` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_overtime_lf` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_overtime_lf`(
	IN puserid INT(11),
	IN paydate DATE,
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE tran_code VARCHAR(32);
	DECLARE ot_rate DECIMAL(3,2);
	DECLARE qty DECIMAL(3,2);
	DECLARE tran_type_id INT(11);
	DECLARE rec_id INT(11);
	
	DECLARE overtime CURSOR FOR 
		SELECT p.`transaction_code`, r.`overtime_rate`, p.`quantity`, t.`transaction_type_id`,p.`record_id`
		FROM ww_time_record_process p
		LEFT JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		LEFT JOIN ww_payroll_overtime_rates r ON p.`transaction_code` = r.`overtime_code` AND u.`company_id` = r.`company_id`
		LEFT JOIN ww_payroll_transaction t ON p.`transaction_id` = t.`transaction_id`
		WHERE r.`deleted` = 0 AND p.`deleted` = 0 AND p.`payroll_date` = paydate AND p.`latefile` = 1 AND p.`user_id` = puserid;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	-- select overtime;
	
	OPEN overtime;
	REPEAT
		FETCH overtime INTO tran_code, ot_rate, qty, tran_type_id, rec_id ;
		
		IF NOT done THEN
			
			SET @tran_code = '';
			SET @tran_id = 0;
			SELECT transaction_code, transaction_id
			INTO @tran_code, @tran_id
			FROM ww_payroll_transaction WHERE transaction_code = CONCAT(tran_code,'_LF');
			
			INSERT INTO `ww_payroll_current_transaction`
			    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`,
			     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
			     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
			     `created_by`, `deleted`)
			SELECT periodid, processing_type_id, paydate, user_id, @tran_id, 
			     @tran_code, AES_ENCRYPT( qty, encryption_key() ), 
			     AES_ENCRYPT( ROUND( ( ( (AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) / 8 ) * ot_rate ),2), encryption_key() ) ,
			     AES_ENCRYPT( ROUND( ( qty * ( ( ( ( AES_DECRYPT(`salary`, encryption_key()) / ( total_year_days /12 ) ) ) / 8 ) * ot_rate ) ), 2 ), encryption_key() ),
			     tran_type_id, 0,'ww_time_record_process',rec_id,0,'',NOW(),0,0
			FROM ww_payroll_partners 
			WHERE user_id = puserid;
		END IF;
	UNTIL done END REPEAT;
    
	CLOSE overtime;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_period` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_period` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_period`( IN periodid INT(11), IN sensID VARCHAR(30) )
BEGIN
	DECLARE payroll_period_done TINYINT(11) DEFAULT 0;
	DECLARE rec INT(11) DEFAULT 0;
	
	DECLARE nproc_type_id INT(11) DEFAULT 0;
	DECLARE capply_to_id INT(11) DEFAULT '';
	DECLARE npay_sched_id INT(11) DEFAULT 0;
	DECLARE dpaydate DATE;
	DECLARE ddtFrom DATE;
	DECLARE ddtTo DATE;
	DECLARE capply_to VARCHAR(16) DEFAULT '';
	DECLARE napply_id INT(11) DEFAULT 0;
	
	DECLARE payroll_period CURSOR FOR
	SELECT p.`period_processing_type_id`, p.`apply_to_id`, p.`payroll_schedule_id`, p.`payroll_date`, p.`date_from`, p.`date_to`,
	       a.`apply_to`, a.`id`
	FROM ww_payroll_period p, ww_payroll_period_apply_to a
	WHERE a.`payroll_period_id` = p.`payroll_period_id` AND p.`payroll_period_id` = periodid;
	 
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET payroll_period_done = 1;
	
	
	OPEN payroll_period;
	
	REPEAT
		FETCH payroll_period INTO nproc_type_id, capply_to_id, npay_sched_id, dpaydate, ddtFrom, ddtTo, capply_to, napply_id;
	
		IF NOT payroll_period_done THEN
			SET rec = rec + 1;
			SET @proc_type_id = nproc_type_id;
			SET @apply_to_id  = capply_to_id;
			SET @pay_sched_id = npay_sched_id;
			SET @paydate      = dpaydate;
			SET @dtFrom       = ddtFrom;
			SET @dtTo         = ddtTo;
			SET @apply_to     = capply_to;
			SET @apply_id     = napply_id;
			
			IF @proc_type_id = 1 THEN
				BEGIN
					DECLARE ppdone TINYINT(1) DEFAULT 0;
					DECLARE emp_id INT(11);
					DECLARE onhold INT(11);
					DECLARE employee CURSOR FOR
						SELECT DISTINCT a.`user_id`, a.`on_hold`
						FROM ww_payroll_partners a
						INNER JOIN ww_users b ON a.`user_id` = b.`user_id`
						INNER JOIN ww_partners c ON a.`user_id` = c.`user_id`
						INNER JOIN ww_users_profile d ON d.`user_id` = a.`user_id`
						LEFT JOIN ww_time_record_summary e ON a.`user_id` = e.`user_id`
						LEFT JOIN ww_time_period f ON f.`company_id` = d.`company_id` -- AND IF(a.`non_swipe`=1, 1, f.`payroll_date` = e.`payroll_date`)
						WHERE a.`deleted` = 0 AND a.`payroll_schedule_id` = @pay_sched_id 
						AND b.`deleted` = 0 -- AND b.`active` = 1 
						AND IF(sensID != '',FIND_IN_SET(a.sensitivity,sensID), 1 )
						AND c.`effectivity_date` <= f.`date_to` 
						AND ( IFNULL(c.`resigned_date`,'0000-00-00') = '0000-00-00' OR ( c.`resigned_date` NOT BETWEEN @dtFrom AND @dtTo AND c.resigned_date > @dtFrom ) )
						AND f.`payroll_date` = @paydate AND f.`deleted` = 0 -- AND a.`on_hold` = 0 
						AND IF(@apply_to_id  = 1, d.`user_id` IN (@apply_to),
							IF(@apply_to_id = 2, a.`company_id` IN (@apply_to),
								IF(@apply_to_id = 3, d.`division_id` IN (@apply_to),
									IF(@apply_to_id = 4, d.`department_id` IN (@apply_to),
										IF(@apply_to_id = 5, d.`branch_id` IN (@apply_to),0)
										)
									)
								)
							);
					DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET ppdone = 1;
					
					OPEN employee;
					REPEAT
						FETCH employee INTO emp_id, onhold;
							DELETE FROM ww_payroll_current_transaction WHERE `employee_id` = emp_id AND `period_id` = periodid;
							IF onhold = 0 and emp_id > 0 THEN
								-- get time period
								-- SET @nCompanyID = 0;
								-- SET @nPeriodID = 0;
								-- SELECT company_id INTO @nCompanyID FROM ww_users_profile WHERE user_id = emp_id;
								-- SELECT period_id INTO @nPeriodID FROM ww_time_period WHERE company_id = @nCompanyID AND payroll_date = @paydate AND deleted = 0 LIMIT 1;
								-- process remaining attendance
								-- CALL `sp_time_period_process_latefile`( @nPeriodID, emp_id );	
															
								CALL sp_payroll_period_process(periodid, emp_id);								
							END IF;
							SET emp_id = 0;
						UNTIL ppdone END REPEAT;
				
					CLOSE employee;
				END;
			ELSEIF @proc_type_id = 2 THEN
				BEGIN
					DECLARE ppdone TINYINT(1) DEFAULT 0;
					DECLARE emp_id INT(11);
					DECLARE onhold INT(11);
					DECLARE employee CURSOR FOR
						SELECT DISTINCT a.`user_id`, a.`on_hold`
						FROM ww_payroll_partners a
						INNER JOIN ww_users b ON a.`user_id` = b.`user_id`
						INNER JOIN ww_partners c ON a.`user_id` = c.`user_id`
						INNER JOIN ww_users_profile d ON d.`user_id` = a.`user_id`
						-- LEFT JOIN ww_time_record_summary e ON a.`user_id` = e.`user_id`
						-- LEFT JOIN ww_time_period f ON e.`payroll_date` = f.`payroll_date` AND f.`company_id` = d.`company_id`
						WHERE a.`deleted` = 0 AND a.`payroll_schedule_id` = @pay_sched_id 
						AND b.`deleted` = 0 -- AND b.`active` = 1 
						AND IF(sensID != '',FIND_IN_SET(a.sensitivity,sensID), 1 )
						-- AND c.`effectivity_date` <= f.`date_to` 
						AND ( IFNULL(c.`resigned_date`,'0000-00-00') = '0000-00-00' OR ( c.`resigned_date` NOT BETWEEN @dtFrom AND @dtTo AND c.resigned_date > @dtFrom ) )
						-- AND f.`payroll_date` = @paydate AND f.`deleted` = 0 -- AND a.`on_hold` = 0 
						AND IF(@apply_to_id  = 1, d.`user_id` IN (@apply_to),
							IF(@apply_to_id = 2, a.`company_id` IN (@apply_to),
								IF(@apply_to_id = 3, d.`division_id` IN (@apply_to),
									IF(@apply_to_id = 4, d.`department_id` IN (@apply_to),
										IF(@apply_to_id = 5, d.`branch_id` IN (@apply_to),0)
										)
									)
								)
							);						
					DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET ppdone = 1;
					
					OPEN employee;
					REPEAT
						FETCH employee INTO emp_id, onhold;
							DELETE FROM ww_payroll_current_transaction WHERE `employee_id` = emp_id AND `period_id` = periodid;
							IF onhold = 0 THEN
								CALL sp_payroll_period_special_process(periodid, emp_id);
							END IF;
							SET emp_id = 0;
						UNTIL ppdone END REPEAT;
				
					CLOSE employee;
				END;				
			ELSEIF  @proc_type_id = 3 THEN
				BEGIN
					DECLARE ppdone TINYINT(1) DEFAULT 0;
					DECLARE emp_id INT(11);
					DECLARE res_date DATE;
					DECLARE employee CURSOR FOR
						SELECT DISTINCT a.`user_id`, c.resigned_date
						FROM ww_payroll_partners a
						INNER JOIN ww_users b ON a.`user_id` = b.`user_id`
						INNER JOIN ww_partners c ON a.`user_id` = c.`user_id`
						INNER JOIN ww_users_profile d ON d.`user_id` = a.`user_id`
						WHERE a.`deleted` = 0 AND a.`payroll_schedule_id` = @pay_sched_id 
						AND b.`deleted` = 0 AND c.`effectivity_date` <= @dtTo 
						AND IF(sensID != '',FIND_IN_SET(a.sensitivity,sensID), 1 )
						AND c.`resigned_date` <= @dtTo 
						AND IF(@apply_to_id  = 1, d.`user_id` IN (@apply_to),
							IF(@apply_to_id = 2, a.`company_id` IN (@apply_to),
								IF(@apply_to_id = 3, d.`division_id` IN (@apply_to),
									IF(@apply_to_id = 4, d.`department_id` IN (@apply_to),
										IF(@apply_to_id = 5, d.`branch_id` IN (@apply_to),0)
										)
									)
								)
							);
					DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET ppdone = 1;
					
					OPEN employee;
					myLoop: LOOP
						FETCH employee INTO emp_id, res_date;
						
						IF ppdone THEN
						    CLOSE employee;
						    LEAVE myLoop;
						END IF;
						
						-- for Final Pay / Last Pay
						-- set tax computation to Annualized
						UPDATE ww_payroll_partners SET tax_mode = 2, remain = 1 WHERE user_id = emp_id;
						DELETE FROM ww_payroll_current_transaction WHERE `employee_id` = emp_id AND `period_id` = periodid;
						
						-- get time period
						SET @nCompanyID = 0;
						SET @nPeriodID = 0;
						SELECT company_id INTO @nCompanyID FROM ww_users_profile WHERE user_id = emp_id;
						SELECT period_id INTO @nPeriodID FROM ww_time_period WHERE company_id = @nCompanyID AND payroll_date = @paydate AND deleted = 0 LIMIT 1;
						
						-- original record of time period
						SET @dtTo = '0000-00-00';
						SET @dtCutOff = '0000-00-00';
						
						-- SELECT date_to, cutoff INTO @dtTo, @dtCutOff FROM ww_time_period WHERE period_id = @nPeriodID;
						-- update covered period and cutoff
						-- UPDATE ww_time_period SET date_to = res_date, cutoff = DATE_ADD( res_date, INTERVAL 1 DAY ) WHERE period_id = @nPeriodID;
						
						-- process remaining attendance
						IF @nPeriodID > 0 THEN
							CALL `sp_time_period_process_latefile`( @nPeriodID, emp_id );
							INSERT INTO ww_system_messages (msg_code)
							VALUES (CONCAT(@nPeriodID,', ',emp_id));
							
							CALL sp_time_period_process( @nPeriodID, emp_id );
							INSERT INTO ww_system_messages (msg_code)
							VALUES (CONCAT('timeperiodprocess',@nPeriodID,', ',emp_id));
						end if;
						
						-- return to original period
						-- UPDATE ww_time_period SET date_to = @dtTo , cutoff = @dtCutOff WHERE period_id = @nPeriodID;
						-- final pay processing
						CALL sp_payroll_final_pay(periodid, emp_id);
						SET emp_id = 0;
					END LOOP;
				END;
			ELSEIF @proc_type_id = 4 THEN
				BEGIN
					DECLARE ppdone TINYINT(1) DEFAULT 0;
					DECLARE emp_id INT(11);
					DECLARE onhold INT(11);
					DECLARE employee CURSOR FOR
						SELECT DISTINCT a.`user_id`, a.`on_hold`
						FROM ww_payroll_partners a
						INNER JOIN ww_users b ON a.`user_id` = b.`user_id`
						INNER JOIN ww_partners c ON a.`user_id` = c.`user_id`
						INNER JOIN ww_users_profile d ON d.`user_id` = a.`user_id`
						-- LEFT JOIN ww_time_record_summary e ON a.`user_id` = e.`user_id`
						-- LEFT JOIN ww_time_period f ON e.`payroll_date` = f.`payroll_date` AND f.`company_id` = d.`company_id`
						WHERE a.`deleted` = 0 AND a.`payroll_schedule_id` = @pay_sched_id 
						AND b.`deleted` = 0 -- AND b.`active` = 1 
						AND IF(sensID != '',FIND_IN_SET(a.sensitivity,sensID), 1 )
						-- AND c.`effectivity_date` <= f.`date_to` 
						AND ( IFNULL(c.`resigned_date`,'0000-00-00') = '0000-00-00' OR ( c.`resigned_date` NOT BETWEEN @dtFrom AND @dtTo AND c.resigned_date > @dtFrom ) )
						-- AND f.`payroll_date` = @paydate AND f.`deleted` = 0 -- AND a.`on_hold` = 0 
						AND IF(@apply_to_id  = 1, d.`user_id` IN (@apply_to),
							IF(@apply_to_id = 2, a.`company_id` IN (@apply_to),
								IF(@apply_to_id = 3, d.`division_id` IN (@apply_to),
									IF(@apply_to_id = 4, d.`department_id` IN (@apply_to),
										IF(@apply_to_id = 5, d.`branch_id` IN (@apply_to),0)
										)
									)
								)
							);
					DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET ppdone = 1;
					
					OPEN employee;
					REPEAT
						FETCH employee INTO emp_id, onhold;
							DELETE FROM ww_payroll_current_transaction WHERE `employee_id` = emp_id AND `period_id` = periodid;
							IF onhold = 0 THEN
								CALL sp_payroll_period_process_leave_conversion(periodid, emp_id);
							END IF;
							SET emp_id = 0;
						UNTIL ppdone END REPEAT;
				
					CLOSE employee;
				END;				
			END IF;
			
			-- update period log
			UPDATE ww_payroll_period_apply_to SET last_processed = NOW() WHERE `id` = @apply_id LIMIT 1;
			UPDATE ww_payroll_period SET last_processed = NOW() WHERE payroll_period_id = periodid LIMIT 1;
			
		END IF;
        
	UNTIL payroll_period_done END REPEAT;
	
	CLOSE payroll_period;		
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_period_process` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_period_process` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_period_process`(IN periodid INT(11), IN puserid INT(11))
BEGIN
	
	
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
	    -- ERROR
	    ROLLBACK;
	END;
    
	START TRANSACTION;
	
	-- employee info
	SET @sSSS_week = '';
	SET @nStatus = '';
	SET @nEmp_type_id = '';
	SET @dtEff = '';
	SET @dtRes = '';
	SET @nShift = '';
	SET @nTaxcode = '';
	SET @nPayrate = '';
	SET @nPaysched = '';
	SET @nTotal_year_days = '';
	SET @nSalary = '';
	SET @nMin_takehome = '';
	SET @sBank_acct = '';
	SET @nPayLocation = '';
	SET @sSSS_no = '';
	SET @nSSS_mode = '';
	SET @sSSS_week = '';
	SET @nSSS_amount = '';
	SET @sHDMF_no = '';
	SET @nHDMF_mode = '';
	SET @sHDMF_week = '';
	SET @nHDMF_amount = '';
	SET @sPHIC_no = '';
	SET @nPHIC_mode = '';
	SET @sPHIC_week = '';
	SET @nPHIC_amount = '';
	SET @sEcola_week = '';
	SET @sTIN = '';
	SET @nTax_mode = '';
	SET @nTax_amount = '';
	SET @sTax_week = '';
	SET @nSensitivity = '';
	SET @nDivisor = '';
	SET @nCompany = '';
	SET @nGroup = '';
	SET @nDivision = '';
	SET @nDepartment = '';
	SET @nSection = '';
	SET @nPosition = '';
	SET @nProject = '';
	SET @nReports_to = '';
	SET @nJobtitle = '';
	SET @nLocation = '';
	SET @nRemain = '';
	SET @nAttendanceBase = '';
	SET @nHold = '';
	SET @nPaymentType = '';	
	-- period info
	SET @period_status_id = 0;
	SET @payroll_date = '';
	SET @date_from = '';
	SET @date_to = '';
	SET @date_closing = '';
	SET @sweek = '';
	SET @payroll_schedule_id = 0;
	SET @period_processing_type_id = 0;
	SET @apply_to_id = 0;
	
	
	
	-- period info
	SELECT `period_status_id`, `payroll_date`, `date_from`, `date_to`, `date_closing`, `week`, 
		`payroll_schedule_id`, `period_processing_type_id`, `apply_to_id`
	INTO @period_status_id, @payroll_date, @date_from, @date_to, @date_closing, @sweek, 
		@payroll_schedule_id, @period_processing_type_id, @apply_to_id
	FROM ww_payroll_period WHERE payroll_period_id = periodid AND deleted = 0;
	
	-- get employee info	
	CALL `sp_payroll_employee_info`(puserid, 
		@nStatus, @nEmp_type_id, @dtEff, @dtRes, @nShift, 
		@nTaxcode, @nPayrate, @nPaysched, @nTotal_year_days, @nSalary, 
		@nMin_takehome, @sBank_acct, @nPayLocation, @sSSS_no, @nSSS_mode, 
		@sSSS_week, @nSSS_amount, @sHDMF_no, @nHDMF_mode, @sHDMF_week, 
		@nHDMF_amount, @sPHIC_no, @nPHIC_mode, @sPHIC_week, @nPHIC_amount, 
		@sEcola_week, @sTIN, @nTax_mode, @nTax_amount, @sTax_week, @nSensitivity, @nDivisor, 
		@nCompany, @nGroup, @nDivision, @nDepartment, @nSection, @nPosition, @nProject, @nReports_to,
		@nJobtitle, @nLocation, @nRemain, @nAttendanceBase, @nHold, @nPaymentType);
	
	-- check if has open transaction
	SET @id = 0;
	SELECT COUNT(`id`) INTO @id FROM ww_payroll_current_transaction 
	WHERE employee_id = puserid AND payroll_date < @payroll_date AND deleted = 0;
	
	-- INSERT INTO `logtable` (`log`) VALUES (puserid);
	
	IF @id > 0 THEN
		-- this will raised error There's still an open transaction kindly closed it first
		BEGIN
		-- ERROR
			/*
			SIGNAL SQLSTATE VALUE '99999'
			SET MESSAGE_TEXT = "There's still an open transaction kindly closed it first.";
			select MESSAGE_TEXT;*/
			DECLARE my_error CONDITION FOR SQLSTATE '22012';
			-- SIGNAL my_error;
		ROLLBACK;
		END;
		
	END IF;
	
	-- check if has unclosed deduction
	
	-- remaining period
	
	-- check if last payroll then set tax computation to Annualize
	
	-- remove ww_payroll_current_transaction with the same periodid (reprocessing)
	IF @period_status_id != 3 THEN
		DELETE FROM ww_payroll_current_transaction WHERE `employee_id` = puserid AND `period_id` = periodid;
	END IF;
	-- compute SALARY
	
	-- monthly
	IF @nPayrate = 2 THEN
		SET @PeriodSalary = 0;
		CALL sp_payroll_get_salary_monthly(puserid, @payroll_date, periodid, @period_processing_type_id );
		SET @PeriodSalary = @nSalary / @nDivisor;
		SET @DailySalary = @nSalary / ( @nTotal_year_days / 12 );
	END IF;
	-- weekly
	
	IF @nPayrate = 6 THEN
		SET @DailySalary = 0;		
		-- insert salary 
		CALL sp_payroll_get_salary_weekly(puserid, @payroll_date, periodid, @period_processing_type_id );
		SET @DailySalary = @nSalary;
	END IF;
		
	IF @nAttendanceBase = 1 THEN		
		IF @nPayrate != 6 THEN
			CALL `sp_payroll_get_absences`( puserid, @payroll_date, periodid, @period_processing_type_id );
			CALL `sp_payroll_get_lates`( puserid, @payroll_date, periodid, @period_processing_type_id );
			CALL `sp_payroll_get_undertime`( puserid, @payroll_date, periodid, @period_processing_type_id );
			
			-- latefile = 1
			CALL `sp_payroll_get_absences_adj`( puserid, @payroll_date, periodid, @period_processing_type_id );
			CALL `sp_payroll_get_lates_adj`( puserid, @payroll_date, periodid, @period_processing_type_id );
			CALL `sp_payroll_get_undertime_adj`( puserid, @payroll_date, periodid, @period_processing_type_id );
			-- compute attendance deduction
			CALL `sp_payroll_get_lwop`( puserid, @payroll_date, periodid, @period_processing_type_id, @DailySalary);
			-- CALL `sp_payroll_get_lwop_adj`( puserid, @payroll_date, periodid, @period_processing_type_id );			
		END IF;
	END IF;
	
		
	IF @nAttendanceBase = 1 THEN 
		-- compute overtime
		CALL sp_payroll_get_overtime( puserid, @payroll_date, periodid, @period_processing_type_id );
		
		-- compute late approve overtime
		CALL sp_payroll_get_overtime_adj( puserid, @payroll_date, periodid, @period_processing_type_id );	
		
		-- compute leave Adjustment
		CALL sp_payroll_get_leave_adj( puserid, @payroll_date, periodid, @period_processing_type_id );	
		
	END IF;
	
	-- compute regular nd
	CALL `sp_payroll_get_nd`( puserid, @payroll_date, periodid, @period_processing_type_id );
	
	-- compute loan amortization
	CALL sp_payroll_get_loan_amortization( puserid, periodid, @payroll_date, @period_processing_type_id, @sweek );
	
	-- compute loan interest
	CALL sp_payroll_get_loan_interest( puserid, periodid, @payroll_date, @period_processing_type_id, @sweek );
	
	-- compute recurring
	CALL sp_payroll_get_recurring(puserid, periodid, @sweek, @payroll_date, @period_processing_type_id);
	
	-- compute batch entry
	CALL sp_payroll_get_batch(puserid, periodid, @payroll_date, @period_processing_type_id);
	
	-- compute leave conversion
	-- CALL sp_payroll_leave_conversion(puserid, periodid, @nCompany, @payroll_date, @DailySalary, @nEmp_type_id, @period_processing_type_id);
	
	-- compute bonus
	CALL sp_payroll_get_bonus(puserid, periodid, @payroll_date, @nSalary, @period_processing_type_id);
	-- compute ecola
	-- call sp_payroll_get_ecola();
	SET @Not_MinWage = 0;
	SET @min_wage_amt = 0;
	SET @ecola_amt = 0;
	
	SELECT `min_wage_amt`, `ecola_amt` 
	INTO @min_wage_amt, @ecola_amt
	FROM ww_users_location WHERE `location_id` = @nPayLocation AND `deleted` = 0;
	
	IF @min_wage_amt >= @DailySalary THEN
		-- CALL sp_payroll_get_ecola(puserid, periodid, @payroll_date, @ecola_amt, @period_processing_type_id);
		SET @Not_MinWage = 1;
	END IF;
	-- compute/update amount = base_on_earning
	SET @cur_tran_id = 0;
	SELECT `id` INTO @cur_tran_id
	FROM ww_payroll_current_transaction WHERE AES_DECRYPT( `amount`, encryption_key() ) = 'base_on_earning' 
		AND `employee_id` = puserid AND `payroll_date` = @payroll_date AND `deleted` = 0;
	IF @cur_tran_id > 0 THEN
		SET @result = 0.00;
		CALL sp_payroll_get_transaction(puserid,periodid,'1,5',1,1,1,0,@result);
		UPDATE ww_payroll_current_transaction SET `unit_rate` = AES_ENCRYPT( @result, encryption_key() ), `amount` = AES_ENCRYPT( @result, encryption_key() )
			WHERE `id` = @cur_tran_id;
	END IF;
	
	-- compute contributions
	CALL sp_payroll_get_sss_contribution( periodid, @payroll_date, @payroll_schedule_id, @period_processing_type_id, @sweek, puserid, @nSalary, @nSSS_mode, @sSSS_week );
	CALL sp_payroll_get_phic_contribution( periodid, @payroll_date, @payroll_schedule_id, @period_processing_type_id, @sweek, puserid, @nSalary, @nPHIC_mode, @sPHIC_week );
	CALL sp_payroll_get_hdmf_contribution( periodid, @payroll_date, @payroll_schedule_id, @period_processing_type_id, @sweek, puserid, @nSalary, @nHDMF_mode, @nHDMF_amount, @sHDMF_week );
	
	-- compute wtax
	-- Based on Tax Table
	IF @Not_MinWage = 0 THEN
		
		IF @nTax_mode = 1 THEN
			CALL sp_payroll_get_tax_table( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTaxcode );
		-- Annualized
		ELSEIF @nTax_mode = 2 THEN
			CALL sp_payroll_get_tax_annualize( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTaxcode, @nRemain );
		
		-- Manual
		ELSEIF @nTax_mode = 3 THEN	
			IF @nTax_amount > 0 THEN
				CALL sp_payroll_get_tax_manual( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTax_amount );
			END IF;
		END IF;
		/*
		-- Cummulative
		elseif @nTax_mode = 4 THEN
		
		else
		
		end if;
		*/
	END IF;
	
	-- compute netpay
	CALL sp_payroll_get_netpay( periodid, puserid, @payroll_date, @period_processing_type_id ) ;
	
	-- update payroll details
	UPDATE ww_payroll_current_transaction a, ww_users_profile b SET 
		a.company_id = @nCompany,
		a.branch_id = b.branch_id,
		a.group_id = @nGroup,
		a.department_id = @nDepartment,
		a.section_id = @nSection,
		a.division_id = @nDivision,
		a.position_id = @nPosition,
		a.location_id = @nLocation,
		a.payment_type_id = @nPaymentType,
		a.minwageflag = @Not_MinWage
	WHERE a.employee_id = puserid AND a.employee_id = b.user_id AND a.period_id = periodid AND a.payroll_date = @payroll_date;
	
	UPDATE ww_payroll_period SET `period_status_id` = 2 WHERE payroll_period_id = periodid ;
	COMMIT;
	
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_period_process_leave_conversion` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_period_process_leave_conversion` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_period_process_leave_conversion`(IN periodid INT(11), IN puserid INT(11))
BEGIN
	
	
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
	    -- ERROR
	    ROLLBACK;
	END;
    
	START TRANSACTION;
	
	-- employee info
	SET @sSSS_week = '';
	SET @nStatus = '';
	SET @nEmp_type_id = '';
	SET @dtEff = '';
	SET @dtRes = '';
	SET @nShift = '';
	SET @nTaxcode = '';
	SET @nPayrate = '';
	SET @nPaysched = '';
	SET @nTotal_year_days = '';
	SET @nSalary = '';
	SET @nMin_takehome = '';
	SET @sBank_acct = '';
	SET @nPayLocation = '';
	SET @sSSS_no = '';
	SET @nSSS_mode = '';
	SET @sSSS_week = '';
	SET @nSSS_amount = '';
	SET @sHDMF_no = '';
	SET @nHDMF_mode = '';
	SET @sHDMF_week = '';
	SET @nHDMF_amount = '';
	SET @sPHIC_no = '';
	SET @nPHIC_mode = '';
	SET @sPHIC_week = '';
	SET @nPHIC_amount = '';
	SET @sEcola_week = '';
	SET @sTIN = '';
	SET @nTax_mode = '';
	SET @nTax_amount = '';
	SET @sTax_week = '';
	SET @nSensitivity = '';
	SET @nDivisor = '';
	SET @nCompany = '';
	SET @nGroup = '';
	SET @nDivision = '';
	SET @nDepartment = '';
	SET @nSection = '';
	SET @nPosition = '';
	SET @nProject = '';
	SET @nReports_to = '';
	SET @nJobtitle = '';
	SET @nLocation = '';
	SET @nRemain = '';
	SET @nAttendanceBase = '';
	SET @nHold = '';
	SET @nPaymentType = '';	
	-- period info
	SET @period_status_id = 0;
	SET @payroll_date = '';
	SET @date_from = '';
	SET @date_to = '';
	SET @date_closing = '';
	SET @sweek = '';
	SET @payroll_schedule_id = 0;
	SET @period_processing_type_id = 0;
	SET @apply_to_id = 0;
	
	
	
	-- period info
	SELECT `period_status_id`, `payroll_date`, `date_from`, `date_to`, `date_closing`, `week`, 
		`payroll_schedule_id`, `period_processing_type_id`, `apply_to_id`
	INTO @period_status_id, @payroll_date, @date_from, @date_to, @date_closing, @sweek, 
		@payroll_schedule_id, @period_processing_type_id, @apply_to_id
	FROM ww_payroll_period WHERE payroll_period_id = periodid AND deleted = 0;
	
	-- get employee info	
	CALL `sp_payroll_employee_info`(puserid, 
		@nStatus, @nEmp_type_id, @dtEff, @dtRes, @nShift, 
		@nTaxcode, @nPayrate, @nPaysched, @nTotal_year_days, @nSalary, 
		@nMin_takehome, @sBank_acct, @nPayLocation, @sSSS_no, @nSSS_mode, 
		@sSSS_week, @nSSS_amount, @sHDMF_no, @nHDMF_mode, @sHDMF_week, 
		@nHDMF_amount, @sPHIC_no, @nPHIC_mode, @sPHIC_week, @nPHIC_amount, 
		@sEcola_week, @sTIN, @nTax_mode, @nTax_amount, @sTax_week, @nSensitivity, @nDivisor, 
		@nCompany, @nGroup, @nDivision, @nDepartment, @nSection, @nPosition, @nProject, @nReports_to,
		@nJobtitle, @nLocation, @nRemain, @nAttendanceBase, @nHold, @nPaymentType);
	
	-- check if has open transaction
	SET @id = 0;
	SELECT COUNT(`id`) INTO @id FROM ww_payroll_current_transaction 
	WHERE employee_id = puserid AND payroll_date < @payroll_date AND deleted = 0;
	
	IF @id > 0 THEN
		-- this will raised error There's still an open transaction kindly closed it first
		BEGIN
		-- ERROR
			/*
			SIGNAL SQLSTATE VALUE '99999'
			SET MESSAGE_TEXT = "There's still an open transaction kindly closed it first.";
			select MESSAGE_TEXT;*/
			DECLARE my_error CONDITION FOR SQLSTATE '22012';
			-- SIGNAL my_error;
		ROLLBACK;
		END;
		
	END IF;
	
	-- check if has unclosed deduction
	
	-- remaining period
	
	-- check if last payroll then set tax computation to Annualize
	
	-- remove ww_payroll_current_transaction with the same periodid (reprocessing)
	IF @period_status_id != 3 THEN
		DELETE FROM ww_payroll_current_transaction WHERE `employee_id` = puserid AND `period_id` = periodid;
	END IF;
	-- compute SALARY
	
	-- monthly
	IF @nPayrate = 2 THEN
		SET @PeriodSalary = 0;
		-- CALL sp_payroll_get_salary_monthly(puserid, @payroll_date, periodid, @period_processing_type_id );
		SET @PeriodSalary = @nSalary / @nDivisor;
		SET @DailySalary = @nSalary / ( @nTotal_year_days / 12 );
	END IF;
	-- weekly
	
	IF @nPayrate = 6 THEN
		SET @DailySalary = 0;		
		-- insert salary 
		-- CALL sp_payroll_get_salary_weekly(puserid, @payroll_date, periodid, @period_processing_type_id );
		SET @DailySalary = @nSalary;
	END IF;
	
	-- compute recurring
	-- CALL sp_payroll_get_recurring(puserid, periodid, @sweek, @payroll_date, @period_processing_type_id);
	
	-- compute batch entry
	CALL sp_payroll_get_batch(puserid, periodid, @payroll_date, @period_processing_type_id);
	
	-- compute leave conversion
	CALL sp_payroll_leave_conversion(puserid, periodid, @nCompany, @payroll_date, @DailySalary, @nEmp_type_id, @nStatus, @period_processing_type_id, @nTotal_year_days);
	
	SET @Tax_Bonus = 0;	
	-- compute bonus
	CALL sp_payroll_get_bonus(puserid, periodid, @payroll_date, @nSalary, @period_processing_type_id);
	
	-- SELECT @Tax_Bonus;
	
	if @Tax_Bonus > 0 and @nEmp_type_id IN (1,2,3,4,9,10,16,17) then
		set @nTax_mode = 5; -- for bonus taxable		
	elseIF @Tax_Bonus > 0 AND @nEmp_type_id IN (5,6,18) THEN
		SET @nTax_mode = 5; -- for bonus taxable				
	end if;
	-- compute ecola
	-- call sp_payroll_get_ecola();
	SET @Not_MinWage = 0;
	SET @min_wage_amt = 0;
	SET @ecola_amt = 0;
	
	SELECT `min_wage_amt`, `ecola_amt` 
	INTO @min_wage_amt, @ecola_amt
	FROM ww_users_location WHERE `location_id` = @nPayLocation AND `deleted` = 0;
	
	IF @min_wage_amt >= @DailySalary THEN
		-- CALL sp_payroll_get_ecola(puserid, periodid, @payroll_date, @ecola_amt, @period_processing_type_id);
		SET @Not_MinWage = 1;
	END IF;
	-- compute/update amount = base_on_earning
	SET @cur_tran_id = 0;
	SELECT `id` INTO @cur_tran_id
	FROM ww_payroll_current_transaction WHERE AES_DECRYPT( `amount`, encryption_key() ) = 'base_on_earning' 
		AND `employee_id` = puserid AND `payroll_date` = @payroll_date AND `deleted` = 0;
	IF @cur_tran_id > 0 THEN
		SET @result = 0.00;
		CALL sp_payroll_get_transaction(puserid,periodid,'1,5',1,1,1,0,@result);
		UPDATE ww_payroll_current_transaction SET `unit_rate` = AES_ENCRYPT( @result, encryption_key() ), `amount` = AES_ENCRYPT( @result, encryption_key() )
			WHERE `id` = @cur_tran_id;
	END IF;
	
	IF @Not_MinWage = 0 THEN
		
		IF @nTax_mode = 1 THEN
			CALL sp_payroll_get_tax_table( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTaxcode );
		-- Annualized
		ELSEIF @nTax_mode = 2 THEN
			CALL sp_payroll_get_tax_annualize( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTaxcode, @nRemain );
		
		-- Manual
		ELSEIF @nTax_mode = 3 THEN	
			IF @nTax_amount > 0 THEN
				CALL sp_payroll_get_tax_manual( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTax_amount );
			END IF;
		ELSEIF @nTax_mode = 5 THEN
			CALL sp_payroll_get_tax_bonus( puserid, periodid, @payroll_date, @period_processing_type_id );
		ELSEIF @nTax_mode = 6 THEN	
			CALL sp_payroll_get_tax_bonus_rf( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTaxcode, @Tax_Bonus );
		END IF;
	END IF;
		
	-- compute netpay
	CALL sp_payroll_get_netpay( periodid, puserid, @payroll_date, @period_processing_type_id ) ;
	-- update payroll details
	UPDATE ww_payroll_current_transaction a, ww_users_profile b SET 
		a.company_id = @nCompany,
		a.branch_id = b.branch_id,
		a.group_id = @nGroup,
		a.department_id = @nDepartment,
		a.section_id = @nSection,
		a.division_id = @nDivision,
		a.position_id = @nPosition,
		a.location_id = @nLocation,
		a.payment_type_id = @nPaymentType,
		a.minwageflag = @Not_MinWage
	WHERE a.employee_id = puserid AND a.employee_id = b.user_id AND a.period_id = periodid AND a.payroll_date = @payroll_date;
	
	UPDATE ww_payroll_period SET `period_status_id` = 2 WHERE payroll_period_id = periodid ;
	COMMIT;
	
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_period_special_process` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_period_special_process` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_period_special_process`(IN periodid INT(11), IN puserid INT(11))
BEGIN
	
	
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
	    -- ERROR
	    ROLLBACK;
	END;
    
	START TRANSACTION;
	
	-- employee info
	SET @sSSS_week = '';
	SET @nStatus = '';
	SET @nEmp_type_id = '';
	SET @dtEff = '';
	SET @dtRes = '';
	SET @nShift = '';
	SET @nTaxcode = '';
	SET @nPayrate = '';
	SET @nPaysched = '';
	SET @nTotal_year_days = '';
	SET @nSalary = '';
	SET @nMin_takehome = '';
	SET @sBank_acct = '';
	SET @nPayLocation = '';
	SET @sSSS_no = '';
	SET @nSSS_mode = '';
	SET @sSSS_week = '';
	SET @nSSS_amount = '';
	SET @sHDMF_no = '';
	SET @nHDMF_mode = '';
	SET @sHDMF_week = '';
	SET @nHDMF_amount = '';
	SET @sPHIC_no = '';
	SET @nPHIC_mode = '';
	SET @sPHIC_week = '';
	SET @nPHIC_amount = '';
	SET @sEcola_week = '';
	SET @sTIN = '';
	SET @nTax_mode = '';
	SET @nTax_amount = '';
	SET @sTax_week = '';
	SET @nSensitivity = '';
	SET @nDivisor = '';
	SET @nCompany = '';
	SET @nGroup = '';
	SET @nDivision = '';
	SET @nDepartment = '';
	SET @nSection = '';
	SET @nPosition = '';
	SET @nProject = '';
	SET @nReports_to = '';
	SET @nJobtitle = '';
	SET @nLocation = '';
	SET @nRemain = '';
	SET @nAttendanceBase = '';
	SET @nHold = '';
	SET @nPaymentType = '';	
	-- period info
	SET @period_status_id = 0;
	SET @payroll_date = '';
	SET @date_from = '';
	SET @date_to = '';
	SET @date_closing = '';
	SET @sweek = '';
	SET @payroll_schedule_id = 0;
	SET @period_processing_type_id = 0;
	SET @apply_to_id = 0;
	
	
	
	-- period info
	SELECT `period_status_id`, `payroll_date`, `date_from`, `date_to`, `date_closing`, `week`, 
		`payroll_schedule_id`, `period_processing_type_id`, `apply_to_id`
	INTO @period_status_id, @payroll_date, @date_from, @date_to, @date_closing, @sweek, 
		@payroll_schedule_id, @period_processing_type_id, @apply_to_id
	FROM ww_payroll_period WHERE payroll_period_id = periodid AND deleted = 0;
	
	-- get employee info	
	CALL `sp_payroll_employee_info`(puserid, 
		@nStatus, @nEmp_type_id, @dtEff, @dtRes, @nShift, 
		@nTaxcode, @nPayrate, @nPaysched, @nTotal_year_days, @nSalary, 
		@nMin_takehome, @sBank_acct, @nPayLocation, @sSSS_no, @nSSS_mode, 
		@sSSS_week, @nSSS_amount, @sHDMF_no, @nHDMF_mode, @sHDMF_week, 
		@nHDMF_amount, @sPHIC_no, @nPHIC_mode, @sPHIC_week, @nPHIC_amount, 
		@sEcola_week, @sTIN, @nTax_mode, @nTax_amount, @sTax_week, @nSensitivity, @nDivisor, 
		@nCompany, @nGroup, @nDivision, @nDepartment, @nSection, @nPosition, @nProject, @nReports_to,
		@nJobtitle, @nLocation, @nRemain, @nAttendanceBase, @nHold, @nPaymentType);
	
	-- check if has open transaction
	SET @id = 0;
	SELECT COUNT(`id`) INTO @id FROM ww_payroll_current_transaction 
	WHERE employee_id = puserid AND payroll_date < @payroll_date AND deleted = 0;
	
	IF @id > 0 THEN
		-- this will raised error There's still an open transaction kindly closed it first
		BEGIN
		-- ERROR
			/*
			SIGNAL SQLSTATE VALUE '99999'
			SET MESSAGE_TEXT = "There's still an open transaction kindly closed it first.";
			select MESSAGE_TEXT;*/
			DECLARE my_error CONDITION FOR SQLSTATE '22012';
			-- SIGNAL my_error;
		ROLLBACK;
		END;
		
	END IF;
	
	-- check if has unclosed deduction
	
	-- remaining period
	
	-- check if last payroll then set tax computation to Annualize
	
	-- remove ww_payroll_current_transaction with the same periodid (reprocessing)
	IF @period_status_id != 3 THEN
		DELETE FROM ww_payroll_current_transaction WHERE `employee_id` = puserid AND `period_id` = periodid;
	END IF;
	-- compute SALARY
	
	-- monthly
	IF @nPayrate = 2 THEN
		SET @PeriodSalary = 0;
		-- CALL sp_payroll_get_salary_monthly(puserid, @payroll_date, periodid, @period_processing_type_id );
		SET @PeriodSalary = @nSalary / @nDivisor;
		SET @DailySalary = @nSalary / ( @nTotal_year_days / 12 );
	END IF;
	-- weekly
	
	IF @nPayrate = 6 THEN
		SET @DailySalary = 0;		
		-- insert salary 
		-- CALL sp_payroll_get_salary_weekly(puserid, @payroll_date, periodid, @period_processing_type_id );
		SET @DailySalary = @nSalary;
	END IF;
	
	-- compute recurring
	-- CALL sp_payroll_get_recurring(puserid, periodid, @sweek, @payroll_date, @period_processing_type_id);
	
	-- compute batch entry
	CALL sp_payroll_get_batch(puserid, periodid, @payroll_date, @period_processing_type_id);
	
	-- compute leave conversion
	-- CALL sp_payroll_leave_conversion(puserid, periodid, @nCompany, @payroll_date, @DailySalary, @nEmp_type_id, @period_processing_type_id);
	SET @Tax_Bonus = 0;	
	-- compute bonus
	CALL sp_payroll_get_bonus(puserid, periodid, @payroll_date, @nSalary, @period_processing_type_id);
	
	-- SELECT @Tax_Bonus;
	
	if @nTax_mode != 3 then
		if @Tax_Bonus > 0 and @nEmp_type_id IN (1,2,3,4,9,10,16,17) then
			set @nTax_mode = 5; -- for bonus taxable		
		elseIF @Tax_Bonus > 0 AND @nEmp_type_id IN (5,6,18) THEN
			SET @nTax_mode = 7; -- for bonus taxable				
		end if;
	end if;
	-- compute ecola
	-- call sp_payroll_get_ecola();
	SET @Not_MinWage = 0;
	SET @min_wage_amt = 0;
	SET @ecola_amt = 0;
	
	SELECT `min_wage_amt`, `ecola_amt` 
	INTO @min_wage_amt, @ecola_amt
	FROM ww_users_location WHERE `location_id` = @nPayLocation AND `deleted` = 0;
	
	IF @min_wage_amt >= @DailySalary THEN
		-- CALL sp_payroll_get_ecola(puserid, periodid, @payroll_date, @ecola_amt, @period_processing_type_id);
		SET @Not_MinWage = 1;
	END IF;
	-- compute/update amount = base_on_earning
	SET @cur_tran_id = 0;
	SELECT `id` INTO @cur_tran_id
	FROM ww_payroll_current_transaction WHERE AES_DECRYPT( `amount`, encryption_key() ) = 'base_on_earning' 
		AND `employee_id` = puserid AND `payroll_date` = @payroll_date AND `deleted` = 0;
	IF @cur_tran_id > 0 THEN
		SET @result = 0.00;
		CALL sp_payroll_get_transaction(puserid,periodid,'1,5',1,1,1,0,@result);
		UPDATE ww_payroll_current_transaction SET `unit_rate` = AES_ENCRYPT( @result, encryption_key() ), `amount` = AES_ENCRYPT( @result, encryption_key() )
			WHERE `id` = @cur_tran_id;
	END IF;
	
	/*SELECT amount INTO @nTax_amount
	FROM whtax_adjustment WHERE `user_id` = puserid;
	
	IF @nTax_amount > 0 THEN
		CALL sp_payroll_get_tax_manual( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTax_amount );
	END IF;*/
	IF @Not_MinWage = 0 THEN
		
		IF @nTax_mode = 1 THEN
			CALL sp_payroll_get_tax_table( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTaxcode );
		-- Annualized
		ELSEIF @nTax_mode = 2 THEN
			CALL sp_payroll_get_tax_annualize( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTaxcode, @nRemain );
		
		-- Manual
		ELSEIF @nTax_mode = 3 THEN	
			IF @nTax_amount > 0 THEN
				CALL sp_payroll_get_tax_manual( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTax_amount );
			END IF;
		ELSEIF @nTax_mode = 5 THEN
			CALL sp_payroll_get_tax_bonus( puserid, periodid, @payroll_date, @period_processing_type_id );
		ELSEIF @nTax_mode = 6 THEN	
			CALL sp_payroll_get_tax_bonus_rf( puserid, periodid, @payroll_date, @period_processing_type_id, @payroll_schedule_id, @nTaxcode, @Tax_Bonus );
		ELSEIF @nTax_mode = 7 THEN
			CALL sp_payroll_get_tax_bonus_sup( puserid, periodid, @payroll_date, @period_processing_type_id );			
		END IF;
		/*
		-- Cummulative
		elseif @nTax_mode = 4 THEN
		
		else
		
		end if;
		*/
	END IF;
		
	-- compute netpay
	CALL sp_payroll_get_netpay( periodid, puserid, @payroll_date, @period_processing_type_id ) ;
	-- update payroll details
	UPDATE ww_payroll_current_transaction a, ww_users_profile b SET 
		a.company_id = @nCompany,
		a.branch_id = b.branch_id,
		a.group_id = @nGroup,
		a.department_id = @nDepartment,
		a.section_id = @nSection,
		a.division_id = @nDivision,
		a.position_id = @nPosition,
		a.location_id = @nLocation,
		a.payment_type_id = @nPaymentType,
		a.minwageflag = @Not_MinWage
	WHERE a.employee_id = puserid AND a.employee_id = b.user_id AND a.period_id = periodid AND a.payroll_date = @payroll_date;
	
	UPDATE ww_payroll_period SET `period_status_id` = 2 WHERE payroll_period_id = periodid ;
	COMMIT;
	
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_recompute_all_employee_netpay` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_recompute_all_employee_netpay` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_recompute_all_employee_netpay`(
		IN puserid INT(11),
		IN periodid INT(11),
		in netpay decimal(12,2),
		IN net_rec_id INT(11)
	)
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE deduction DECIMAL(12,2);
	DECLARE rec_id INT(11);
	DECLARE trans CURSOR FOR
		SELECT AES_DECRYPT( pct.`amount`, encryption_key() ), `id`
		FROM ww_payroll_current_transaction pct
		INNER JOIN ww_payroll_transaction pt ON pct.`transaction_id` = pt.`transaction_id` 
			AND pt.`transaction_type_id` IN (3,4,5) AND pt.`transaction_code` != 'WHTAX'
		INNER JOIN ww_payroll_transaction_class ptc ON ptc.`transaction_class_id` = pt.`transaction_class_id`
			AND ptc.`government_mandated` = 0 
		WHERE pct.`employee_id` = puserid and pct.`period_id` = periodid
		ORDER BY pt.transaction_type_id ASC, priority_id DESC;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	OPEN trans;
	myLoop: LOOP
		FETCH trans INTO deduction, rec_id;
		select concat(deduction, 'x', rec_id);
		IF netpay > 0 THEN
		    select netpay;
		    UPDATE ww_payroll_current_transaction SET 
			`unit_rate` = AES_ENCRYPT( ROUND( netpay, 2 ), encryption_key() ), 
			`amount` = AES_ENCRYPT( ROUND( netpay, 2 ), encryption_key() )
		    WHERE id = net_rec_id;
		    CLOSE trans;
		    LEAVE myLoop;
		END IF;
		IF done THEN
		    CLOSE trans;
		    LEAVE myLoop;
		END IF;
		SET netpay = netpay + deduction;
		UPDATE ww_payroll_current_transaction SET 
			`on_hold` = 1
		WHERE id = rec_id;
		
	END LOOP;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_recompute_all_netpay` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_recompute_all_netpay` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_recompute_all_netpay`()
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	declare emp_id int(11);
	declare per_id int(11);
	declare netpay decimal(12,2);
	DECLARE rec_id INT(11);
	
	declare emp cursor for
		SELECT employee_id, period_id, AES_DECRYPT(`amount`, encryption_key() ), `id` FROM ww_payroll_current_transaction
		WHERE deleted = 0 AND transaction_code = 'NETPAY' 
			AND AES_DECRYPT(`amount`, encryption_key() ) < 0;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	open emp;
	myLoop: LOOP
		FETCH emp INTO emp_id, per_id, netpay, rec_id;
		SELECT CONCAT(emp_id, 'c', per_id, 'n', netpay);
		IF done THEN
		    CLOSE emp;
		    LEAVE myLoop;
		END IF;
		call sp_payroll_recompute_all_employee_netpay( emp_id, per_id, netpay, rec_id);
		
	END LOOP;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_recompute_netpay` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_recompute_netpay` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_recompute_netpay`(
		IN puserid INT(11),
		IN periodid INT(11)
	)
BEGIN
	set @netpay = 0.00;
	
	SELECT ROUND( SUM( IF( 
		ptt.`operation` = '-',
		AES_DECRYPT(pct.`amount`, encryption_key ()) * - 1,
		AES_DECRYPT(pct.`amount`, encryption_key ())
		) ), 2 ) 
	into @netpay
	FROM ww_payroll_current_transaction pct 
	INNER JOIN ww_payroll_transaction pt ON pt.`transaction_id` = pct.`transaction_id` 
	INNER JOIN ww_payroll_transaction_type ptt ON pct.`transaction_type_id` = ptt.`transaction_type_id` 
	INNER JOIN ww_payroll_transaction_class pc ON pc.`transaction_class_id` = pt.`transaction_class_id`
	WHERE pct.`employee_id` = 32 AND pct.`period_id` = 1 AND pct.`deleted` = 0 AND pct.`on_hold` = 0 AND
	      pt.transaction_id NOT IN ( 
			SELECT pt.transaction_id
			FROM ww_payroll_transaction pt
			INNER JOIN ww_payroll_transaction_class pc ON pt.`transaction_class_id` = pc.`transaction_class_id`
			INNER JOIN ww_payroll_transaction_type tt ON tt.`transaction_type_id` = pt.`transaction_type_id`
			WHERE pc.`transaction_class_code` = 'LEAVES' AND operation = '+' );
	
	UPDATE ww_payroll_current_transaction SET 
		`unit_rate` = AES_ENCRYPT( ROUND( @netpay, 2 ), encryption_key() ), 
		`amount` = AES_ENCRYPT( ROUND( @netpay, 2 ), encryption_key() )
	WHERE `employee_id` = puserid and `period_id` = periodid and `transaction_code` = 'NETPAY';
		
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_regen_closed_bir` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_regen_closed_bir` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_regen_closed_bir`(
	
    )
BEGIN
	BEGIN
		DECLARE closed_bir_done TINYINT(11) DEFAULT 0;
		DECLARE bir_emp_id INT(11);
		DECLARE bir_per_id INT(11);
		DECLARE bir_paydate DATE;
		DECLARE bir_employee CURSOR FOR
			SELECT `period_id`, `employee_id`, `payroll_date`
			FROM `ww_payroll_closed_transaction` WHERE `deleted` = 0 and payroll_date like '%2018%' group by employee_id;
		DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET closed_bir_done = 1;
		OPEN bir_employee;
		mybirLoop: LOOP
			FETCH bir_employee INTO bir_per_id, bir_emp_id, bir_paydate;
	
			IF closed_bir_done THEN
				CLOSE bir_employee;
				LEAVE mybirLoop;
			END IF;
			-- Insert Data to Payroll BIR
			CALL `sp_payroll_bir_record`( bir_emp_id, YEAR(bir_paydate), 0 );
		END LOOP;
	END;
	
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_regen_closed_summary` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_regen_closed_summary` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_regen_closed_summary`(
	
    )
BEGIN
	DECLARE closed_period_done TINYINT(11) DEFAULT 0;
	DECLARE emp_id INT(11);
	DECLARE per_id INT(11);
	DECLARE paydate DATE;
	DECLARE employee CURSOR FOR
		SELECT DISTINCT `period_id`, `employee_id`, `payroll_date`
		FROM `ww_payroll_closed_transaction` 
		WHERE `deleted` = 0 AND payroll_date LIKE '%2018%' AND `on_hold` = 0;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET closed_period_done = 1;
	OPEN employee;
	
	myLoop: LOOP
		FETCH employee INTO per_id, emp_id, paydate;
		
		IF closed_period_done THEN
		    CLOSE employee;
		    LEAVE myLoop;
		END IF;
		-- employee summary
		-- check if has record on payroll_closed_summary
		SET @count = 0;
		SELECT COUNT(*) INTO @count FROM `ww_payroll_closed_summary` WHERE `user_id` = emp_id AND `year` = YEAR(paydate) AND `deleted` = 0;
		IF @count = 0 THEN
			-- insert record on payroll_closed_summary
			CALL sp_payroll_closed_summary_insert( emp_id, paydate);
		END IF;
		
		BEGIN
			DECLARE s_done TINYINT(1) DEFAULT 0;
			DECLARE tran_code VARCHAR(32);
			DECLARE summary CURSOR FOR
				SELECT `summary_code` FROM `ww_payroll_closed_summary`
				WHERE `user_id` = emp_id AND `year` = YEAR(paydate)
					AND deleted = 0;
			DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET s_done = 1;
			OPEN summary;
			
			mySummary: LOOP
				FETCH summary INTO tran_code;
				
				IF s_done THEN
					CLOSE summary;
					LEAVE mySummary;
				END IF;
				SET @amt = 0;
				CALL sp_payroll_regen_closed_summary_amt( emp_id, paydate, tran_code, @result );
				SET @amt = @result;
				
				IF @amt IS NOT NULL THEN
					-- update payroll_closed_summary
					CALL sp_payroll_closed_summary_update( emp_id, paydate, tran_code, @amt );
				END IF;
				
			END LOOP;
		END;
		
		-- Insert Data to Payroll BIR
		-- CALL `sp_payroll_bir_record`( emp_id, YEAR(paydate), 0 );
		
	END LOOP;
	
	BEGIN
		DECLARE closed_bir_done TINYINT(11) DEFAULT 0;
		DECLARE bir_emp_id INT(11);
		DECLARE bir_per_id INT(11);
		DECLARE bir_paydate DATE;
		DECLARE bir_employee CURSOR FOR
			SELECT `period_id`, `employee_id`, `payroll_date`
			FROM `ww_payroll_closed_transaction` WHERE `deleted` = 0 group by employee_id;
		DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET closed_bir_done = 1;
		OPEN bir_employee;
		mybirLoop: LOOP
			FETCH bir_employee INTO bir_per_id, bir_emp_id, bir_paydate;
	
			IF closed_bir_done THEN
				CLOSE bir_employee;
				LEAVE mybirLoop;
			END IF;
			-- Insert Data to Payroll BIR
			CALL `sp_payroll_bir_record`( bir_emp_id, YEAR(bir_paydate), 0 );
		END LOOP;
	END;
	
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_regen_closed_summary_amt` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_regen_closed_summary_amt` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_regen_closed_summary_amt`(
	in puserid int(11),
	in paydate date,
	in tran_code varchar(32),
	out nAmount decimal(12,2)
    )
BEGIN
	    set @tran = tran_code;
		SELECT 
		  CASE @tran 
		    WHEN 'TAXABLE_INCOME' THEN SUM( AES_DECRYPT(amount, encryption_key ()) * (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'DEDUCTION_LATE' THEN - 1 
			  WHEN 'DEDUCTION_UNDERTIME' THEN - 1 
			  WHEN 'ABSENCES' THEN - 1 
			  WHEN 'TAXABLE_DEDUCTION' THEN - 1 
			  ELSE 1 
			END
		      )
		    ) 
		    WHEN 'SALARY' THEN SUM( AES_DECRYPT(amount, encryption_key ()) * (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'SALARY' THEN 1 ELSE - 1 
			END
		      )
		    ) 
		    ELSE SUM(
		      AES_DECRYPT(amount, encryption_key ())
		    ) 
		  END
		into nAmount
		FROM ww_payroll_closed_transaction pct 
		LEFT JOIN ww_payroll_transaction_class ptc ON pct.transaction_class_id = ptc.transaction_class_id 
		WHERE pct.employee_id = puserid and pct.payroll_date = paydate
		  AND (
		    CASE @tran 
		      WHEN 'TAXABLE_INCOME' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'SALARY' THEN 1 WHEN 'OVERTIME' THEN 1 WHEN 'BONUS_TAXABLE' THEN 1 
			  WHEN 'ALLOWANCE_BATCH' THEN 1 WHEN 'ALLOWANCE_RECURRING' THEN 1 WHEN 'LEAVES' THEN 1 
			  WHEN 'ABSENCES' THEN 1 WHEN 'DEDUCTION_LATE' THEN 1 WHEN 'DEDUCTION_UNDERTIME' THEN 1 
			  WHEN 'TAXABLE_DEDUCTION' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'BONUS' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'BONUS' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'BONUS_TAXABLE' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'BONUS_TAXABLE' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'ADDITIONAL_EXCLUSION' THEN (
			CASE
			  ptc.government_mandated 
			  WHEN 1 THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'SALARY' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'SALARY' THEN 1 WHEN 'ABSENCES' THEN 1 WHEN 'DEDUCTION_LATE' THEN 1 
			  WHEN 'DEDUCTION_UNDERTIME' THEN 1 ELSE 0 
			END
		      ) 
		      
		      WHEN 'ALLOW_NSTD' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'ALLOWANCE_BATCH' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'BENEFIT_STD' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'BENEFIT_RECURRING' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'BENEFIT_NSTD' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'BENEFIT_BATCH' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'DEDUCTION_STD' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'DEDUCTION_RECURRING' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'DEDUCTION_NSTD' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'DEDUCTION_BATCH' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'OVERTIME' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'OVERTIME' THEN 1 ELSE 0 
			END
		      ) 
		      WHEN 'DEMMINIMIS' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'DE_MINIMIS_BENEFIT_RECURRING' THEN 1 when 'DE_MINIMIS_BENEFIT_BATCH' then 1 ELSE 0 
			END
		      ) 
		      WHEN 'LEAVES' THEN (
			CASE
			  ptc.transaction_class_code 
			  WHEN 'LEAVES' THEN 1 ELSE 0 
			END
		      ) 
		      ELSE (
			CASE
			  @tran 
			  WHEN ptc.transaction_class_code THEN 1 ELSE 0 
			END
		      ) 
		    END
		  ) = 1 ;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_regen_closed_summary_only` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_regen_closed_summary_only` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_regen_closed_summary_only`(
	
    )
BEGIN
	DECLARE closed_period_done TINYINT(11) DEFAULT 0;
	DECLARE emp_id INT(11);
	DECLARE per_id INT(11);
	DECLARE paydate DATE;
	DECLARE employee CURSOR FOR
		SELECT DISTINCT `period_id`, `employee_id`, `payroll_date`
		FROM `ww_payroll_closed_transaction` 
		WHERE `deleted` = 0 AND `on_hold` = 0 and payroll_date like '%2018%';
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET closed_period_done = 1;
	OPEN employee;
	
	myLoop: LOOP
		FETCH employee INTO per_id, emp_id, paydate;
		
		IF closed_period_done THEN
		    CLOSE employee;
		    LEAVE myLoop;
		END IF;
		-- employee summary
		-- check if has record on payroll_closed_summary
		SET @count = 0;
		SELECT COUNT(*) INTO @count FROM `ww_payroll_closed_summary` WHERE `user_id` = emp_id AND `year` = YEAR(paydate) AND `deleted` = 0;
		IF @count = 0 THEN
			-- insert record on payroll_closed_summary
			CALL sp_payroll_closed_summary_insert( emp_id, paydate);
		END IF;
		
		BEGIN
			DECLARE s_done TINYINT(1) DEFAULT 0;
			DECLARE tran_code VARCHAR(32);
			DECLARE summary CURSOR FOR
				SELECT `summary_code` FROM `ww_payroll_closed_summary`
				WHERE `user_id` = emp_id AND `year` = YEAR(paydate)
					AND deleted = 0;
			DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET s_done = 1;
			OPEN summary;
			
			mySummary: LOOP
				FETCH summary INTO tran_code;
				
				IF s_done THEN
					CLOSE summary;
					LEAVE mySummary;
				END IF;
				SET @amt = 0;
				CALL sp_payroll_regen_closed_summary_amt( emp_id, paydate, tran_code, @result );
				SET @amt = @result;
				
				IF @amt IS NOT NULL THEN
					-- update payroll_closed_summary
					CALL sp_payroll_closed_summary_update( emp_id, paydate, tran_code, @amt );
				END IF;
				
			END LOOP;
		END;
		
	END LOOP;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_salary_monthly` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_salary_monthly` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_salary_monthly`(
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	INSERT INTO `ww_payroll_current_transaction`
	    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`,
	     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
	     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
	     `created_by`, `deleted`)
	SELECT periodid, processing_type_id, paydate, user_id, 1, 
	     'SALARY', AES_ENCRYPT(1.00, encryption_key()), 
	     AES_ENCRYPT( 
		round(
		(AES_DECRYPT(salary, encryption_key()) / ( 
			CASE `payroll_schedule_id` WHEN 4 THEN 1 WHEN 5 THEN 2 WHEN 6 THEN 4 ELSE 2 END)
		),2), encryption_key()
	     ) ,
	     AES_ENCRYPT( 
		round(
		(AES_DECRYPT(salary, encryption_key()) / ( 
			CASE `payroll_schedule_id` WHEN 4 THEN 1 WHEN 5 THEN 2 WHEN 6 THEN 4 ELSE 2 END)
		),2), encryption_key()
	     ) ,
	     1, 0,'',0,0,'',NOW(),0,0
	FROM ww_payroll_partners 
	WHERE user_id = puserid;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_salary_weekly` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_salary_weekly` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_salary_weekly`(
	IN puserid INT(11), 
	IN paydate DATE, 
	IN periodid INT(11),
	IN processing_type_id INT(11)
	)
BEGIN
	SET @tran_code = '';
	SET @tran_id = 0;
	SET @tran_class_id = 0;
	SET @tran_type_id = 0;
	SELECT transaction_code, transaction_id , transaction_type_id, `transaction_class_id`
	INTO @tran_code, @tran_id, @tran_type_id, @tran_class_id
	FROM ww_payroll_transaction WHERE transaction_code = 'SALARY';
		
	INSERT INTO `ww_payroll_current_transaction`
	    (`period_id`,`processing_type_id`,`payroll_date`,`employee_id`,`transaction_id`, `transaction_class_id`,
	     `transaction_code`,`quantity`,`unit_rate`,`amount`,`transaction_type_id`,`inserted_from_id`,
	     `record_from`, `record_id`, `on_hold`, `remarks`, `created_on`,
	     `created_by`, `deleted`)
	SELECT periodid, processing_type_id, paydate, puserid, @tran_id, @tran_class_id,
	     @tran_code, AES_ENCRYPT(SUM(t.`hrs_actual`), encryption_key()), 
	     AES_ENCRYPT( ( AES_DECRYPT(p.`salary`, encryption_key()) / 8 ), encryption_key() ) ,
	     AES_ENCRYPT( SUM(t.`hrs_actual`) * ( AES_DECRYPT(p.`salary`, encryption_key()) / 8 ), encryption_key() ) ,
	     @tran_type_id, 0,'',0,0,'',NOW(),0,0
	FROM ww_payroll_partners p
	left join ww_time_record_summary t on p.`user_id` = t.`user_id`
	WHERE p.`user_id` = puserid AND
		t.`payroll_date` = paydate
	GROUP BY t.`user_id`, t.`payroll_date`;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_standard_table` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_standard_table` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_standard_table`()
BEGIN
	/* STANDARD == 33 */
	/*Table structure for table `ww_bank` */
	DROP TABLE IF EXISTS `ww_bank`;
	CREATE TABLE `ww_bank` (
	  `bank_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `bank_type` VARCHAR(10) CHARACTER SET latin1 DEFAULT NULL,
	  `bank_code_numeric` VARCHAR(20) CHARACTER SET latin1 NOT NULL,
	  `bank_code_alpha` VARCHAR(30) CHARACTER SET latin1 DEFAULT NULL,
	  `bank` VARCHAR(50) CHARACTER SET latin1 NOT NULL,
	  `account_name` VARCHAR(128) CHARACTER SET latin1 DEFAULT NULL,
	  `account_no` VARCHAR(128) CHARACTER SET latin1 DEFAULT NULL,
	  `batch_no` INT(5) DEFAULT '0',
	  `ceiling_amount` DECIMAL(12,2) DEFAULT '0.00',
	  `branch_code` VARCHAR(20) CHARACTER SET latin1 DEFAULT NULL,
	  `description` TEXT CHARACTER SET latin1,
	  `deleted` INT(1) DEFAULT '0',
	  PRIMARY KEY (`bank_id`)
	) ENGINE=INNODB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_account_type` */
	DROP TABLE IF EXISTS `ww_payroll_account_type`;
	CREATE TABLE `ww_payroll_account_type` (
	  `account_type_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `account_type` VARCHAR(255) CHARACTER SET latin1 NOT NULL,
	  `description` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) NOT NULL DEFAULT '0',
	  PRIMARY KEY (`account_type_id`)
	) ENGINE=INNODB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_annual_tax` */
	DROP TABLE IF EXISTS `ww_payroll_annual_tax`;
	CREATE TABLE `ww_payroll_annual_tax` (
	  `annual_tax_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `salary_from` DECIMAL(10,2) NOT NULL,
	  `salary_to` DECIMAL(10,2) NOT NULL,
	  `amount` DECIMAL(10,2) NOT NULL,
	  `rate` DECIMAL(6,2) NOT NULL,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) NOT NULL DEFAULT '0',
	  PRIMARY KEY (`annual_tax_id`)
	) ENGINE=INNODB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_apply_to` */
	DROP TABLE IF EXISTS `ww_payroll_apply_to`;
	CREATE TABLE `ww_payroll_apply_to` (
	  `apply_to_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `apply_to` VARCHAR(64) NOT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`apply_to_id`)
	) ENGINE=INNODB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_closed_summary_id` */
	DROP TABLE IF EXISTS `ww_payroll_closed_summary_id`;
	CREATE TABLE `ww_payroll_closed_summary_id` (
	  `summary_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `summary_code` VARCHAR(32) NOT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) NOT NULL DEFAULT '0',
	  PRIMARY KEY (`summary_id`)
	) ENGINE=INNODB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8;
	/*Data for the table `ww_payroll_closed_summary_id` */
	
	/*Table structure for table `ww_payroll_inserted_from` */
	DROP TABLE IF EXISTS `ww_payroll_inserted_from`;
	CREATE TABLE `ww_payroll_inserted_from` (
	  `inserted_from_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `inserted_from` VARCHAR(64) CHARACTER SET latin1 NOT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`inserted_from_id`)
	) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_interest_type` */
	DROP TABLE IF EXISTS `ww_payroll_interest_type`;
	CREATE TABLE `ww_payroll_interest_type` (
	  `interest_type_id` INT(1) NOT NULL AUTO_INCREMENT,
	  `interest_type` VARCHAR(64) CHARACTER SET latin1 NOT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`interest_type_id`)
	) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_loan_interest_type` */
	DROP TABLE IF EXISTS `ww_payroll_loan_interest_type`;
	CREATE TABLE `ww_payroll_loan_interest_type` (
	  `interest_type_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `interest_type` VARCHAR(255) CHARACTER SET latin1 DEFAULT NULL,
	  `description` TEXT,
	  `deleted` INT(1) DEFAULT '0',
	  PRIMARY KEY (`interest_type_id`)
	) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_loan_mode` */
	DROP TABLE IF EXISTS `ww_payroll_loan_mode`;
	CREATE TABLE `ww_payroll_loan_mode` (
	  `loan_mode_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `loan_mode` VARCHAR(128) DEFAULT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`loan_mode_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_loan_status` */
	DROP TABLE IF EXISTS `ww_payroll_loan_status`;
	CREATE TABLE `ww_payroll_loan_status` (
	  `loan_status_id` INT(1) NOT NULL AUTO_INCREMENT,
	  `loan_status` VARCHAR(32) DEFAULT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`loan_status_id`)
	) ENGINE=INNODB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_loan_type` */
	DROP TABLE IF EXISTS `ww_payroll_loan_type`;
	CREATE TABLE `ww_payroll_loan_type` (
	  `loan_type_id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `loan_type` VARCHAR(128) DEFAULT NULL,
	  `description` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`loan_type_id`)
	) ENGINE=INNODB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_overtime` */
	DROP TABLE IF EXISTS `ww_payroll_overtime`;
	CREATE TABLE `ww_payroll_overtime` (
	  `overtime_id` INT(1) NOT NULL DEFAULT '0',
	  `overtime_code` VARCHAR(32) NOT NULL DEFAULT '',
	  `overtime` VARCHAR(64) DEFAULT NULL,
	  `overtime_rate` DECIMAL(5,2) DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0'
	) ENGINE=INNODB DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_overtime_rates` */
	DROP TABLE IF EXISTS `ww_payroll_overtime_rates`;
	CREATE TABLE `ww_payroll_overtime_rates` (
	  `overtime_rate_id` INT(1) NOT NULL AUTO_INCREMENT,
	  `company_id` INT(1) NOT NULL DEFAULT '0',
	  `partner_status_id` INT(1) NOT NULL DEFAULT '0',
	  `overtime_id` INT(11) NOT NULL,
	  `overtime_code` VARCHAR(32) NOT NULL DEFAULT '',
	  `overtime` VARCHAR(64) DEFAULT NULL,
	  `overtime_rate` DECIMAL(5,2) DEFAULT NULL,
	  `sequence` TINYINT(1) DEFAULT NULL,
	  `class` VARCHAR(32) DEFAULT NULL,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_on` INT(11) DEFAULT NULL,
	  `modified_by` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`overtime_rate_id`),
	  UNIQUE KEY `company_partner_overtime` (`company_id`,`partner_status_id`,`overtime_code`),
	  KEY `company_id` (`company_id`),
	  KEY `partner_status_id` (`partner_status_id`),
	  KEY `overtime_code` (`overtime_code`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_payment_mode` */
	DROP TABLE IF EXISTS `ww_payroll_payment_mode`;
	CREATE TABLE `ww_payroll_payment_mode` (
	  `payment_mode_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `payment_mode` VARCHAR(64) CHARACTER SET latin1 NOT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`payment_mode_id`)
	) ENGINE=INNODB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_payment_type` */
	DROP TABLE IF EXISTS `ww_payroll_payment_type`;
	CREATE TABLE `ww_payroll_payment_type` (
	  `payment_type_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `payment_type` VARCHAR(64) DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`payment_type_id`)
	) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_period_processing_type` */
	DROP TABLE IF EXISTS `ww_payroll_period_processing_type`;
	CREATE TABLE `ww_payroll_period_processing_type` (
	  `period_processing_type_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `period_processing_type` VARCHAR(64) CHARACTER SET latin1 NOT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`period_processing_type_id`)
	) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_period_status` */
	DROP TABLE IF EXISTS `ww_payroll_period_status`;
	CREATE TABLE `ww_payroll_period_status` (
	  `period_status_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `period_status` VARCHAR(64) NOT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`period_status_id`)
	) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_phic_table` */
	DROP TABLE IF EXISTS `ww_payroll_phic_table`;
	CREATE TABLE `ww_payroll_phic_table` (
	  `phic_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `from` DECIMAL(10,2) NOT NULL DEFAULT '0.00',
	  `to` DECIMAL(10,2) NOT NULL DEFAULT '0.00',
	  `eeshare` DECIMAL(6,2) NOT NULL DEFAULT '0.00' COMMENT 'employee share',
	  `ershare` DECIMAL(6,2) NOT NULL DEFAULT '0.00' COMMENT 'employer share',
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`phic_id`)
	) ENGINE=INNODB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
	
	/*Table structure for table `ww_payroll_rate_type` */
	DROP TABLE IF EXISTS `ww_payroll_rate_type`;
	CREATE TABLE `ww_payroll_rate_type` (
	  `payroll_rate_type_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `payroll_rate_type` VARCHAR(64) CHARACTER SET latin1 DEFAULT NULL,
	  `description` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) NOT NULL DEFAULT '0',
	  PRIMARY KEY (`payroll_rate_type_id`)
	) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_schedule` */
	DROP TABLE IF EXISTS `ww_payroll_schedule`;
	CREATE TABLE `ww_payroll_schedule` (
	  `payroll_schedule_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `payroll_schedule` VARCHAR(64) CHARACTER SET latin1 DEFAULT NULL,
	  `yearly` INT(1) DEFAULT '0',
	  `monthly` INT(1) DEFAULT '0',
	  `daily` INT(1) DEFAULT '0',
	  `piece_rate` INT(1) DEFAULT '0',
	  `commision` INT(1) DEFAULT '0',
	  `total_period_per_annum` INT(1) DEFAULT '24',
	  `deleted` TINYINT(1) NOT NULL DEFAULT '0',
	  PRIMARY KEY (`payroll_schedule_id`)
	) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_schedule_rate_divisor` */
	DROP TABLE IF EXISTS `ww_payroll_schedule_rate_divisor`;
	CREATE TABLE `ww_payroll_schedule_rate_divisor` (
	  `payroll_rate_type_id` INT(11) DEFAULT NULL,
	  `payroll_schedule_id` INT(11) DEFAULT NULL,
	  `divisor` FLOAT DEFAULT NULL,
	  `deleted` INT(1) DEFAULT '0'
	) ENGINE=INNODB DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_sss_table` */
	DROP TABLE IF EXISTS `ww_payroll_sss_table`;
	CREATE TABLE `ww_payroll_sss_table` (
	  `sss_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `from` DECIMAL(10,2) NOT NULL DEFAULT '0.00',
	  `to` DECIMAL(10,2) NOT NULL DEFAULT '0.00',
	  `eeshare` DECIMAL(6,2) NOT NULL DEFAULT '0.00' COMMENT 'employee share',
	  `ershare` DECIMAL(6,2) NOT NULL DEFAULT '0.00' COMMENT 'employer share',
	  `ec` DECIMAL(6,2) NOT NULL DEFAULT '0.00',
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`sss_id`)
	) ENGINE=INNODB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_transaction` */
	DROP TABLE IF EXISTS `ww_payroll_transaction`;
	CREATE TABLE `ww_payroll_transaction` (
	  `transaction_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `transaction_code` VARCHAR(32) NOT NULL,
	  `transaction_label` VARCHAR(128) DEFAULT NULL,
	  `transaction_class_id` INT(1) DEFAULT '0',
	  `transaction_type_id` INT(1) DEFAULT '0',
	  `debit_account_id` INT(1) DEFAULT '0',
	  `credit_account_id` INT(1) DEFAULT '0',
	  `per_annum_cap` DECIMAL(15,2) DEFAULT '0.00',
	  `priority_id` TINYINT(1) DEFAULT '3',
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`transaction_id`),
	  KEY `transaction_code` (`transaction_code`),
	  KEY `transaction_class_id` (`transaction_class_id`),
	  KEY `transaction_type_id` (`transaction_type_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=199 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_transaction_class` */
	DROP TABLE IF EXISTS `ww_payroll_transaction_class`;
	CREATE TABLE `ww_payroll_transaction_class` (
	  `transaction_class_id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `transaction_class_code` VARCHAR(32) NOT NULL,
	  `transaction_class` VARCHAR(128) NOT NULL,
	  `regular_processing` TINYINT(1) DEFAULT '0',
	  `special_processing` TINYINT(1) DEFAULT '0',
	  `final_pay_processing` TINYINT(1) DEFAULT '0',
	  `is_recurring` TINYINT(1) DEFAULT '0',
	  `is_irregular` TINYINT(1) DEFAULT '0',
	  `is_loan` TINYINT(1) DEFAULT '0',
	  `is_bonus` TINYINT(1) DEFAULT '0',
	  `government_mandated` TINYINT(1) DEFAULT '0',
	  `description` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`transaction_class_id`),
	  KEY `transaction_class_code` (`transaction_class_code`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_transaction_method` */
	DROP TABLE IF EXISTS `ww_payroll_transaction_method`;
	CREATE TABLE `ww_payroll_transaction_method` (
	  `payroll_transaction_method_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `payroll_transaction_method` VARCHAR(32) NOT NULL,
	  `sequence` TINYINT(1) DEFAULT '1',
	  `description` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`payroll_transaction_method_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_transaction_mode` */
	DROP TABLE IF EXISTS `ww_payroll_transaction_mode`;
	CREATE TABLE `ww_payroll_transaction_mode` (
	  `payroll_transaction_mode_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `payroll_transaction_mode` VARCHAR(32) NOT NULL,
	  `description` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`payroll_transaction_mode_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_transaction_mode_tax` */
	DROP TABLE IF EXISTS `ww_payroll_transaction_mode_tax`;
	CREATE TABLE `ww_payroll_transaction_mode_tax` (
	  `payroll_transaction_mode_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `payroll_transaction_mode` VARCHAR(32) NOT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`payroll_transaction_mode_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_transaction_priority` */
	DROP TABLE IF EXISTS `ww_payroll_transaction_priority`;
	CREATE TABLE `ww_payroll_transaction_priority` (
	  `priority_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `priority` VARCHAR(32) NOT NULL,
	  `priority_index` TINYINT(1) DEFAULT '1',
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`priority_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_transaction_type` */
	DROP TABLE IF EXISTS `ww_payroll_transaction_type`;
	CREATE TABLE `ww_payroll_transaction_type` (
	  `transaction_type_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `transaction_type` VARCHAR(32) NOT NULL,
	  `operation` VARCHAR(1) NOT NULL DEFAULT '+',
	  `description` TEXT,
	  `sort_order` TINYINT(1) DEFAULT '1',
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`transaction_type_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_week` */
	DROP TABLE IF EXISTS `ww_payroll_week`;
	CREATE TABLE `ww_payroll_week` (
	  `week_id` INT(1) NOT NULL AUTO_INCREMENT,
	  `week` VARCHAR(8) NOT NULL,
	  `description` TEXT,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`week_id`)
	) ENGINE=INNODB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_whtax_table` */
	DROP TABLE IF EXISTS `ww_payroll_whtax_table`;
	CREATE TABLE `ww_payroll_whtax_table` (
	  `whtax_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `payroll_schedule_id` INT(1) NOT NULL,
	  `taxcode_id` INT(1) NOT NULL,
	  `salary_from` DECIMAL(10,2) NOT NULL DEFAULT '0.00',
	  `salary_to` DECIMAL(10,2) NOT NULL DEFAULT '0.00',
	  `fixed_amount` DECIMAL(10,2) NOT NULL DEFAULT '0.00',
	  `excess_percentage` DECIMAL(6,2) NOT NULL DEFAULT '0.00',
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`whtax_id`)
	) ENGINE=INNODB AUTO_INCREMENT=193 DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED;
	
	/*Table structure for table `ww_sensitivity` */
	DROP TABLE IF EXISTS `ww_sensitivity`;
	CREATE TABLE `ww_sensitivity` (
	  `sensitivity_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `sensitivity` VARCHAR(32) DEFAULT NULL,
	  `description` TEXT,
	  `deleted` INT(1) DEFAULT '0',
	  PRIMARY KEY (`sensitivity_id`)
	) ENGINE=INNODB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_taxcode` */
	DROP TABLE IF EXISTS `ww_taxcode`;
	CREATE TABLE `ww_taxcode` (
	  `taxcode_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `taxcode` VARCHAR(50) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
	  `amount` DOUBLE(15,2) NOT NULL,
	  `description` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) NOT NULL,
	  PRIMARY KEY (`taxcode_id`)
	) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
	
	/* OTHER PAYROLL TABLE == 18 */
	
	/*Table structure for table `ww_payroll_account` */
	DROP TABLE IF EXISTS `ww_payroll_account`;
	CREATE TABLE `ww_payroll_account` (
	  `account_id` int(11) NOT NULL AUTO_INCREMENT,
	  `account_code` varchar(32) CHARACTER SET latin1 NOT NULL,
	  `account_name` varchar(255) CHARACTER SET latin1 NOT NULL,
	  `account_type_id` int(11) NOT NULL DEFAULT '2',
	  `description` text,
	  `created_by` int(11) DEFAULT NULL,
	  `created_on` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` int(11) DEFAULT NULL,
	  `modified_on` datetime DEFAULT NULL,
	  `deleted` tinyint(1) NOT NULL DEFAULT '0',
	  PRIMARY KEY (`account_id`),
	  UNIQUE KEY `account_code` (`account_code`),
	  KEY `account_type_id` (`account_type_id`)
	) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_bonus` */
	DROP TABLE IF EXISTS `ww_payroll_bonus`;
	CREATE TABLE `ww_payroll_bonus` (
	  `bonus_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `bonus_transaction_id` INT(11) DEFAULT NULL,
	  `accrual_transaction_id` INT(11) DEFAULT NULL,
	  `adjustment_transaction_id` INT(11) DEFAULT NULL,
	  `taxable_bonus_transaction_id` INT(11) DEFAULT NULL,
	  `taxable_acrrual_transaction_id` INT(11) DEFAULT NULL,
	  `taxable_adjustment_transaction_id` INT(11) DEFAULT NULL,
	  `date_from` DATE DEFAULT NULL,
	  `date_to` DATE DEFAULT NULL,
	  `payroll_date` DATE DEFAULT NULL,
	  `transaction_method_id` INT(11) DEFAULT NULL,
	  `period` INT(11) DEFAULT NULL,
	  `mainamount` DECIMAL(15,2) DEFAULT NULL,
	  `apply_maxbonus_rule` INT(1) DEFAULT '0',
	  `week` VARCHAR(16) DEFAULT NULL,
	  `employee_id` TEXT,
	  `account_id` INT(11) DEFAULT NULL,
	  `description` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` INT(1) DEFAULT '0',
	  PRIMARY KEY (`bonus_id`),
	  UNIQUE KEY `payroll_date` (`payroll_date`)
	) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_bonus_accrual` */
	DROP TABLE IF EXISTS `ww_payroll_bonus_accrual`;
	CREATE TABLE `ww_payroll_bonus_accrual` (
	  `accrual_id` INT(11) DEFAULT NULL,
	  `period_id` INT(11) DEFAULT NULL,
	  `bonus_id` INT(11) DEFAULT NULL,
	  `employee_id` INT(11) DEFAULT NULL,
	  `amount` DECIMAL(15,2) DEFAULT NULL,
	  KEY `accrual_id` (`accrual_id`),
	  KEY `period_id` (`period_id`),
	  KEY `employee_id` (`employee_id`),
	  KEY `bonus_id` (`bonus_id`)
	) ENGINE=INNODB DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_bonus_employee` */
	DROP TABLE IF EXISTS `ww_payroll_bonus_employee`;
	CREATE TABLE `ww_payroll_bonus_employee` (
	  `bonus_id` INT(11) DEFAULT NULL,
	  `employee_id` INT(11) DEFAULT NULL,
	  `amount` VARBINARY(255) DEFAULT NULL,
	  KEY `bonus_id` (`bonus_id`),
	  KEY `employee_id` (`employee_id`)
	) ENGINE=INNODB DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_closed_summary` */
	DROP TABLE IF EXISTS `ww_payroll_closed_summary`;
	CREATE TABLE `ww_payroll_closed_summary` (
	  `id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `user_id` INT(11) NOT NULL,
	  `company_id` INT(11) DEFAULT NULL,
	  `department_id` INT(11) DEFAULT NULL,
	  `type` VARCHAR(1) DEFAULT NULL,
	  `year` INT(1) NOT NULL,
	  `summary_id` INT(1) NOT NULL,
	  `summary_code` VARCHAR(32) NOT NULL,
	  `ytd` VARBINARY(255) DEFAULT NULL,
	  `january` VARBINARY(255) DEFAULT NULL,
	  `february` VARBINARY(255) DEFAULT NULL,
	  `march` VARBINARY(255) DEFAULT NULL,
	  `april` VARBINARY(255) DEFAULT NULL,
	  `may` VARBINARY(255) DEFAULT NULL,
	  `june` VARBINARY(255) DEFAULT NULL,
	  `july` VARBINARY(255) DEFAULT NULL,
	  `august` VARBINARY(255) DEFAULT NULL,
	  `september` VARBINARY(255) DEFAULT NULL,
	  `october` VARBINARY(255) DEFAULT NULL,
	  `november` VARBINARY(255) DEFAULT NULL,
	  `december` VARBINARY(255) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `deleted` INT(1) DEFAULT '0',
	  PRIMARY KEY (`id`)
	) ENGINE=INNODB AUTO_INCREMENT=55 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_closed_transaction` */
	DROP TABLE IF EXISTS `ww_payroll_closed_transaction`;
	CREATE TABLE `ww_payroll_closed_transaction` (
	  `id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `period_id` INT(11) DEFAULT NULL,
	  `processing_type_id` INT(1) DEFAULT NULL,
	  `payroll_date` DATE DEFAULT NULL,
	  `employee_id` INT(11) DEFAULT NULL,
	  `transaction_id` INT(1) DEFAULT NULL,
	  `transaction_class_id` INT(11) DEFAULT NULL,
	  `transaction_code` VARCHAR(32) DEFAULT NULL,
	  `quantity` VARBINARY(255) DEFAULT NULL,
	  `unit_rate` VARBINARY(255) DEFAULT NULL,
	  `amount` VARBINARY(255) DEFAULT NULL,
	  `transaction_type_id` INT(1) DEFAULT NULL,
	  `inserted_from_id` INT(1) DEFAULT NULL,
	  `record_from` VARCHAR(64) DEFAULT NULL,
	  `record_id` INT(11) DEFAULT NULL,
	  `on_hold` TINYINT(1) DEFAULT '0',
	  `remarks` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`id`),
	  KEY `period_id` (`period_id`),
	  KEY `processing_type_id` (`processing_type_id`),
	  KEY `payroll_date` (`payroll_date`),
	  KEY `transaction_id` (`transaction_id`),
	  KEY `transaction_type_id` (`transaction_type_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_current_transaction` */
	DROP TABLE IF EXISTS `ww_payroll_current_transaction`;
	CREATE TABLE `ww_payroll_current_transaction` (
	  `id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `period_id` INT(11) DEFAULT NULL,
	  `processing_type_id` INT(1) DEFAULT NULL,
	  `payroll_date` DATE DEFAULT NULL,
	  `employee_id` INT(11) DEFAULT NULL,
	  `transaction_id` INT(1) DEFAULT NULL,
	  `transaction_class_id` INT(11) DEFAULT NULL,
	  `transaction_code` VARCHAR(32) DEFAULT NULL,
	  `quantity` VARBINARY(255) DEFAULT NULL,
	  `unit_rate` VARBINARY(255) DEFAULT NULL,
	  `amount` VARBINARY(255) DEFAULT NULL,
	  `transaction_type_id` INT(1) DEFAULT NULL,
	  `inserted_from_id` INT(1) DEFAULT NULL,
	  `record_from` VARCHAR(64) DEFAULT NULL,
	  `record_id` INT(11) DEFAULT NULL,
	  `on_hold` TINYINT(1) DEFAULT '0',
	  `remarks` TEXT,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `created_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `modified_by` INT(11) DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`id`),
	  KEY `period_id` (`period_id`),
	  KEY `processing_type_id` (`processing_type_id`),
	  KEY `payroll_date` (`payroll_date`),
	  KEY `transaction_id` (`transaction_id`),
	  KEY `transaction_type_id` (`transaction_type_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=278 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_entry_batch` */
	DROP TABLE IF EXISTS `ww_payroll_entry_batch`;
	CREATE TABLE `ww_payroll_entry_batch` (
	  `batch_entry_id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `payroll_date` DATE NOT NULL,
	  `transaction_id` INT(11) DEFAULT NULL,
	  `document_no` VARCHAR(64) CHARACTER SET latin1 DEFAULT NULL,
	  `unit_rate_main` VARBINARY(255) DEFAULT NULL,
	  `remarks` TEXT CHARACTER SET latin1,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`batch_entry_id`),
	  KEY `payroll_date` (`payroll_date`),
	  KEY `document_no` (`document_no`),
	  KEY `deleted` (`deleted`),
	  KEY `transaction_id` (`transaction_id`)
	) ENGINE=INNODB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_entry_batch_employee` */
	DROP TABLE IF EXISTS `ww_payroll_entry_batch_employee`;
	CREATE TABLE `ww_payroll_entry_batch_employee` (
	  `batch_entry_id` INT(11) NOT NULL,
	  `employee_id` INT(11) NOT NULL,
	  `quantity` VARBINARY(255) DEFAULT NULL,
	  `unit_rate` VARBINARY(255) DEFAULT NULL,
	  `amount` VARBINARY(255) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `deleted` TINYINT(1) DEFAULT '0',
	  KEY `batch_entry_id` (`batch_entry_id`),
	  KEY `employee_id` (`employee_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_entry_recurring` */
	DROP TABLE IF EXISTS `ww_payroll_entry_recurring`;
	CREATE TABLE `ww_payroll_entry_recurring` (
	  `recurring_id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `transaction_id` INT(11) NOT NULL,
	  `document_no` VARCHAR(32) CHARACTER SET latin1 DEFAULT NULL,
	  `date_from` DATE DEFAULT NULL,
	  `date_to` DATE DEFAULT NULL,
	  `week` VARCHAR(16) CHARACTER SET latin1 DEFAULT NULL,
	  `amount` VARCHAR(64) CHARACTER SET latin1 NOT NULL,
	  `transaction_type_id` INT(1) NOT NULL,
	  `transaction_method_id` INT(1) NOT NULL,
	  `remarks` VARCHAR(255) CHARACTER SET latin1 DEFAULT NULL,
	  `account_id` INT(11) DEFAULT NULL,
	  `account_code` VARCHAR(32) CHARACTER SET latin1 DEFAULT NULL,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`recurring_id`),
	  KEY `transaction_id` (`transaction_id`),
	  KEY `document_no` (`document_no`),
	  KEY `date_from` (`date_from`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_entry_recurring_employee` */
	DROP TABLE IF EXISTS `ww_payroll_entry_recurring_employee`;
	CREATE TABLE `ww_payroll_entry_recurring_employee` (
	  `recurring_id` INT(11) UNSIGNED NOT NULL,
	  `employee_id` INT(11) NOT NULL,
	  `quantity` VARBINARY(255) DEFAULT NULL,
	  `amount` VARBINARY(255) NOT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `deleted` TINYINT(1) DEFAULT '0',
	  KEY `recurring_id` (`recurring_id`),
	  KEY `employee_id` (`employee_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_loan` */
	DROP TABLE IF EXISTS `ww_payroll_loan`;
	CREATE TABLE `ww_payroll_loan` (
	  `loan_id` INT(1) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `loan` VARCHAR(128) NOT NULL,
	  `principal_transid` INT(1) DEFAULT NULL,
	  `amortization_transid` INT(1) DEFAULT NULL,
	  `interest_transid` INT(1) DEFAULT NULL,
	  `loan_type_id` INT(1) DEFAULT NULL,
	  `loan_mode_id` INT(1) DEFAULT NULL,
	  `amount_limit` DECIMAL(9,2) DEFAULT '0.00',
	  `interest` DECIMAL(9,2) DEFAULT '0.00',
	  `interest_type_id` INT(1) DEFAULT NULL,
	  `debit` INT(1) DEFAULT NULL,
	  `credit` INT(1) DEFAULT NULL,
	  `description` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_on` INT(11) DEFAULT NULL,
	  `modified_by` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`loan_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_location` */
	DROP TABLE IF EXISTS `ww_payroll_location`;
	CREATE TABLE `ww_payroll_location` (
	  `payroll_location_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `payroll_location_code` VARCHAR(32) DEFAULT NULL,
	  `payroll_location_label` VARCHAR(100) DEFAULT NULL,
	  `min_wage_amt` DECIMAL(12,2) DEFAULT '0.00',
	  `ecola_amt` DECIMAL(12,2) DEFAULT '0.00',
	  `description` TEXT,
	  `deleted` TINYINT(1) NOT NULL DEFAULT '0',
	  PRIMARY KEY (`payroll_location_id`),
	  UNIQUE KEY `payroll_location_code` (`payroll_location_code`)
	) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
	/*Table structure for table `ww_payroll_partners_contribution` */
	DROP TABLE IF EXISTS `ww_payroll_partners_contribution`;
	CREATE TABLE `ww_payroll_partners_contribution` (
	  `id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `period_id` INT(11) NOT NULL,
	  `payroll_date` DATE NOT NULL,
	  `user_id` INT(11) NOT NULL,
	  `transaction_id` INT(11) DEFAULT NULL,
	  `employee` DECIMAL(10,2) DEFAULT '0.00',
	  `company` DECIMAL(10,2) DEFAULT '0.00',
	  `ec` DECIMAL(10,2) DEFAULT '0.00',
	  `msb_id` INT(11) DEFAULT NULL,
	  `created_by` INT(11) DEFAULT NULL,
	  `create_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`id`)
	) ENGINE=INNODB DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_partners_loan` */
	DROP TABLE IF EXISTS `ww_payroll_partners_loan`;
	CREATE TABLE `ww_payroll_partners_loan` (
	  `partner_loan_id` INT(11) NOT NULL AUTO_INCREMENT,
	  `user_id` INT(11) DEFAULT NULL,
	  `loan_id` INT(11) DEFAULT NULL,
	  `loan_status_id` INT(1) DEFAULT NULL,
	  `description` TEXT,
	  `entry_date` DATE DEFAULT NULL,
	  `loan_principal` VARBINARY(255) DEFAULT NULL,
	  `amount` VARBINARY(255) DEFAULT NULL,
	  `interest` VARBINARY(255) DEFAULT NULL,
	  `interest_type_id` INT(1) DEFAULT NULL,
	  `no_payments` INT(1) DEFAULT NULL,
	  `no_payments_paid` INT(1) DEFAULT NULL,
	  `no_payments_remaining` INT(1) DEFAULT NULL,
	  `beginning_balance` VARBINARY(255) DEFAULT NULL,
	  `running_balance` VARBINARY(255) DEFAULT NULL,
	  `release_date` DATE DEFAULT NULL,
	  `payment_mode_id` INT(1) DEFAULT NULL,
	  `start_date` DATE DEFAULT NULL,
	  `releasing_debit_account_id` INT(11) DEFAULT NULL,
	  `releasing_credit_account_id` INT(11) DEFAULT NULL,
	  `system_amortization` VARBINARY(255) DEFAULT NULL,
	  `user_amortization` VARBINARY(255) DEFAULT NULL,
	  `system_interest` VARBINARY(255) DEFAULT NULL,
	  `user_interest` VARBINARY(255) DEFAULT NULL,
	  `total_arrears` VARBINARY(255) DEFAULT NULL,
	  `total_amount_paid` VARBINARY(255) DEFAULT NULL,
	  `last_payment_date` DATE DEFAULT NULL,
	  `amortization_credit_account_id` INT(11) DEFAULT NULL,
	  `interest_credit_account_id` INT(11) DEFAULT NULL,
	  `interest_amortization_credit_account_id` INT(11) DEFAULT NULL,
	  `week` VARCHAR(64) DEFAULT NULL,
	  `previous_employee_loan_id` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `created_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `modified_by` INT(11) DEFAULT NULL,
	  `deleted` INT(1) DEFAULT '0',
	  PRIMARY KEY (`partner_loan_id`)
	) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_partners_loan_payment` */
	DROP TABLE IF EXISTS `ww_payroll_partners_loan_payment`;
	CREATE TABLE `ww_payroll_partners_loan_payment` (
	  `partner_loan_id` INT(11) NOT NULL,
	  `payroll_date` DATE DEFAULT NULL,
	  `type` VARCHAR(10) DEFAULT NULL,
	  `amount` VARBINARY(255) DEFAULT NULL,
	  `paid` TINYINT(1) DEFAULT '0',
	  `date_paid` DATE DEFAULT NULL
	) ENGINE=INNODB DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_period` */
	DROP TABLE IF EXISTS `ww_payroll_period`;
	CREATE TABLE `ww_payroll_period` (
	  `payroll_period_id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `period_status_id` TINYINT(1) DEFAULT '1',
	  `payroll_date` DATE DEFAULT NULL,
	  `date_from` DATE DEFAULT NULL,
	  `date_to` DATE DEFAULT NULL,
	  `date_closing` DATE DEFAULT NULL,
	  `week` INT(1) DEFAULT NULL,
	  `annualized` TINYINT(1) DEFAULT '0',
	  `payroll_schedule_id` INT(11) DEFAULT NULL,
	  `period_processing_type_id` INT(11) DEFAULT '1',
	  `apply_to_id` INT(11) DEFAULT NULL,
	  `remarks` TEXT,
	  `created_by` INT(11) DEFAULT NULL,
	  `created_on` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	  `modified_by` INT(11) DEFAULT NULL,
	  `modified_on` DATETIME DEFAULT NULL,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`payroll_period_id`),
	  KEY `payroll_date` (`payroll_date`),
	  KEY `date_from` (`date_from`),
	  KEY `date_to` (`date_to`),
	  KEY `period_status_id` (`period_status_id`),
	  KEY `deleted` (`deleted`)
	) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
	
	/*Table structure for table `ww_payroll_period_apply_to` */
	DROP TABLE IF EXISTS `ww_payroll_period_apply_to`;
	CREATE TABLE `ww_payroll_period_apply_to` (
	  `id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	  `payroll_period_id` INT(11) NOT NULL,
	  `apply_to` INT(11) NOT NULL,
	  `created_on` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
	  `deleted` TINYINT(1) DEFAULT '0',
	  PRIMARY KEY (`id`)
	) ENGINE=INNODB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
	
	/* TABLES NOT INCLUDED */
	/* ww_payroll_govt_contribution */
	/* ww_payroll_overtimex */
	/* ww_payroll_partners */
	/* ww_payroll_paycode */
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_payroll_update_loan_manual` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_payroll_update_loan_manual` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_payroll_update_loan_manual`(
	IN puserid INT(11),
	IN ploan_id INT(11),
	in amor DECIMAL(12,2)	
    )
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE emp_id INT(11);
	DECLARE ploan_id INT(11);
	DECLARE	paydate DATE;
	DECLARE pay_mode INT(11);
	DECLARE run_bal DECIMAL(12,2);
	DECLARE sys_amort DECIMAL(12,2);
	DECLARE user_amort DECIMAL(12,2);
	DECLARE ln_status_id INT(11);
	DECLARE tot_amt_pd DECIMAL(12,2);
	DECLARE no_pay_pd INT(11);
	DECLARE no_pay_rem INT(11);
	DECLARE loan CURSOR FOR
		SELECT pl.`user_id`, pl.`partner_loan_id`,
			ROUND(AES_DECRYPT(pl.`running_balance`, encryption_key ()),2),
			ROUND(AES_DECRYPT(pl.`system_amortization`, encryption_key ()),2),
			ROUND(AES_DECRYPT(pl.`user_amortization`, encryption_key ()),2),
			pl.`loan_status_id`, ROUND(AES_DECRYPT( pl.`total_amount_paid`, encryption_key ()),2),
			pl.`no_payments_paid`, pl.`no_payments_remaining`
		FROM ww_payroll_partners_loan pl
			WHERE pl.`deleted` = 0
			AND user_id = puserid
			and partner_loan_id = ploan_id
			AND AES_DECRYPT( pl.`running_balance` , encryption_key() ) > 0 AND pl.`loan_status_id` = 2;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	
	OPEN loan;
	myLoop: LOOP
		FETCH loan INTO emp_id, ploan_id, run_bal, sys_amort, user_amort, ln_status_id, tot_amt_pd, no_pay_pd, no_pay_rem;
		
		IF done THEN
		    CLOSE loan;
		    LEAVE myLoop;
		END IF;
		IF amor > 0 THEN
			BEGIN
				SET run_bal = run_bal + amor;
				IF run_bal < sys_amort THEN
					SET sys_amort = run_bal;
				END IF;
				IF run_bal < user_amort THEN
					SET user_amort = run_bal;
				END IF;
				
				SET tot_amt_pd = tot_amt_pd - amor;
				SET no_pay_pd = no_pay_pd - 1;
			END;
		END IF;
		
		IF pay_mode = 3 THEN
			SET pay_mode = 2;
		END IF;
		IF pay_mode = 4 THEN
			SET pay_mode = 1;
		END IF;
		
		IF run_bal <= 0.001 THEN
			SET ln_status_id = 4;
		END IF;
		
		IF pay_mode = 3 OR pay_mode = 2 THEN
			BEGIN
				IF amor != 0 THEN
					SET no_pay_rem = ROUND(run_bal / user_amort);
				END IF;
				IF no_pay_rem * user_amort < run_bal THEN
					SET no_pay_rem = no_pay_rem - 1;
				END IF;
			END;
		END IF;
		
		IF pay_mode = 4 OR pay_mode = 1 THEN
			BEGIN
				IF amor != 0 THEN
					SET no_pay_rem = ROUND(run_bal / sys_amort);
				END IF;
				IF no_pay_rem * sys_amort < run_bal THEN
					SET no_pay_rem = no_pay_rem - 1;
				END IF;
			END;
		END IF;
		
		UPDATE ww_payroll_partners_loan SET 
			`running_balance` = AES_ENCRYPT( ROUND( run_bal, 2) , encryption_key() ),
			`system_amortization` = AES_ENCRYPT( ROUND( sys_amort, 2) , encryption_key() ),
			`user_amortization` = AES_ENCRYPT( ROUND( user_amort, 2) , encryption_key() ),
			`total_arrears` = AES_ENCRYPT( ROUND( @arrears, 2) , encryption_key() ),
			`total_amount_paid` = AES_ENCRYPT( ROUND( tot_amt_pd, 2) , encryption_key() ),
			`last_payment_date` = paydate,
			`loan_status_id` = ln_status_id,
			`payment_mode_id` = pay_mode,
			`no_payments_paid` = no_pay_pd,
			`no_payments_remaining` = no_pay_rem
		WHERE partner_loan_id  = ploan_id AND `user_id` = emp_id;
	END LOOP;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_performance_appraisal_change_pending_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_performance_appraisal_change_pending_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_performance_appraisal_change_pending_approvers`(IN user_ids VARCHAR(256), IN class_id INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    DECLARE appraisalid INT;
    DECLARE approverid INT;
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE forms CURSOR FOR
       SELECT  pap.`appraisal_id`, pap.`user_id`, paa.approver_id 
       FROM ww_performance_appraisal_applicable pap 
	JOIN `ww_performance_appraisal_approver` paa ON pap.appraisal_id = paa.appraisal_id
	AND pap.user_id = paa.user_id
       AND FIND_IN_SET(approver_id, user_ids) AND status_id > 0 AND status_id < 4;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- START TRANSACTION;
        
    OPEN forms;
    
    REPEAT
       FETCH forms INTO appraisalid, userid, approverid;
       
       IF NOT done THEN
	   DELETE from ww_performance_appraisal_approver 
	   WHERE appraisal_id = appraisalid AND user_id = userid;
           CALL `sp_performance_appraisal_populate_approvers`(appraisalid, userid);
           UPDATE ww_performance_planning_applicable 
           SET to_user_id = getFirstApprover(appraisalid, userid)
           WHERE appraisal_id = appraisalid AND user_id = userid;    
	   SET rec = rec + 1;
	   
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE forms;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_performance_appraisal_get_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_performance_appraisal_get_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_performance_appraisal_get_approvers`(IN appraisalid INT(11), IN userid INT(11))
BEGIN
          -- 
          -- [0] Override from USERS
          -- 
          SET @rec = 0;
          SET @class = '';
                   
          
          SELECT c.`class_code`, COUNT(a.`id`) INTO @class, @rec
          FROM `ww_approver_class_user` a
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE a.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
                    
          IF @rec > 0 THEN
             SELECT appraisalid, userid, `approver_id`, `condition`, `sequence`, 0
             FROM `ww_approver_class_user` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`approver_id`<>userid 
             AND a.user_id = userid
             GROUP BY 3;   
          ELSE   
          -- 
          -- [1] Override from POSITION
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id`
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
          
          IF @rec > 0 THEN
             SELECT appraisalid, userid, `approver_id`, `condition`, `sequence`, 0
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
             JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
             AND a.department_id = e.department_id AND a.company_id = e.company_id
             GROUP BY 3;   
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
             WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.`approver_id`<>userid AND a.deleted = 0;
          
             IF @rec > 0 THEN
		SELECT appraisalid, userid, `approver_id`, `condition`, `sequence`, 0
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
		JOIN `users_profile` e ON e.department_id = a.`department_id` AND e.`user_id`=userid
                WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
                AND a.company_id = e.company_id 
                GROUP BY 3;        
             ELSE
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
                WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
          
                IF @rec > 0 THEN
		   SELECT appraisalid, userid, `approver_id`, `condition`, `sequence`, 0
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
                   GROUP BY 3;
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
             
          END IF; -- IF POSITION        
             
          END IF; -- IF USERS          
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_performance_appraisal_populate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_performance_appraisal_populate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_performance_appraisal_populate_approvers`(IN appraisalid INT(11), IN userid INT(11), IN appraiseeid INT(11))
BEGIN
          -- 
          -- [0] Override from USERS
          -- 
          SET @rec = 0;
          SET @class = '';
                    
          SELECT c.`class_code`, COUNT(a.`id`) INTO @class, @rec
          FROM `ww_approver_class_user` a
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE a.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
          
          IF @rec > 0 THEN
             INSERT INTO `ww_performance_appraisal_approver`
             (`appraisal_id`, `appraisee_id`, `user_id`, `approver_id`, `condition`, `sequence`, `performance_status_id`)
             SELECT appraisalid, appraiseeid, userid, `approver_id`, `condition`, `sequence`, 0
             FROM `ww_approver_class_user` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`approver_id`<>userid 
             AND a.user_id = userid
             -- GROUP BY 3
             ON DUPLICATE KEY UPDATE `deleted`=0;                              
          ELSE     
          -- 
          -- [1] Override from POSITION
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id`
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
          
          IF @rec > 0 THEN
             INSERT INTO `ww_performance_appraisal_approver`
             (`appraisal_id`, `appraisee_id`, `user_id`, `approver_id`, `condition`, `sequence`, `performance_status_id`)
             SELECT appraisalid, appraiseeid, userid, `approver_id`, `condition`, `sequence`, 0
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
             JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
             AND a.department_id = e.department_id AND a.company_id = e.company_id
             -- GROUP BY 3
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
             WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.`approver_id`<>userid AND a.deleted = 0;
          
             IF @rec > 0 THEN
                INSERT INTO `ww_performance_appraisal_approver`
                (`appraisal_id`, `appraisee_id`, `user_id`, `approver_id`, `condition`, `sequence`, `performance_status_id`)
                SELECT appraisalid, appraiseeid, userid, `approver_id`, `condition`, `sequence`, 0
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
		        JOIN `users_profile` e ON e.department_id = a.`department_id` AND e.`user_id`=userid
                WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
                AND a.company_id = e.company_id 
                -- GROUP BY 3
                ON DUPLICATE KEY UPDATE `deleted`=0;             
             ELSE
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
                WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
          
                IF @rec > 0 THEN
                   INSERT INTO `ww_performance_appraisal_approver`
                   (`appraisal_id`, `appraisee_id`, `user_id`, `approver_id`, `condition`, `sequence`, `performance_status_id`)
                   SELECT appraisalid, appraiseeid, userid, `approver_id`, `condition`, `sequence`, 0
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
                   -- GROUP BY 3
                   ON DUPLICATE KEY UPDATE `deleted`=0;             
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
             
          END IF; -- IF POSITION     
             
          END IF; -- IF USERS              
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_performance_planning_change_pending_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_performance_planning_change_pending_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_performance_planning_change_pending_approvers`(IN user_ids VARCHAR(256), IN class_id INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    DECLARE planningid INT;
    DECLARE approverid INT;
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE forms CURSOR FOR
       SELECT  pap.`planning_id`, pap.`user_id`, paa.approver_id 
       FROM ww_performance_planning_applicable pap 
	   JOIN `ww_performance_planning_approver` paa ON pap.planning_id = paa.planning_id
	      AND pap.user_id = paa.user_id
          AND FIND_IN_SET(approver_id, user_ids) AND (status_id > 0 AND status_id < 4);
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    INSERT INTO `ww_system_messages` (msg_code,msg) VALUES ('PLANNING-APPROVER',CONCAT(user_ids,'-',class_id));
 
    -- START TRANSACTION;
        
    OPEN forms;
    
    REPEAT
       FETCH forms INTO planningid, userid, approverid;
       
       IF NOT done THEN
	      DELETE FROM ww_performance_planning_approver 
	      WHERE planning_id = planningid AND user_id = userid;
          
          CALL `sp_performance_planning_populate_approvers`(planningid, userid);
          
          UPDATE ww_performance_planning_applicable 
          SET to_user_id = getFirstApprover(planningid, userid)
          WHERE planning_id = planningid AND user_id = userid;    
          
	      SET rec = rec + 1;
          INSERT INTO `ww_system_messages` (msg_code,msg) VALUES ('CHANGE-APPROVER',CONCAT(userid,'-',planningid));
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE forms;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_performance_planning_get_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_performance_planning_get_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_performance_planning_get_approvers`(IN planningid INT(11), IN userid INT(11))
BEGIN
          -- 
          -- [0] Override from USERS
          -- 
          SET @rec = 0;
          SET @class = '';
          
          
          SELECT c.`class_code`, COUNT(a.`id`) INTO @class, @rec
          FROM `ww_approver_class_user` a
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE a.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
                    
          IF @rec > 0 THEN
             SELECT planningid, userid, `approver_id`, `condition`, `sequence`, 0
             FROM `ww_approver_class_user` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`approver_id`<>userid 
             AND a.user_id = userid
             GROUP BY 3;   
          ELSE     
          -- 
          -- [1] Override from POSITION
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id`
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
          
          IF @rec > 0 THEN
             SELECT planningid, userid, `approver_id`, `condition`, `sequence`, 0
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
             JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
             AND a.department_id = e.department_id AND a.company_id = e.company_id
             GROUP BY 3;   
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
             WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.`approver_id`<>userid AND a.deleted = 0;
          
             IF @rec > 0 THEN
		SELECT planningid, userid, `approver_id`, `condition`, `sequence`, 0
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
		JOIN `users_profile` e ON e.department_id = a.`department_id` AND e.`user_id`=userid
                WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
                AND a.company_id = e.company_id 
                GROUP BY 3;        
             ELSE
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
                WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
          
                IF @rec > 0 THEN
		   SELECT planningid, userid, `approver_id`, `condition`, `sequence`, 0
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
                   GROUP BY 3;
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
             
          END IF; -- IF POSITION   
             
          END IF; -- IF USERS          
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_performance_planning_initialize_template` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_performance_planning_initialize_template` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_performance_planning_initialize_template`(IN planningid INT, IN userid INT)
BEGIN
	DELETE FROM ww_performance_planning_applicable_fields WHERE planning_id = planningid AND user_id = userid;
	DELETE FROM ww_performance_planning_applicable_items WHERE planning_id = planningid AND user_id = userid;
	DELETE FROM ww_performance_planning_crowdsource WHERE planning_id = planningid AND user_id = userid;
       
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_performance_planning_populate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_performance_planning_populate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_performance_planning_populate_approvers`(IN planningid INT(11), IN userid INT(11), IN appraiseeid INT(11))
BEGIN
          -- 
          -- [0] Override from USERS
          -- 
          SET @rec = 0;
          SET @class = '';
          
          SELECT c.`class_code`, COUNT(a.`id`) INTO @class, @rec
          FROM `ww_approver_class_user` a
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE a.`user_id`=userid AND c.`class_code`='PPA'
          AND a.deleted = 0;
          
          IF @rec > 0 THEN
             INSERT INTO `ww_performance_planning_approver`
             (`planning_id`, `appraisee_id`, `user_id`, `approver_id`, `condition`, `sequence`, `performance_status_id`)
             SELECT planningid, appraiseeid, userid, `approver_id`, `condition`, `sequence`, 0
             FROM `ww_approver_class_user` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`approver_id`<>userid
             AND a.user_id = userid
             -- GROUP BY 3
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE     
          -- 
          -- [1] Override from POSITION
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id`
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
          
          IF @rec > 0 THEN
             INSERT INTO `ww_performance_planning_approver`
             (`planning_id`, `appraisee_id`, `user_id`, `approver_id`, `condition`, `sequence`, `performance_status_id`)
             SELECT planningid, appraiseeid, userid, `approver_id`, `condition`, `sequence`, 0
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
             JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
             AND a.department_id = e.department_id AND a.company_id = e.company_id
             -- GROUP BY 3
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
             WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.`approver_id`<>userid AND a.deleted = 0;
          
             IF @rec > 0 THEN
                INSERT INTO `ww_performance_planning_approver`
		(`planning_id`, `appraisee_id`, `user_id`, `approver_id`, `condition`, `sequence`, `performance_status_id`)
		SELECT planningid, appraiseeid, userid, `approver_id`, `condition`, `sequence`, 0
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
		JOIN `users_profile` e ON e.department_id = a.`department_id` AND e.`user_id`=userid
                WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
                AND a.company_id = e.company_id 
                -- GROUP BY 3
                ON DUPLICATE KEY UPDATE `deleted`=0;             
             ELSE
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
                WHERE b.`user_id`=userid AND c.`class_code`='PPA' AND a.deleted = 0;
          
                IF @rec > 0 THEN
                   INSERT INTO `ww_performance_planning_approver`
		   (`planning_id`, `appraisee_id`, `user_id`, `approver_id`, `condition`, `sequence`, `performance_status_id`)
                   SELECT planningid, appraiseeid, userid, `approver_id`, `condition`, `sequence`, 0
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
                   -- GROUP BY 3
                   ON DUPLICATE KEY UPDATE `deleted`=0;             
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
             
          END IF; -- IF POSITION        
             
          END IF; -- IF USER            
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_play_redeemed` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_play_redeemed` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_play_redeemed`(IN userid INT(11), IN itemid INT(11))
BEGIN
    
    -- [1] Transaction
	INSERT INTO ww_play_partner_redeemed
	(user_id, item_id, points)
	SELECT userid, item_id, points
	FROM ww_play_redeemable 
	WHERE item_id = itemid LIMIT 1;
    
    -- [2] Summary Points
    SET @rec = 0;
    SELECT user_id INTO @rec 
    FROM ww_play_partner_points LIMIT 1;
    
    IF @rec = 0 THEN
       INSERT INTO ww_play_partner_points
       (user_id, used_points, redeemed)
	   SELECT userid, points, 1
	   FROM ww_play_redeemable WHERE item_id = itemid LIMIT 1;
	ELSE
	   UPDATE ww_play_partner_points pp, ww_play_redeemable pr
	   SET pp.used_points = pp.used_points + pr.points,
	       pp.redeemed = pp.redeemed + 1
	   WHERE pp.user_id = @rec AND pr.item_id = itemid;
	END IF;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_recruitment_manpower_plan_approval` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_recruitment_manpower_plan_approval` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_recruitment_manpower_plan_approval`(IN planid INT, IN statusid INT, IN approverid int)
BEGIN
   -- [1]
   UPDATE `ww_recruitment_manpower_plan_approver`
   SET
      `plan_status_id` = statusid
   WHERE 
      `plan_id` = planid AND 
      `approver_id` = approverid AND
      `deleted` = 0
   LIMIT 1;
             
   -- set next approver
   IF statusid = 3 THEN
      SET @seq = (SELECT MAX(sequence) FROM `ww_recruitment_manpower_plan_approver` WHERE `plan_id`=planid AND `plan_status_id`=3 AND `deleted`=0)+1;
      UPDATE `ww_recruitment_manpower_plan_approver`
      SET `plan_status_id` = 2
      WHERE `plan_id` = planid AND `sequence` = @seq AND `deleted`=0 AND `condition` = 'By Level';
   END IF;
  
   -- [2] Update status by sequence to approver
   -- Change the status of the next approver
   -- 20150722 Only work on BY LEVEL
   
   -- 20150722 inlcude EITHER OF and ALL on approval condition
   -- [2.5] Check condition on approver   
   SET @conditions = '';
   
   SELECT `condition` INTO @conditions 
   FROM `ww_recruitment_manpower_plan_approver`
   WHERE 
      `plan_id` = planid AND 
      `approver_id` = approverid AND
      `deleted` = 0
   LIMIT 1;
   
   -- [3] Update status on header
   -- Check if all approver already approved
   IF(@conditions = 'Either Of') THEN
	   UPDATE `ww_recruitment_manpower_plan`
	   SET
	      `manpower_plan_status_id` = statusid,
	      `date_approved` = IF(statusid=3, NOW(), `date_approved`),
	      `date_declined` = IF(statusid=4, `date_declined`, NOW())
	   WHERE 
	      `plan_id` = planid 
	   LIMIT 1;
	   
	   CALL sp_recruitment_manpower_plan_transfer_position(planid);
   ELSE
	   SET @appCount    = 0;
	   SET @appApproved = 0;
	   SET @appDeclined = 0;
	   
	   SELECT COUNT(*), SUM(IF(`plan_status_id`=3,1,0)), SUM(IF(`plan_status_id`=4,1,0)) 
	   INTO @appCount, @appApproved, @appDeclined
	   FROM `ww_recruitment_manpower_plan_approver`
	   WHERE `plan_id`=planid;
	   
	   UPDATE `ww_recruitment_manpower_plan`
	   SET
	      `manpower_plan_status_id` = IF(@appCount=@appApproved, 3, IF(@appCount=@appDeclined, 4, IF(@appDeclined > 0, 4, IF(@appApproved > 0, 2, 2)))),
	      `date_approved` = IF(@appCount=@appApproved, NOW(), `date_approved`),
	      `date_declined` = IF(@appDeclined > 0, NOW(), `date_declined`)
	   WHERE 
	      `plan_id` = planid 
	   LIMIT 1;
	   
	   if @appCount=@appApproved then
		CALL sp_recruitment_manpower_plan_transfer_position(planid);
	   end if;
   END IF;
   SET @code_type = CASE
	WHEN statusid = 3 THEN 'approved'
	WHEN statusid = 4 THEN 'disapproved' 
	ELSE 'approved' 
	END;      
   -- [4] Push email 
   CALL sp_manpower_plan_email(planid,@code_type);
   -- 
   
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_recruitment_manpower_plan_pending_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_recruitment_manpower_plan_pending_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_recruitment_manpower_plan_pending_approvers`(IN user_ids VARCHAR(256), IN class_id INT(11))
BEGIN
    DECLARE done INT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE recruitmentRequests CURSOR FOR
       SELECT  amp.`plan_id`, amp.`user_id` FROM `ww_recruitment_manpower_plan` amp WHERE `deleted`=0
       AND FIND_IN_SET(user_id, user_ids) AND ( `status_id` < 3 AND status_id > 0);
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    -- START TRANSACTION;
    
    OPEN recruitmentRequests;
    
    REPEAT
       FETCH recruitmentRequests INTO recordid, userid;
       IF NOT done THEN
	   DELETE FROM ww_recruitment_manpower_plan_approver WHERE plan_id = recordid;
           -- CALL `sp_mrf_populate_approvers`(recordid, userid);
           CALL `sp_recruitment_manpower_plan_populate_approvers`(recordid, userid);
           UPDATE ww_recruitment_manpower_plan SET `status_id` = 2 WHERE plan_id = recordid;      
	   SET rec = rec + 1;
	   
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE recruitmentRequests;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_recruitment_manpower_plan_populate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_recruitment_manpower_plan_populate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_recruitment_manpower_plan_populate_approvers`(IN planid INT(11), IN userid INT(11))
BEGIN
	-- 
          -- [1] Override from POSITION
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
          FROM `ww_approver_class_user` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id`
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE b.`user_id`=userid AND c.`class_code`='AMP';
          
          IF @rec > 0 THEN
             INSERT INTO `ww_recruitment_manpower_plan_approver`
             (`plan_id`, `user_id`, `approver_id`, `display_name`, `condition`, `sequence`, `plan_status_id`)
             SELECT planid, userid, `approver_id`, `alias`, `condition`, `sequence`, 2
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
             JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
             AND a.department_id = e.department_id AND a.company_id = e.company_id
             GROUP BY 3
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
             WHERE b.`user_id`=userid AND c.`class_code`='AMP' AND a.`approver_id`<>userid;
          
             IF @rec > 0 THEN
                INSERT INTO `ww_recruitment_manpower_plan_approver`
		(`plan_id`, `user_id`, `approver_id`, `display_name`, `condition`, `sequence`, `plan_status_id`)
		SELECT planid, userid, `approver_id`, `alias`, `condition`, `sequence`, 2
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
		JOIN `users_profile` e ON e.department_id = a.`department_id` AND e.`user_id`=userid
                WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
                AND a.company_id = e.company_id 
                GROUP BY 3
                ON DUPLICATE KEY UPDATE `deleted`=0;             
             ELSE
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
                WHERE b.`user_id`=userid AND c.`class_code`='AMP';
          
                IF @rec > 0 THEN
                   INSERT INTO `ww_recruitment_manpower_plan_approver`
		   (`plan_id`, `user_id`, `approver_id`, `display_name`, `condition`, `sequence`, `plan_status_id`)
		   SELECT planid, userid, `approver_id`, `alias`, `condition`, `sequence`, 2
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
                   GROUP BY 3
                   ON DUPLICATE KEY UPDATE `deleted`=0;             
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
             
          END IF; -- IF POSITION 
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_recruitment_manpower_plan_transfer_position` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_recruitment_manpower_plan_transfer_position` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_recruitment_manpower_plan_transfer_position`(IN planid INT(11))
BEGIN
    
    SET @position = '';
    
    SELECT `position` into @position from `ww_recruitment_manpower_plan_position_new` where plan_id = planid;
    
    INSERT INTO `ww_users_position`
       ( `position` )
       SELECT 
          `position`
       FROM 
             `ww_recruitment_manpower_plan_position_new`
       WHERE 
              plan_id = planid;
    
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_recruitment_request_pending_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_recruitment_request_pending_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_recruitment_request_pending_approvers`(IN user_ids VARCHAR(256), IN class_id INT(11))
BEGIN
    DECLARE done INT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE recruitmentRequests CURSOR FOR
       SELECT  tr.`request_id`, tr.`user_id` FROM `ww_recruitment_request` tr WHERE `deleted`=0
       AND FIND_IN_SET(user_id, user_ids) AND ( `status_id` < 3 AND status_id > 0);
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    -- START TRANSACTION;
    
    OPEN recruitmentRequests;
    
    REPEAT
       FETCH recruitmentRequests INTO recordid, userid;
       IF NOT done THEN
	   DELETE FROM ww_recruitment_request_approver WHERE request_id = recordid;
           -- CALL `sp_mrf_populate_approvers`(recordid, userid);
           CALL `sp_recruitment_request_populate_approvers`(recordid, userid);
           UPDATE ww_recruitment_request SET `status_id` = 2 WHERE request_id = recordid;      
	   SET rec = rec + 1;
	   
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE recruitmentRequests;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_recruitment_request_populate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_recruitment_request_populate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_recruitment_request_populate_approvers`(IN requestid INT(11), IN userid INT(11))
BEGIN
	  -- 
          -- [0] Override from USER
          -- 
          
          SET @rec = 0;
          SET @class = '';
          
	  SELECT c.`class_code`, COUNT(a.`id`) INTO @class, @rec
          FROM `ww_approver_class_user` a
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE a.`user_id`=userid AND c.`class_code`='REC' AND a.deleted = 0;
          
          IF @rec > 0 THEN
             INSERT INTO `ww_recruitment_request_approver`
             (`request_id`, `user_id`, `approver_id`, `condition`, `sequence`, `status_id`)
             SELECT requestid, `userid`, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,1))
             FROM `ww_approver_class_user` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`approver_id`<>userid
             AND a.user_id = userid
             -- GROUP BY 2
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE  
		  -- 
		  -- [1] Override from POSITION
		  -- 
		  SET @rec = 0;
		  SET @class = '';
		  SET @positions = '';
		  SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
		  FROM `ww_approver_class_position` a
		  JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id`
		  JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
		  WHERE b.`user_id`=userid AND c.`class_code`='REC';
		  
		  IF @rec > 0 THEN
		     INSERT INTO `ww_recruitment_request_approver`
		     (`request_id`, `user_id`, `approver_id`, `condition`, `sequence`, `status_id`)
		     SELECT requestid, userid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,1))
		     FROM `ww_approver_class_position` a
		     JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
		     JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
		     JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
		     WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
		     AND a.department_id = e.department_id AND a.company_id = e.company_id
		     GROUP BY 3
		     ON DUPLICATE KEY UPDATE `deleted`=0;             
		  ELSE     
			    
		     -- [2] Override from DEPARTMENT
		     -- 
		     SET @rec = 0;
		     SET @class = '';
		     SET @department = '';
		  
		     SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
		     FROM `ww_approver_class_department` a
		     JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
		     JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
		     WHERE b.`user_id`=userid AND c.`class_code`='REC' AND a.`approver_id`<>userid;
		  
		     IF @rec > 0 THEN
			INSERT INTO `ww_recruitment_request_approver`
			(`request_id`, `user_id`, `approver_id`, `condition`, `sequence`, `status_id`)
			SELECT requestid, userid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,1))
			FROM `ww_approver_class_department` a
			JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
			JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
			JOIN `users_profile` e ON e.department_id = a.`department_id` AND e.`user_id`=userid
			WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
			AND a.company_id = e.company_id 
			GROUP BY 3
			ON DUPLICATE KEY UPDATE `deleted`=0;             
		     ELSE
			--   
			-- [3] Override from COMPANY
			-- 
			SET @rec = 0;
			SET @class = '';
			SET @company = '';
		  
			SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
			FROM `ww_approver_class_company` a
			JOIN `users_profile` b ON b.company_id = a.`company_id`
			JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
			WHERE b.`user_id`=userid AND c.`class_code`='REC';
		  
			IF @rec > 0 THEN
			   INSERT INTO `ww_recruitment_request_approver`
			   (`request_id`, `user_id`, `approver_id`, `condition`, `sequence`, `status_id`)
			   SELECT requestid, userid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,1))
			   FROM `ww_approver_class_company` a
			   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
			   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
			   GROUP BY 3
			   ON DUPLICATE KEY UPDATE `deleted`=0;             
			END IF; -- IF COMPANY
		     
		     END IF; -- IF DEPARTMENT
             end if;  -- IF POSITION
          END IF; -- IF user 
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_resources_erequest_change_pending_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_resources_erequest_change_pending_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_resources_erequest_change_pending_approvers`(IN user_ids VARCHAR(256), IN class_id INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE erequests CURSOR FOR
       SELECT  tr.`request_id`, tr.`user_id` FROM `ww_resources_request` tr WHERE `deleted`=0
       AND FIND_IN_SET(user_id, user_ids) AND request_status_id IN (2,3,5);
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- START TRANSACTION;
        
    OPEN erequests;
    
    REPEAT
       FETCH erequests INTO recordid, userid;
       
       IF NOT done THEN
	   DELETE FROM ww_resources_request_approver WHERE request_id = recordid;
           CALL `sp_resources_request_populate_approvers`(recordid, userid);
           UPDATE ww_resources_request SET request_status_id = 2 WHERE request_id = recordid;      
	   SET rec = rec + 1;
	   
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE erequests;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_resources_request_populate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_resources_request_populate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_resources_request_populate_approvers`(IN requestid INT(11), IN userid INT(11))
BEGIN
          -- 
          -- [1] Override from POSITION
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id` AND b.department_id=a.department_id
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          WHERE b.`user_id`=userid AND c.`class_code`= 'EREQ';
          
          IF @rec > 0 THEN
             INSERT INTO `ww_resources_request_approver`
             (`request_id`, `user_id`, `condition`, `sequence`, `request_status_id`)
             SELECT requestid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,3))
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.department_id=a.department_id AND u.user_id=userid
             WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND a.`approver_id`<>userid
             GROUP BY 2
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
	     WHERE b.`user_id`=userid AND c.`class_code`= 'EREQ'
             AND a.`approver_id`<>userid;
          
             IF @rec > 0 THEN
                INSERT INTO `ww_resources_request_approver`
                (`request_id`, `user_id`, `condition`, `sequence`, `request_status_id`)
                SELECT requestid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,3))
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
                WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.`approver_id`<>userid
                GROUP BY 2
                ON DUPLICATE KEY UPDATE `request_status_id`=VALUES(`request_status_id`), `sequence`=VALUES(`sequence`), `deleted`=0;             
             ELSE
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
	        WHERE b.`user_id`=userid AND c.`class_code`= 'EREQ'
                AND a.`approver_id`<>userid;
          
                IF @rec > 0 THEN
                   INSERT INTO `ww_resources_request_approver`
                   (`request_id`, `user_id`, `condition`, `sequence`, `request_status_id`)
                   SELECT requestid, `approver_id`, `condition`, `sequence`, IF(@rec=1,2,IF(`sequence`=1,2,3))
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company AND a.`approver_id`<>userid
                   GROUP BY 2
                   ON DUPLICATE KEY UPDATE `deleted`=0;             
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
             
          END IF; -- IF POSITION          
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_system_support_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_system_support_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_system_support_email`(IN msgid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE msgcode   VARCHAR(64);
    DECLARE msgbody   TEXT;
    DECLARE createdon DATETIME;
    DECLARE fattach   VARCHAR(128);
    DECLARE fupload   VARCHAR(128);
    DECLARE email     VARCHAR(128);
    DECLARE sender    VARCHAR(128);
    
    DECLARE supportbox CURSOR FOR
       SELECT ss.msg_code, ss.msg, ss.created_on, ss.attachment, ss.upload,
              u.email, IFNULL(up.firstname,up.lastname)sender
       FROM `ww_system_support` ss
       INNER JOIN `users` u ON u.user_id=ss.user_id
       INNER JOIN `users_profile` up ON up.user_id=ss.user_id
       WHERE ss.`msg_id`=msgid AND IFNULL(u.`email`,'')<>'';
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    OPEN supportbox;
    
    REPEAT
       FETCH supportbox INTO msgcode, msgbody, createdon, fattach, fupload, email, sender;
       
       IF NOT done THEN
           SET rec = rec + 1;
           
           -- {{retrieve the email template}}
           SET @emailto = email;
           SET @emailbcc = 'rdlozada@teemworx.com';
           SET @emailsubject = '';
           SET @emailbody = '';
       
           SELECT `subject`,`body` INTO @emailsubject, @emailbody
           FROM `ww_system_template`
           WHERE `code` = 'SUPPORT-BOX-ACKNOWLEDGE' LIMIT 1;
           
           IF @emailsubject <> '' THEN
              -- {{replace variables}}
              SET @emailbody = REPLACE(@emailbody, '{{alias}}', sender);
              SET @emailbody = REPLACE(@emailbody, '{{createdon}}', DATE_FORMAT(createdon, '%b-%e %l:%i%p'));
              
              -- {{link}}
              SET @url = get_config('System','URL');
	          IF RIGHT(TRIM(@url),1) <> '/' THEN
	             SET @url = CONCAT(TRIM(@url),'/');
	          END IF;
	   
              -- {{header/email logo}}
              SET @logo = get_config('System','print_logo'); 
	          IF TRIM(@logo) <> '' THEN
	             SET @logo = CONCAT(@url,@logo);
	          ELSE
	             SET @logo = CONCAT(@url,get_config('System','logo'));
	          END IF;
	   	         
              SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
              SET @system_fromaddress = (SELECT `value` FROM `ww_config` WHERE `key`='from_address' LIMIT  1);
              SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
              SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
              SET @emailbody = REPLACE(@emailbody, '{{system_route}}', @url);
              SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
               
              -- {{insert to table}}
              IF TRIM(@emailbody) <> '' THEN
                 INSERT INTO `ww_system_email_queue` (`to`,`bcc`,`subject`,`body`)
                 SELECT @emailto, @emailbcc, @emailsubject, @emailbody;
              END IF;
              
              -- SELECT @emailto, @emailsubject, @emailbody;
              
              -- {{retrieve the email template}}
              SET @emailto = @system_fromaddress;
              SET @emailcc = 'rdlozada@teemworx.com';
              SET @emailsubject = '';
              SET @emailbody = '';
       
              SELECT `subject`,`body` INTO @emailsubject, @emailbody
              FROM `ww_system_template`
              WHERE `code` = 'SUPPORT-BOX-ADMIN' LIMIT 1;
           
              IF @emailsubject <> '' THEN
                 -- {{insert to table}}
                 IF TRIM(@emailbody) <> '' THEN
                    SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
                    SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
                    SET @emailbody = REPLACE(@emailbody, '{{system_route}}', @url);
                    SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
                    
                    SET @emailbody = REPLACE(@emailbody, '{{createdon}}', DATE_FORMAT(createdon, '%b-%e %l:%i%p'));
                    SET @emailbody = REPLACE(@emailbody, '{{file_screenshot}}', CONCAT('<a target="_blank" href="',@url,fattach,'">',fattach,'</a>'));
                    SET @emailbody = REPLACE(@emailbody, '{{file_attach}}', CONCAT('<a target="_blank" href="',@url,fupload,'">',fupload,'</a>'));
                    
                    INSERT INTO `ww_system_email_queue` (`to`,`cc`,`subject`,`body`)
                    SELECT @emailto, @emailcc, @emailsubject, @emailbody;
                 END IF;
              END IF;
              
           END IF;
        END IF;
        
    UNTIL done END REPEAT;
    
    CLOSE supportbox;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_calendar` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_calendar` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_calendar`(IN datefrom DATE, IN dateto DATE, IN userid INTEGER(11))
BEGIN
    
    -- [1] Work Schedule
    SELECT 
       ts.`shift` `title`, 
       IF(ts.`shift`='Restday', '#bcb8b8', '#4b8df8')  `color`, 
       IF(ts.`shift`='Restday', TRUE, FALSE) `allday`,
       UNIX_TIMESTAMP(CONCAT(`date`,' ',IF(IFNULL(ts.time_start,'00:00:00')='00:00:00', '12:00:00', ts.time_start))) `start`,
       UNIX_TIMESTAMP(CONCAT(`date`,' ',IF(IFNULL(ts.time_end,'00:00:00')='00:00:00', '12:00:00', ts.time_end))) `end`,
       tr.`user_id`, 
       FALSE `editable`, 'SCHEDULE' `type`, 0 `forms_id`, 0 `form_id`, '' reason
    FROM `time_record` tr
    LEFT JOIN `time_shift` ts ON ts.shift_id = IF(IFNULL(tr.aux_shift_id,0)=0, tr.shift_id, tr.aux_shift_id)
    WHERE tr.`user_id`=userid AND (`date` BETWEEN datefrom AND dateto)
    
    -- 
    -- [2] Holidays
    UNION ALL
    SELECT 
       `holiday` `title`, '#ea6734' `color`, TRUE `allday`,
       UNIX_TIMESTAMP(CONCAT(`holiday_date`,' 12:00:00')) `start`,
       UNIX_TIMESTAMP(CONCAT(`holiday_date`,' 12:00:00')) `end`,
       IFNULL(`ww_time_holiday_location`.user_id,0) `user_id`, FALSE `editable`,	
       'HOLIDAYS' `type`, 0 `forms_id`, 0 `form_id`, '' reason
    FROM `time_holiday` 
    LEFT JOIN `ww_time_holiday_location` ON 
       `ww_time_holiday_location`.holiday_id=`time_holiday`.holiday_id AND 
       IF(`time_holiday`.legal=1,0,IF(`time_holiday`.location_count=0,1,`ww_time_holiday_location`.user_id=userid))
    WHERE (`holiday_date` BETWEEN datefrom AND dateto)
    
    -- 
    -- [3] Birthdays
    UNION ALL
    SELECT 
       'It\'s your Birthday' `title`, '#a13cb4' color, TRUE `allday`,
       UNIX_TIMESTAMP(DATE_ADD(CONCAT(`up`.`birth_date`,' 12:00:00'), INTERVAL YEAR(NOW())-YEAR(`up`.`birth_date`) YEAR)) `start`, 
       UNIX_TIMESTAMP(DATE_ADD(CONCAT(`up`.`birth_date`,' 12:00:00'), INTERVAL YEAR(NOW())-YEAR(`up`.`birth_date`) YEAR)) `end`, 
       `u`.user_id, 
       FALSE editable, 'BIRTHDAY' `type`, 0 `forms_id`, 0 `form_id`, '' reason
    FROM `users` `u`
    INNER JOIN `users_profile` `up` ON `up`.user_id=`u`.user_id
    WHERE `u`.`user_id` = userid AND 
    (
       CASE WHEN MONTH(datefrom)=12 THEN 
          ( MONTH(`up`.`birth_date`)=12 OR MONTH(`up`.`birth_date`) BETWEEN 1 AND MONTH(dateto) )
       ELSE 
          ( MONTH(`up`.`birth_date`) BETWEEN MONTH(datefrom) AND MONTH(dateto) )
       END
    )
    
    -- 
    -- [4] Forms
    UNION ALL
    SELECT 
       IF(tf.`form_code` = 'ADDL', 'CL', tf.`form_code` ) `title`,
       -- IF(`form_status_id`=6,'#35aa47',IF(`form_status_id`= 8,'#969696','#ed9090')) `color`, 
       IFNULL(tfs.`color`,'#ffffff') `color`,
       FALSE `allday`,
       UNIX_TIMESTAMP(CONCAT(tfd.`date`,' 12:00:00')) `start`,
       UNIX_TIMESTAMP(CONCAT(tfd.`date`,' 12:00:00')) `end`,
       tf.`user_id`, 
       TRUE `editable`, 'FORM' `type`, tf.`forms_id`, tf.`form_id`, '' reason       
    FROM `time_forms` tf
    INNER JOIN `time_forms_date` tfd ON tfd.`forms_id`=tf.`forms_id`
    LEFT JOIN `ww_time_form_status` tfs ON tfs.`form_status_id`=tf.`form_status_id`
    WHERE tf.`user_id`=userid AND (`date_from` BETWEEN datefrom AND dateto)
    ;
    
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_calendar_manager` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_calendar_manager` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_calendar_manager`(IN datefrom DATE, IN dateto DATE, IN userid INTEGER(11))
BEGIN
    
    SET @role = 0;
    SELECT role_id INTO @role FROM users WHERE user_id = userid LIMIT 1;
    
    -- [1] Work Group Schedule 
    SELECT 
       ts.`shift` `title`, IF(ts.`shift`='Restday', '#bcb8b8', '#4b8df8') color, TRUE `allday`,
       UNIX_TIMESTAMP(CONCAT(`date`,' 12:00:00')) `start`,
       UNIX_TIMESTAMP(CONCAT(`date`,' 12:00:00')) `end`,
       userid `user_id`, FALSE editable, 'SCHEDULE' `type`, 0 `forms_id`, ts.`shift_id` `form_id`, '' reason
    FROM `time_record` tr
    INNER JOIN `time_shift` ts ON ts.shift_id = IF(IFNULL(tr.aux_shift_id,0)=0, tr.shift_id, tr.aux_shift_id)
    INNER JOIN `users_profile` up ON up.`user_id`=tr.`user_id` AND 
       (IF(@role IN (1,2,6), userid=tr.`modified_by`, up.`reports_to_id`=userid) OR up.`reports_to_id`=userid)
    WHERE tr.`date` BETWEEN datefrom AND dateto
    GROUP BY tr.`date`, ts.`shift_id`
    -- 
    -- [2] Holidays
    UNION ALL
    SELECT 
       `holiday` `title`, '#ea6734' `color`, TRUE `allday`,
       UNIX_TIMESTAMP(CONCAT(`holiday_date`,' 12:00:00')) `start`,
       UNIX_TIMESTAMP(CONCAT(`holiday_date`,' 12:00:00')) `end`,
       IFNULL(`ww_time_holiday_location`.user_id,0) `user_id`, FALSE `editable`, 'HOLIDAYS' `type`, 0 `forms_id`, 0 `form_id`, '' reason
    FROM `time_holiday` 
    LEFT JOIN `ww_time_holiday_location` ON 
       `ww_time_holiday_location`.holiday_id=`time_holiday`.holiday_id AND 
       IF(`time_holiday`.legal=1,0,IF(`time_holiday`.location_count=0,1,`ww_time_holiday_location`.user_id=userid))
    WHERE (`holiday_date` BETWEEN datefrom AND dateto)
    -- 
    -- [3] Birthdays
    UNION ALL
    SELECT 
       'It\'s your Birthday' `title`, '#a13cb4' color, TRUE `allday`,
       UNIX_TIMESTAMP(DATE_ADD(CONCAT(`up`.`birth_date`,' 12:00:00'), INTERVAL YEAR(NOW())-YEAR(`up`.`birth_date`) YEAR)) `start`, 
       UNIX_TIMESTAMP(DATE_ADD(CONCAT(`up`.`birth_date`,' 12:00:00'), INTERVAL YEAR(NOW())-YEAR(`up`.`birth_date`) YEAR)) `end`, 
       `u`.user_id, FALSE editable, 'BIRTHDAY' `type`, 0 `forms_id`, 0 `form_id`, '' reason
       
    FROM `users` `u`
    INNER JOIN `users_profile` `up` ON `up`.user_id=`u`.user_id
    WHERE `u`.`user_id` = userid AND
    (
       CASE WHEN MONTH(datefrom)=12 THEN 
          ( MONTH(`up`.`birth_date`)=12 OR MONTH(`up`.`birth_date`) BETWEEN 1 AND MONTH(dateto) )
       ELSE 
          ( MONTH(`up`.`birth_date`) BETWEEN MONTH(datefrom) AND MONTH(dateto) )
       END
    )
    ;
    
    
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_calendar_manager_insert` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_calendar_manager_insert` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_calendar_manager_insert`(IN userid INT(11), IN dates DATE, IN shiftid INT(1))
BEGIN
    
    /* force creation of a record on ww_time_record */
    -- CALL sp_time_period_populate_user(dates,dates,userid);
    
    -- [1] This will perform update
    INSERT INTO `time_record` (`user_id`, `date`, `aux_shift_id`)
    SELECT userid, dates, shiftid
    ON DUPLICATE KEY UPDATE `aux_shift_id` = shiftid;
    
    
    -- [2] update raw 
    CALL sp_time_record_raw_reupload (userid, dates);
    
    /* need to filter via immediate id */
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_calendar_manager_insert_weekly` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_calendar_manager_insert_weekly` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_calendar_manager_insert_weekly`(IN userid INT(11), IN dates DATE, IN calendarid INT(1))
BEGIN
    /* 2017-03-21 : Added checking of forms application
                  : Re-upload of time-record-raw
    */
    
    -- [01] force creation of a record on ww_time_record 
    -- CALL sp_time_period_populate_user(dates,dates,userid);
    -- ?
    
    -- [02] force update timein, timeout if there are filed application
    -- ?
    
    
    -- [03] this will perform update
    INSERT INTO `ww_time_record` (`user_id`, `date`, `aux_shift_id`)
    SELECT userid, dates, tswc.`shift_id`
    FROM `ww_time_shift_weekly_calendar` tswc 
    WHERE tswc.`calendar_id`=calendarid AND tswc.`week_name`=DAYNAME(dates)
    ON DUPLICATE KEY UPDATE `aux_shift_id` = tswc.`shift_id`, `modified_on`=NOW();
    
    
    -- [04] update raw 
    CALL sp_time_record_raw_reupload (userid, dates);
    
    /* need to filter via immediate id */
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_calendar_manager_list` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_calendar_manager_list` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_calendar_manager_list`(IN immediateid INT(11), IN dates DATE, IN shiftid INT(1), IN role INT(11))
BEGIN
    
    /**
    - ORIGINAL SCRIPT
    
    SELECT tr.user_id, u.`display_name`, p.`id_number`, tr.shift_id, tr.shift
    FROM `time_record` tr, `users` u, `partners` p
    WHERE 
       tr.`user_id` = u.`user_id` AND
       u.`user_id` = p.`user_id` AND
       u.`can_view` = 1 AND
       tr.`date`=dates AND 
       tr.`shift_id`=shiftid
    ORDER BY u.`display_name`
    LIMIT 30;
    
    -- need to filter via immediate id */
    
    -- just a quick fix to override current query script
    -- and to enable admin data access	
    
    -- 2 is HR Administrator
    -- 6 is HR Timekeeper
    
	SELECT 
		tr.`user_id`, 
		u.`display_name`,
		p.`id_number`,
		ts.shift_id,
		ts.shift
		
	FROM ww_time_record tr 
	INNER JOIN ww_time_shift ts ON IF(IFNULL(tr.`aux_shift_id`,0)=0,tr.`shift_id`,tr.`aux_shift_id`)=ts.shift_id
	LEFT JOIN ww_users u ON u.`user_id` = tr.`user_id`  
	LEFT JOIN ww_partners p ON p.`user_id` = u.`user_id` 
	LEFT JOIN ww_users_profile up ON up.`user_id` = tr.`user_id` 
	WHERE 
	       tr.`user_id` = u.`user_id` AND 
	       u.`user_id` = p.`user_id` AND 
	       u.`can_view` = 1 AND 
	       tr.`date`= dates AND  
	       IF(IFNULL(tr.`aux_shift_id`,0)=0,tr.`shift_id`,tr.`aux_shift_id`)= shiftid AND 
	       
	       -- REMOVE IMMEDIATE SUPERVISOR FILTERING
	       -- ON ROLES WITHIN HR ADMIN AND HR TIMEKEEPER
	       -- AND up.`reports_to_id` = immediateid 
               
	       IF(u.role_id IN ('1','6','24'), 1, (up.`reports_to_id`=immediateid OR up.`coordinator_id`=immediateid) ) 
	       
	ORDER BY u.`display_name`;
   
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_approval` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_approval` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_approval`(IN formsid INT, IN userid INT, IN statusid INT, IN usercomment TEXT)
BEGIN
   /* This will insert records to ww_time_record and executed thru events
      PARAMETER:
         statusid : 1=APPROVED, 0=DECLINE
      LAST Change: 2014-04-11 initial
                   2014-04-11 
   */
   -- [1]
   UPDATE `ww_time_forms_approver`
   SET
      `comment`        = usercomment,
      `comment_date`   = NOW(),
      `form_status_id` = IF(statusid = 1, 6, 7)
   WHERE 
      `forms_id` = formsid AND 
      `user_id` = userid AND
      `deleted` = 0
   LIMIT 1;
             
   -- set next approver
   IF statusid = 1 THEN
      SET @seq = (SELECT MAX(sequence) FROM `ww_time_forms_approver` WHERE `forms_id`=formsid AND `form_status_id`=6 AND `deleted`=0)+1;
      UPDATE `ww_time_forms_approver`
      SET `form_status_id` = 2
      WHERE `forms_id` = formsid AND `sequence` = @seq AND `deleted`=0 AND `condition` = 'By Level';
   END IF;
  
   -- [2] Update status by sequence to approver
   -- Change the status of the next approver
   -- 20150722 Only work on BY LEVEL
   
   -- 20150722 inlcude EITHER OF and ALL on approval condition
   -- [2.5] Check condition on approver   
   SET @conditions = '';
   
   SELECT `condition` INTO @conditions 
   FROM `ww_time_forms_approver`
   WHERE 
      `forms_id` = formsid AND 
      `user_id` = userid AND
      `deleted` = 0
   LIMIT 1;
   
   -- [3] Update status on header
   -- Check if all approver already approved
   IF(@conditions = 'Either Of') THEN
	   UPDATE `time_forms`
	   SET
	      `form_status_id` = IF(statusid=1, 6, 7),
	      `date_approved` = IF(statusid=1, NOW(), `date_approved`),
	      `date_declined` = IF(statusid=1, `date_declined`, NOW())
	   WHERE 
	      `forms_id` = formsid 
	   LIMIT 1;
	   
	   -- [1]
	   UPDATE `ww_time_forms_approver`
	   SET
	      `comment`        = usercomment,
	      `comment_date`   = NOW(),
	      `form_status_id` = IF(statusid = 1, 6, 7)
	   WHERE 
	      `forms_id` = formsid AND 
	      `deleted` = 0
	   LIMIT 1;
   
   ELSE
	   SET @appCount    = 0;
	   SET @appApproved = 0;
	   SET @appDeclined = 0;
	   
	   SELECT COUNT(*), SUM(IF(`form_status_id`=6,1,0)), SUM(IF(`form_status_id`=7,1,0)) 
	   INTO @appCount, @appApproved, @appDeclined
	   FROM `ww_time_forms_approver`
	   WHERE `forms_id`=formsid;
	   
	   UPDATE `time_forms`
	   SET
	      -- `form_status_id` = IF(@appCount=@appApproved, 6, IF(@appCount=@appDeclined, 7, IF(@appDeclined > 0, 7, IF(@appApproved > 0, 3, `form_status_id`)))),
	      `form_status_id` = IF(@appCount=@appApproved, 6, IF(@appCount=@appDeclined, 7, IF(@appDeclined > 0, 7, `form_status_id`))),
	      `date_approved` = IF(@appCount=@appApproved, NOW(), `date_approved`),
	      `date_declined` = IF(@appDeclined > 0, NOW(), `date_declined`)
	   WHERE 
	      `forms_id` = formsid
	   LIMIT 1;	      
   END IF;
      
   
   -- [4] Push email 
   IF (@appCount = @appApproved) OR (@appDeclined > 0) THEN
      CALL sp_time_forms_email_status(formsid);
   ELSE
      CALL sp_time_forms_email(formsid);
   END IF;
   -- 
   
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_approval_admin` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_approval_admin` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_approval_admin`(IN formsid INT, IN userid INT, IN statusid INT, IN usercomment TEXT)
BEGIN
   /* This will insert records to ww_time_record and executed thru events
      PARAMETER:
         statusid : 1=APPROVED, 0=DECLINE
      LAST Change: 2014-04-11 initial
                   2014-04-11 
   */
   
   -- [1]
   UPDATE `ww_time_forms_approver`
   SET
      `comment`        = usercomment,
      `comment_date`   = NOW(),
      `form_status_id` = IF(statusid = 1, 6, IF(statusid = 0, 7, 8))
   WHERE 
      `forms_id` = formsid AND 
      `deleted` = 0
   LIMIT 1;
   
  
   -- [2] Update status by sequence to approver
   IF statusid = 1 THEN
      SET @seq = (SELECT MAX(sequence) FROM `ww_time_forms_approver` WHERE `forms_id`=formsid AND `form_status_id`=6 AND `deleted`=0)+1;
      UPDATE `ww_time_forms_approver`
      SET `form_status_id` = 2
      WHERE `forms_id` = formsid AND `sequence` = @seq AND `deleted`=0;
   END IF;
   
   
   -- Change the status of the next approver
   -- 
   
   -- [3] Update status on header
   -- Check if all approver already approved
   SET @appCount    = 0;
   SET @appApproved = 0;
   SET @appDeclined = 0;
   SET @appCancelled = 0;
   
   SELECT COUNT(*), SUM(IF(`form_status_id`=6,1,0)), SUM(IF(`form_status_id`=7,1,0)), SUM(IF(`form_status_id`=8,1,0)) 
   INTO @appCount, @appApproved, @appDeclined, @appCancelled
   FROM `ww_time_forms_approver`
   WHERE `forms_id`=formsid;
   
   UPDATE `time_forms`
   SET
      `form_status_id` = IF(@appCount=@appApproved, 6, IF(@appCount=@appDeclined, 7,IF(@appCount=@appCancelled, 8, IF(@appDeclined > 0, 7, IF(@appCancelled > 0, 8, IF(@appApproved > 0, 3, `form_status_id`))))))
   WHERE 
      `forms_id` = formsid 
   LIMIT 1;
      
   
   -- [4] Push email 
   CALL sp_time_forms_email(formsid);
   -- 
   
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_aux_shift` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_aux_shift` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_aux_shift`(IN formcode VARCHAR(8), IN userid INT(11), IN formsid INT(11))
BEGIN
   -- [1]
   IF (formcode = 'SL') OR (formcode = 'VL') OR
      (formcode = 'EL') OR (formcode = 'FL') OR
      (formcode = 'LIP') OR (formcode = 'HL') OR
      (formcode = 'ML') OR (formcode = 'PL') OR 
      (formcode = 'LWOP') OR (formcode = 'BL') OR 
      (formcode = 'SLW') OR (formcode = 'SPL') OR (formcode = 'VVL')  OR
      (formcode = 'ADDL') OR (formcode = 'FLV')
       THEN 
      -- [1.1] Priority 1
      
      SET @shift_exist = 0;
      SELECT tfd.`id` INTO @shift_exist
      FROM `time_forms_date` tfd, `time_record` tr 
      WHERE 
         tr.`date` = tfd.`date` AND
         tfd.`forms_id` = formsid AND
         tr.`user_id` = userid 
      ORDER BY tfd.`date` DESC LIMIT 1;
         
      IF (@shift_exist = 0 OR @shift_exist = '') THEN      
         SET @dfrom = '';
         SET @dto = '';
         
         SELECT date_from, date_to INTO @dfrom, @dto
         FROM `ww_time_forms`
         WHERE 
            `forms_id` = formsid;
         
         CALL sp_time_period_populate_user(@dfrom, @dto, userid);
      END IF;
            
      UPDATE `time_forms_date` tfd, `time_record` tr, `ww_time_shift` ts, `ww_time_duration` td, ww_time_forms tf
      SET 
         tfd.`time_from` = IF(tfd.`duration_id`=1, 
                              CONCAT(tfd.`date`,' ',ts.`time_start`), 
                              IF(tfd.`duration_id`=2, 
                                 CONCAT(tfd.`date`,' ',ts.`time_start`), 
                                 CONCAT(tfd.`date`,' ',ts.`time_end`) - INTERVAL td.`credit` HOUR)),
                                 
         tfd.`time_to` = IF(tfd.`duration_id`=1, 
                            CONCAT(tfd.`date`,' ', ts.`time_end`), 
                            IF(tfd.`duration_id`=3, 
                               CONCAT(tfd.`date`,' ',ts.`time_end`), 
                               CONCAT(tfd.`date`,' ',ts.`time_start`) + INTERVAL td.`credit` HOUR)),
                               
         tr.`aux_time_in` = IF(IFNULL(tr.`aux_time_in`,'0000-00-00 00:00:00')='0000-00-00 00:00:00', 
                               IF(tfd.`duration_id`=1, 
                                  CONCAT(tfd.`date`,' ',ts.`time_start`), 
                                  IF(tfd.`duration_id`=2, 
                                     CONCAT(tfd.`date`,' ',ts.`time_start`), 
                                     CONCAT(tfd.`date`,' ',ts.`time_end`) - INTERVAL td.`credit` HOUR)),
            
                               IF(tr.`aux_time_in` > IF(tfd.`duration_id`=1, 
                                  CONCAT(tfd.`date`,' ',ts.`time_start`), 
                                  IF(tfd.`duration_id`=2, 
                                     CONCAT(tfd.`date`,' ',ts.`time_start`), 
                                     CONCAT(tfd.`date`,' ',ts.`time_end`) - INTERVAL td.`credit` HOUR)),
                                  IF(tfd.`duration_id`=1, 
                                     CONCAT(tfd.`date`,' ',ts.`time_start`), 
                                     IF(tfd.`duration_id`=2, 
                                        CONCAT(tfd.`date`,' ',ts.`time_start`), 
                                        CONCAT(tfd.`date`,' ',ts.`time_end`) - INTERVAL td.`credit` HOUR)),
                                  tr.`aux_time_in`
                               )
                            ),
                            
         tr.`aux_time_out` = IF(IFNULL(tr.`aux_time_out`,'0000-00-00 00:00:00')='0000-00-00 00:00:00', 
                                IF(tfd.`duration_id`=1, 
                                   CONCAT(tfd.`date`,' ',ts.`time_end`), 
                                   IF(tfd.`duration_id`=3, 
                                      CONCAT(tfd.`date`,' ',ts.`time_end`), 
                                      CONCAT(tfd.`date`,' ',ts.`time_start`) + INTERVAL td.`credit` HOUR)),
            
                                IF(tr.`aux_time_out` < IF(tfd.`duration_id`=1, 
                                   CONCAT(tfd.`date`,' ',ts.`time_end`), 
                                   IF(tfd.`duration_id`=3, 
                                      CONCAT(tfd.`date`,' ',ts.`time_end`), 
                                      CONCAT(tfd.`date`,' ',ts.`time_start`) + INTERVAL td.`credit` HOUR)),
                                   IF(tfd.`duration_id`=1, 
                                      CONCAT(tfd.`date`,' ',ts.`time_end`), 
                                      IF(tfd.`duration_id`=3, 
                                         CONCAT(tfd.`date`,' ',ts.`time_end`), 
                                         CONCAT(tfd.`date`,' ',ts.`time_start`) + INTERVAL td.`credit` HOUR)),
                                   tr.`aux_time_out`
                                )
                             ),
         tr.`modified_on` = NOW()
      WHERE 
         tr.`date` = tfd.`date` AND
         tfd.`forms_id` = formsid AND
         tr.`user_id` = userid AND
         tfd.`duration_id` = td.`duration_id` AND
         tfd.forms_id = tf.forms_id AND
         ts.`shift_id` = IF(IFNULL(tr.`aux_shift_id`,0)=0,tr.`shift_id`,tr.`aux_shift_id`) AND
         (tf.form_code != 'ADDL' OR (tf.form_code = 'ADDL' AND tf.type = 'Use'));
   END IF;
   
   
   -- [2]
   IF formcode = 'CWS' THEN 
      -- [1.2] Priority 2: If a leave 
      
      UPDATE `time_record` tr, `time_forms_date` tfd, `ww_time_shift` ts 
      SET tr.`aux_shift_id` = ts.`shift_id`,
          tr.`aux_shift` = ts.`shift`,
          tr.`modified_on` = NOW()
      WHERE tr.`date`=tfd.`date` AND tfd.`forms_id`=formsid AND tr.`user_id`=userid AND ts.`shift_id`=tfd.`shift_to`;
   END IF;
   
   
   -- [3]
   IF (formcode = 'OBT') OR (formcode = 'DTRP') OR (formcode = 'DTRU') THEN
      -- [1.3] Priority 3
      
      UPDATE `time_record` tr, `time_forms_date` tfd 
      SET 
         -- tr.`aux_time_in` = IF(IFNULL(`aux_time_in`,'0000-00-00 00:00:00')='0000-00-00 00:00:00', tfd.`time_from`, IF(`aux_time_in`>tfd.`time_from`, tfd.`time_from`, `aux_time_in`)), 
         -- tr.`aux_time_out` = IF(IFNULL(`aux_time_out`,'0000-00-00 00:00:00')='0000-00-00 00:00:00', tfd.`time_to`, IF(`aux_time_out`<tfd.`time_to`, tfd.`time_to`, `aux_time_out`))
         tr.`aux_time_in` = IF( IFNULL(tr.`aux_time_in`,'0000-00-00 00:00:00')='0000-00-00 00:00:00',
                                -- TRUE
                                tfd.`time_from`,
                                -- FALSE
                                IF( tr.`aux_time_in` > IFNULL(tfd.`time_from`,'0000-00-00 00:00:00'),
                                    -- TRUE
                                    IF( IFNULL(tfd.`time_from`,'0000-00-00 00:00:00') = '0000-00-00 00:00:00',
                                        -- TRUE
                                        tr.`aux_time_in`,
                                        -- FALSE
                                        IF( tr.`aux_time_in` > IFNULL(tfd.`time_from`,'0000-00-00 00:00:00'),
                                            -- TRUE
                                            tfd.`time_from`,
                                            -- FALSE
                                            tr.`aux_time_in`
                                        )
                                    ),
                                    -- FALSE
                                    tr.`aux_time_in`
                                )
                             ),
         tr.`aux_time_out` = IF( IFNULL(tr.`aux_time_out`,'0000-00-00 00:00:00')='0000-00-00 00:00:00',
                                 -- TRUE
                                 tfd.`time_to`,
                                 -- FALSE
                                 IF( tr.`aux_time_out` < IFNULL(tfd.`time_to`,'0000-00-00 00:00:00'),
                                     -- TRUE
                                     IF( IFNULL(tfd.`time_to`,'0000-00-00 00:00:00') = '0000-00-00 00:00:00',
                                         -- TRUE
                                         tr.`aux_time_out`,
                                         -- FALSE
                                         IF( tr.`aux_time_out` < IFNULL(tfd.`time_to`,'0000-00-00 00:00:00'),
                                             -- TRUE
                                             tfd.`time_to`,
                                             -- FALSE
                                             tr.`aux_time_out`
                                         )
                                     ),
                                     -- FALSE
                                     tr.`aux_time_out`
                                 )
                             ),
         tr.`modified_on` = NOW()                             
      WHERE tr.`date`=tfd.`date` AND tfd.`forms_id`=formsid AND tr.`user_id`=userid;
   END IF;  
 
       
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_change_pending_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_change_pending_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_change_pending_approvers`(IN user_ids VARCHAR(256), IN class_code VARCHAR(16))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE forms CURSOR FOR
       SELECT  tr.`forms_id`, tr.`user_id` FROM `time_forms` tr WHERE `deleted`=0
       AND FIND_IN_SET(user_id, user_ids) AND form_status_id IN (2,3,4,5) AND UPPER(form_code) = class_code;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- START TRANSACTION;
        
    OPEN forms;
    
    REPEAT
       FETCH forms INTO recordid, userid;
       
       IF NOT done THEN
	   DELETE FROM ww_time_forms_approver WHERE forms_id = recordid;
           CALL `sp_time_forms_populate_approvers`(recordid, userid);
           UPDATE ww_time_forms SET form_status_id = 2 WHERE forms_id = recordid;      
	   SET rec = rec + 1;
	   
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE forms;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_email` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_email` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_email`(IN formsid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    DECLARE timeformsid INT;
    DECLARE email VARCHAR(128);
    DECLARE approver VARCHAR(32);
    DECLARE classid INT;
    DECLARE ownerid INT;
    
    DECLARE approvers CURSOR FOR
       SELECT tfa.`id`, tfa.`user_id`, u.`email`, up.`firstname`, tfa.`forms_id`, appc.`class_id`, tfs.`user_id` ownid
       FROM `ww_time_forms_approver` tfa
       INNER JOIN `users` u ON u.user_id=tfa.user_id
       INNER JOIN `users_profile` up ON up.user_id=tfa.user_id
       INNER JOIN ww_time_forms tfs ON tfs.forms_id = tfa.forms_id
       INNER JOIN ww_approver_class appc ON UPPER(appc.`class_code`)= UPPER(tfs.`form_code`)
       WHERE tfa.`deleted`=0 AND tfa.`form_status_id`=2 AND tfa.`forms_id`=formsid AND IFNULL(u.`email`,'')<>'';
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    OPEN approvers;
    
    REPEAT
       FETCH approvers INTO recordid, userid, email, approver, timeformsid, classid, ownerid;
       
       IF NOT done THEN
           SET rec = rec + 1;
           
        --   IF time_get_approver_with_email(classid,ownerid,userid) = 1 THEN
              -- START
           
           -- [1] retrieve the application
           SET @formid = 0;
           SET @formcode = '';
           SET @formname = '';
           SET @displayname = '';
           SET @createdon = '';
           SET @inclusive = '';
           SET @days = '';
           SET @hrs = '';
           SET @reason = '';
           SET @userid = 0;
           SET @datefrom = 0;
           SET @isleave = 0;
           SET @duration = '';
           SET @companytovisit = '';
           SET @companylocation = '';
           SET @timefrom = '';
           SET @timeto = '';
           SET @shifta = '';
           SET @shiftb = '';
       
           SELECT `user_id`, `form_id`, `form_code`, `display_name`, `date_from`, 
                  IF(`date_from`=`date_to`, 
                  DATE_FORMAT(`date_from`, '%M-%e'), 
                  CONCAT(DATE_FORMAT(`date_from`, '%M-%e'), ' to ', DATE_FORMAT(`date_to`, '%M-%e %Y'))
                  ),
                  DATE_FORMAT(`created_on`, '%M-%e %l%p, %W'), 
                  IF(`day` = .5, 'Halfday', IF(`day`=1,'1 day',CONCAT(`day`,' days'))), `hrs`,
                  IFNULL(`reason`,'n/a')
           INTO @userid, @formid, @formcode, @displayname, @datefrom, @inclusive, @createdon, @days, @hrs, @reason
           FROM `time_forms`
           WHERE `forms_id`=timeformsid LIMIT 1;
           
           
           -- [2] retrieve the form 
           SELECT `form`, `is_leave` INTO @formname, @isleave
           FROM `ww_time_form` WHERE `form_id`=@formid LIMIT 1;
       
           
           -- [3] retrieve the email template
           SET @emailto = email;
           SET @emailsubject = '';
           SET @emailbody = '';
       
           SELECT `subject`,`body` INTO @emailsubject, @emailbody
           FROM `ww_system_template`
           WHERE `code` = @formcode LIMIT 1;
           
           
           
           IF @emailsubject <> '' THEN
              -- [2] replace variables
              SET @emailbody = REPLACE(@emailbody, '{{alias}}', approver);
              SET @emailbody = REPLACE(@emailbody, '{{fullname}}', @displayname);
              SET @emailbody = REPLACE(@emailbody, '{{form}}', @formname);
              SET @emailbody = REPLACE(@emailbody, '{{inclusive}}', @inclusive);
              SET @emailbody = REPLACE(@emailbody, '{{createdon}}', @createdon);
              SET @emailbody = REPLACE(@emailbody, '{{reason}}', @reason);
              
              IF @formcode = 'OT' THEN
                 SET @days = @hrs;
              END IF;
              SET @emailbody = REPLACE(@emailbody, '{{days}}', @days);
              
              IF TRIM(@formcode) = 'OBT' THEN
                 SELECT company_to_visit, location INTO @companytovisit, @companylocation 
                 FROM `ww_time_forms_obt` 
                 WHERE `forms_id`=timeformsid LIMIT 1;
                 SET @emailbody = REPLACE(@emailbody, '{{company_to_visit}}', @companytovisit);
                 SET @emailbody = REPLACE(@emailbody, '{{company_location}}', @companylocation);
              END IF;
              
              IF @formcode = 'DTRP' OR @formcode = 'RES' THEN -- DTRP
                 SELECT tfd.`time_from`, tfd.`time_to` INTO @timefrom, @timeto
                 FROM `time_forms_date` tfd
                 WHERE `forms_id`=timeformsid LIMIT 1;
                 
                 IF IFNULL(@timefrom,'0000-00-00 00:00:00')='0000-00-00 00:00:00' THEN
                    SET @emailbody = REPLACE(@emailbody, '{{current_shift}}', @timeto);
                 ELSE
                    SET @emailbody = REPLACE(@emailbody, '{{current_shift}}', @timefrom);
                 END IF;
              END IF;
              
              IF @formcode = 'CWS' THEN -- CWS
                 SELECT IFNULL(tsa.`shift`,''), IFNULL(tsb.`shift`,'') INTO @shifta, @shiftb 
                 FROM `time_forms_date` tfd
                 LEFT JOIN `ww_time_shift` tsa ON tsa.`shift_id`=tfd.`shift_id`
                 LEFT JOIN `ww_time_shift` tsb ON tsb.`shift_id`=tfd.`shift_to`
                 WHERE `forms_id`=timeformsid LIMIT 1;
                 SET @emailbody = REPLACE(@emailbody, '{{current_shift}}', @shifta);
                 SET @emailbody = REPLACE(@emailbody, '{{new_shift}}', @shiftb);
              END IF;
              
              IF @formcode = 'UT' THEN
                 SELECT IFNULL(tsa.`shift`,'') INTO @shifta 
                 FROM `time_forms_date` tfd
                 LEFT JOIN `ww_time_shift` tsa ON tsa.`shift_id`=tfd.`shift_id`
                 WHERE `forms_id`=timeformsid LIMIT 1;
                 SET @emailbody = REPLACE(@emailbody, '{{current_shift}}', @shifta);
              END IF;
              
              IF @isleave = 1 THEN
                 IF @days = 'Halfday' THEN
                    SELECT CONCAT('( ',td.`duration`,' )') INTO @duration
                    FROM `time_forms_date` tfd
                    INNER JOIN `ww_time_duration` td ON td.`duration_id`=tfd.`duration_id`
                    WHERE tfd.`forms_id`=timeformsid LIMIT 1;
                 END IF;
              END IF;
              SET @emailbody = REPLACE(@emailbody, '{{duration}}', @duration);
              
              -- {{table_body}}
              SET @tbody = time_form_balance_email(@userid,YEAR(@datefrom));
              SET @emailbody = REPLACE(@emailbody, '{{table_body}}', @tbody);
          
              -- {{link}}
              SET @url = get_config('System','URL');
	          IF RIGHT(TRIM(@url),1) <> '/' THEN
	             SET @url = CONCAT(TRIM(@url),'/');
	          END IF;
	   
              -- {{header/email logo}}
              SET @logo = get_config('System','print_logo'); 
	          IF TRIM(@logo) <> '' THEN
	             SET @logo = CONCAT(@url,@logo);
	          ELSE
	             SET @logo = CONCAT(@url,get_config('System','logo'));
	          END IF;
	   	         
              SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='form_application_manage' LIMIT 1);
              SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
              SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
              SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
              SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
              SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
               
              -- [3] insert to table
              IF TRIM(@emailbody) <> '' THEN
                 INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
                 SELECT @emailto, @emailsubject, @emailbody;
              END IF;
              
              -- SELECT @emailto, @emailsubject, @emailbody;
              
             -- END IF; -- time_get_approver_with_email(classid,ownerid,userid) = 1
              
           END IF;
        END IF;
        
    UNTIL done END REPEAT;
    
    CLOSE approvers;
    
    -- SELECT rec;
    
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_email_accounting` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_email_accounting` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_email_accounting`(IN formsid INT(11), IN recipientid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE approver VARCHAR(32);
    DECLARE comments TEXT;    
        
       -- [1] retrieve the application
       SET @userid = 0;
       SET @email = '';
       SET @formstatus = '';
       SET @formid = 0;
       SET @formcode = '';
       SET @formname = '';
       SET @recipientAlias = '';
       SET @displayname = '';
       SET @createdon = '';
       SET @inclusive = '';
       SET @days = '';
       SET @reason = '';
       SET @userid = 0;
       SET @datefrom = 0;
       SET @isleave = 0;
       SET @duration = '';
       
       SELECT tf.`user_id`, tfs.`form_status`, `form_id`, `form_code`, `date_from`, 
              IF(`date_from`=`date_to`, 
                 DATE_FORMAT(`date_from`, '%M-%e'), 
                 CONCAT(DATE_FORMAT(`date_from`, '%M-%e'), ' to ', DATE_FORMAT(`date_to`, '%M-%e %Y'))
              ),
              DATE_FORMAT(tf.`created_on`, '%M-%e %l%p, %W'), 
              IF(`day` = .5, 'Halfday', IF(`day`=1,'1 day',CONCAT(`day`,' days'))), 
              IFNULL(`reason`,'n/a'), u.full_name
       INTO @userid, @formstatus, @formid, @formcode, @datefrom, @inclusive, @createdon, @days, @reason, @displayname
       FROM `time_forms` tf
       LEFT JOIN ww_users u ON tf.user_id = u.user_id
       LEFT JOIN `ww_time_form_status` tfs ON tfs.`form_status_id` = tf.`form_status_id` AND tfs.`deleted` = 0
       WHERE `forms_id`=formsid LIMIT 1;
       
       -- [1.5] retrieve the recipient email and firstname 
       SELECT u.email, up.firstname INTO @email, @recipientAlias
       FROM `ww_users` u 
       LEFT JOIN ww_users_profile up ON u.user_id = up.user_id
       WHERE u.user_id= recipientid LIMIT 1;
       
       -- [2] retrieve the form 
       SELECT `form`, `is_leave` INTO @formname, @isleave
       FROM `ww_time_form` WHERE `form_id`=@formid LIMIT 1;
       
       -- [3] retrieve the email template
       SET @emailto = @email;
       SET @emailsubject = '';
       SET @emailbody = '';
       
       SELECT `subject`,`body` INTO @emailsubject, @emailbody
       FROM `ww_system_template`
       WHERE `code` = CONCAT(@formcode,'-ACCOUNTING') LIMIT 1;
       
       
       IF @emailsubject <> '' THEN
           -- [2] replace variables
           SET @emailbody = REPLACE(@emailbody, '{{fullname}}', @displayname);
           SET @emailbody = REPLACE(@emailbody, '{{alias}}', @recipientAlias);
           SET @emailbody = REPLACE(@emailbody, '{{status}}', @formstatus);
           SET @emailbody = REPLACE(@emailbody, '{{comments}}', @comment_body);
           SET @emailbody = REPLACE(@emailbody, '{{form}}', @formname);
           SET @emailbody = REPLACE(@emailbody, '{{inclusive}}', @inclusive);
           SET @emailbody = REPLACE(@emailbody, '{{createdon}}', @createdon);
           SET @emailbody = REPLACE(@emailbody, '{{days}}', @days);
           SET @emailbody = REPLACE(@emailbody, '{{reason}}', @reason);
              
           IF @formcode = 'OBT' THEN
              SET @companytovisit = '';
              SET @companylocation = '';
              SELECT company_to_visit, location INTO @companytovisit, @companylocation 
              FROM `ww_time_forms_obt` 
              WHERE `forms_id`=formsid LIMIT 1;
              SET @emailbody = REPLACE(@emailbody, '{{company_to_visit}}', @companytovisit);
              SET @emailbody = REPLACE(@emailbody, '{{company_location}}', @companylocation);
              
           -- {{table_body}}
           SET @tbody = time_form_obt_request(formsid);
           SET @emailbody = REPLACE(@emailbody, '{{table_body}}', @tbody);           
           END IF;
              
           SET @emailbody = REPLACE(@emailbody, '{{duration}}', @duration);              
          
           -- {{link}}
           SET @url = get_config('System','URL');
	       IF RIGHT(TRIM(@url),1) <> '/' THEN
	          SET @url = CONCAT(TRIM(@url),'/');
	       END IF;
	       
           -- {{header/email logo}}
           SET @logo = get_config('System','print_logo'); 
	       IF TRIM(@logo) <> '' THEN
	          SET @logo = CONCAT(@url,@logo);
	       ELSE
	          SET @logo = CONCAT(@url,get_config('System','logo'));
	       END IF;
	   	         
           SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='forms_request' LIMIT 1);
           SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
           SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
           SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
           SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
           SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
                      
           -- [3] insert to table
           INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
           SELECT @emailto, @emailsubject, @emailbody;
        
       END IF; -- @emailsubject <> '' THEN
       
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_email_hr_validation` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_email_hr_validation` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_email_hr_validation`(IN formsid INT(11), IN recipientid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE approver VARCHAR(32);
    DECLARE comments TEXT;    
        
       -- [1] retrieve the application
       SET @userid = 0;
       SET @email = '';
       SET @formstatus = '';
       SET @formid = 0;
       SET @formcode = '';
       SET @formname = '';
       SET @recipientAlias = '';
       SET @displayname = '';
       SET @createdon = '';
       SET @inclusive = '';
       SET @days = '';
       SET @reason = '';
       SET @userid = 0;
       SET @datefrom = 0;
       SET @isleave = 0;
       SET @duration = '';
       
       SELECT tf.`user_id`, tfs.`form_status`, `form_id`, `form_code`, `date_from`, 
              IF(`date_from`=`date_to`, 
                 DATE_FORMAT(`date_from`, '%M-%e'), 
                 CONCAT(DATE_FORMAT(`date_from`, '%M-%e'), ' to ', DATE_FORMAT(`date_to`, '%M-%e %Y'))
              ),
              DATE_FORMAT(tf.`created_on`, '%M-%e %l%p, %W'), 
              IF(`day` = .5, 'Halfday', IF(`day`=1,'1 day',CONCAT(`day`,' days'))), 
              IFNULL(`reason`,'n/a'), u.full_name
       INTO @userid, @formstatus, @formid, @formcode, @datefrom, @inclusive, @createdon, @days, @reason, @displayname
       FROM `time_forms` tf
       LEFT JOIN ww_users u ON tf.user_id = u.user_id
       LEFT JOIN `ww_time_form_status` tfs ON tfs.`form_status_id` = tf.`form_status_id` AND tfs.`deleted` = 0
       WHERE `forms_id`=formsid LIMIT 1;
       
       -- [1.5] retrieve the recipient email and firstname 
       SELECT u.email, up.firstname INTO @email, @recipientAlias
       FROM `ww_users` u 
       LEFT JOIN ww_users_profile up ON u.user_id = up.user_id
       WHERE u.user_id= recipientid LIMIT 1;
       
       -- [2] retrieve the form 
       SELECT `form`, `is_leave` INTO @formname, @isleave
       FROM `ww_time_form` WHERE `form_id`=@formid LIMIT 1;
       
       -- [3] retrieve the email template
       SET @emailto = @email;
       SET @emailsubject = '';
       SET @emailbody = '';
       
       SELECT `subject`,`body` INTO @emailsubject, @emailbody
       FROM `ww_system_template`
       WHERE `code` = 'HR-VALIDATION' LIMIT 1;
       
       
       IF @emailsubject <> '' THEN
           -- [2] replace variables           
           SET @emailbody = REPLACE(@emailbody, '{{fullname}}', @displayname);
           SET @emailbody = REPLACE(@emailbody, '{{alias}}', @recipientAlias);
           SET @emailbody = REPLACE(@emailbody, '{{status}}', @formstatus);
           SET @emailbody = REPLACE(@emailbody, '{{comments}}', @comment_body);
           SET @emailbody = REPLACE(@emailbody, '{{form}}', @formname);
           SET @emailbody = REPLACE(@emailbody, '{{inclusive}}', @inclusive);
           SET @emailbody = REPLACE(@emailbody, '{{createdon}}', @createdon);
           SET @emailbody = REPLACE(@emailbody, '{{days}}', @days);
           SET @emailbody = REPLACE(@emailbody, '{{reason}}', @reason);
              
           IF @formcode = 'OBT' THEN              
               -- {{table_body}}
               SET @tbody = time_form_obt_request(formsid);
               SET @emailbody = REPLACE(@emailbody, '{{table_body}}', @tbody);   
           ELSE
              -- {{table_body}}
              SET @tbody = time_form_balance_email(@userid,YEAR(@datefrom));
              SET @emailbody = REPLACE(@emailbody, '{{table_body}}', @tbody);        
           END IF;
              
           SET @emailbody = REPLACE(@emailbody, '{{duration}}', @duration);              
          
           -- {{link}}
           SET @url = get_config('System','URL');
	       IF RIGHT(TRIM(@url),1) <> '/' THEN
	          SET @url = CONCAT(TRIM(@url),'/');
	       END IF;
	       
           -- {{header/email logo}}
           SET @logo = get_config('System','print_logo'); 
	       IF TRIM(@logo) <> '' THEN
	          SET @logo = CONCAT(@url,@logo);
	       ELSE
	          SET @logo = CONCAT(@url,get_config('System','logo'));
	       END IF;
	         
           SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='hr_validation' LIMIT 1);
           SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
           SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
           SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
           SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
           SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
                      
           -- [3] insert to table
           INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
           SELECT @emailto, @emailsubject, @emailbody;
        
       END IF; -- @emailsubject <> '' THEN
       
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_email_status` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_email_status` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_email_status`(IN formsid INT(11))
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE approver VARCHAR(32);
    DECLARE comments TEXT;
    DECLARE approvers CURSOR FOR
       SELECT up.`firstname`, tfa.`comment`
       FROM `ww_time_forms_approver` tfa
       JOIN `users_profile` up ON up.user_id=tfa.user_id
       WHERE 
             tfa.`deleted` = 0 AND 
             tfa.`form_status_id` IN (6,7,8) AND 
             tfa.`forms_id` = formsid;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    SET @comment_body = '';
    
    OPEN approvers;
    REPEAT
       FETCH approvers INTO approver, comments;
       IF NOT done THEN
           SET rec = rec + 1;
           SET @comment_body = CONCAT(@comment_body,'<strong>',approver,':</strong><br>',IFNULL(comments,'-'),'<br>');
        END IF;
    UNTIL done END REPEAT;
    CLOSE approvers;
    
    
    IF rec > 0 THEN
    
       -- [1] retrieve the application
       SET @userid = 0;
       SET @email = '';
       SET @formstatus = '';
       SET @formid = 0;
       SET @formcode = '';
       SET @formname = '';
       SET @displayname = '';
       SET @createdon = '';
       SET @inclusive = '';
       SET @days = '';
       SET @reason = '';
       SET @userid = 0;
       SET @datefrom = 0;
       SET @isleave = 0;
       SET @duration = '';
       
       SELECT tf.`user_id`, u.`email`, IF(tfs.`form_status_id`=9,CONCAT(' set to ',tfs.`form_status`), tfs.`form_status`), 
              `form_id`, `form_code`, `firstname`, `date_from`, 
              IF(`date_from`=`date_to`, 
                 DATE_FORMAT(`date_from`, '%M-%e'), 
                 CONCAT(DATE_FORMAT(`date_from`, '%M-%e'), ' to ', DATE_FORMAT(`date_to`, '%M-%e %Y'))
              ),
              DATE_FORMAT(tf.`created_on`, '%M-%e %l%p, %W'), 
              IF(`day` = .5, 'Halfday', IF(`day`=1,'1 day',CONCAT(`day`,' days'))), 
              IFNULL(`reason`,'n/a')
       INTO @userid, @email, @formstatus, @formid, @formcode, @displayname, @datefrom, @inclusive, @createdon, @days, @reason
       FROM `time_forms` tf
       JOIN `users` u ON u.`user_id` = tf.`user_id`
       JOIN `users_profile` up ON up.`user_id` = tf.`user_id`
       LEFT JOIN `ww_time_form_status` tfs ON tfs.`form_status_id` = tf.`form_status_id` AND tfs.`deleted` = 0
       WHERE `forms_id`=formsid LIMIT 1;
       
       -- [2] retrieve the form 
       SELECT `form`, `is_leave` INTO @formname, @isleave
       FROM `ww_time_form` WHERE `form_id`=@formid LIMIT 1;
       
       -- [3] retrieve the email template
       SET @emailto = @email;
       SET @emailsubject = '';
       SET @emailbody = '';
       
       SELECT `subject`,`body` INTO @emailsubject, @emailbody
       FROM `ww_system_template`
       WHERE `code` = CONCAT(@formcode,'-STATUS') LIMIT 1;
       
       
       IF @emailsubject <> '' AND @emailto <> '' THEN
           -- [2] replace variables
           SET @emailbody = REPLACE(@emailbody, '{{alias}}', @displayname);
           SET @emailbody = REPLACE(@emailbody, '{{status}}', @formstatus);
           SET @emailbody = REPLACE(@emailbody, '{{comments}}', @comment_body);
           SET @emailbody = REPLACE(@emailbody, '{{form}}', @formname);
           SET @emailbody = REPLACE(@emailbody, '{{inclusive}}', @inclusive);
           SET @emailbody = REPLACE(@emailbody, '{{createdon}}', @createdon);
           SET @emailbody = REPLACE(@emailbody, '{{days}}', @days);
           SET @emailbody = REPLACE(@emailbody, '{{reason}}', @reason);
              
           IF @formcode = 'OBT' THEN
              SET @companytovisit = '';
              SET @companylocation = '';
              SELECT company_to_visit, location INTO @companytovisit, @companylocation 
              FROM `ww_time_forms_obt` 
              WHERE `forms_id`=formsid LIMIT 1;
              SET @emailbody = REPLACE(@emailbody, '{{company_to_visit}}', @companytovisit);
              SET @emailbody = REPLACE(@emailbody, '{{company_location}}', @companylocation);
           END IF;
              
           IF @formcode = 'DTRP' OR @formcode = 'RES' THEN -- DTRP
              SET @timefrom = '';
              SET @timeto = '';
              SELECT tfd.`time_from`, tfd.`time_to` INTO @timefrom, @timeto
              FROM `time_forms_date` tfd
              WHERE `forms_id`=formsid LIMIT 1;
                 
              IF IFNULL(@timefrom,'0000-00-00 00:00:00')='0000-00-00 00:00:00' THEN
                 SET @emailbody = REPLACE(@emailbody, '{{current_shift}}', @timeto);
              ELSE
                 SET @emailbody = REPLACE(@emailbody, '{{current_shift}}', @timefrom);
              END IF;
           END IF;
              
           IF @formcode = 'CWS' THEN -- CWS
              SET @shifta = '';
              SET @shiftb = '';
              SELECT tsa.`shift`, tsb.`shift` INTO @shifta, @shiftb 
              FROM `time_forms_date` tfd
              LEFT JOIN `ww_time_shift` tsa ON tsa.`shift_id`=tfd.`shift_id`
              LEFT JOIN `ww_time_shift` tsb ON tsb.`shift_id`=tfd.`shift_to`
              WHERE `forms_id`=formsid LIMIT 1;
              SET @emailbody = REPLACE(@emailbody, '{{current_shift}}', @shifta);
              SET @emailbody = REPLACE(@emailbody, '{{new_shift}}', @shiftb);
           END IF;
              
           IF @isleave = 1 THEN
              IF @days = 'Halfday' THEN
                 SELECT CONCAT('( ',td.`duration`,' )') INTO @duration
                 FROM `time_forms_date` tfd
                 INNER JOIN `ww_time_duration` td ON td.`duration_id`=tfd.`duration_id`
                 WHERE tfd.`forms_id`=formsid LIMIT 1;
              END IF;
           END IF;
           SET @emailbody = REPLACE(@emailbody, '{{duration}}', @duration);
              
           -- {{table_body}}
           SET @tbody = time_form_balance_email(@userid,YEAR(@datefrom));
           SET @emailbody = REPLACE(@emailbody, '{{table_body}}', @tbody);
          
           -- {{link}}
           SET @url = get_config('System','URL');
	       IF RIGHT(TRIM(@url),1) <> '/' THEN
	          SET @url = CONCAT(TRIM(@url),'/');
	       END IF;
	       
           -- {{header/email logo}}
           SET @logo = get_config('System','print_logo'); 
	       IF TRIM(@logo) <> '' THEN
	          SET @logo = CONCAT(@url,@logo);
	       ELSE
	          SET @logo = CONCAT(@url,get_config('System','logo'));
	       END IF;
	         
           SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='form_application_manage' LIMIT 1);
           SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
           SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
           SET @emailbody = REPLACE(@emailbody, '{{system_logo}}', @logo);
           SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
           SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
                      
           -- [3] insert to table
           INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`)
           SELECT @emailto, @emailsubject, @emailbody;
        
       END IF; -- @emailsubject <> '' THEN
       
    END IF; -- rec > 0 THEN
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_get_application` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_get_application` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_get_application`(IN userid INT, IN formdate DATE)
BEGIN
	SELECT *
	FROM ww_time_forms
	WHERE form_status_id NOT IN (1,7,8)
	AND form_code = 'NOTHING'
	AND deleted=0
	AND user_id=userid AND formdate BETWEEN date_from AND date_to
	limit 1;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_get_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_get_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_get_approvers`(IN formcode VARCHAR(16), IN userid INT(11))
BEGIN
          
    -- 
    -- [0] Override from USER
    -- 
    SET @rec = 0;
    SET @class = '';
    SET @users = '';
    
    SELECT c.`class_code`, b.`user_id`, COUNT(a.`id`) INTO @class, @users, @rec
    FROM `ww_approver_class_user` a
    JOIN `users_profile` b ON b.user_id = a.`user_id`
    JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
    WHERE a.`deleted`=0 AND b.`user_id`=userid AND c.`class_code`=formcode
          AND a.department_id = b.department_id AND a.company_id = b.company_id AND a.user_id = b.user_id;
    
    IF @rec > 0 THEN
       SELECT  `approver_id`, `condition`, `sequence`, c.lastname, c.firstname, `position`
       FROM `ww_approver_class_user` a
       JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
       JOIN `users_profile` c ON a.`approver_id`=c.`user_id` 
       LEFT JOIN `ww_users_position` d ON c.`position_id`=d.`position_id` 
       JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
       WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`user_id`=@users AND
             a.department_id = e.department_id AND a.company_id = e.company_id AND a.user_id = e.user_id;
    ELSE    
       
       -- 
       -- [1] Override from POSITION
       -- 
       SET @rec = 0;
       SET @class = '';
       SET @positions = '';
    
       SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`) INTO @class, @positions, @rec
       FROM `ww_approver_class_position` a
       JOIN `users_profile` b ON b.position_id = a.`position_id`
       JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
       WHERE a.`deleted`=0 AND b.`user_id`=userid AND  c.`class_code`=formcode AND 
             a.department_id = b.department_id AND a.company_id = b.company_id;
       
       IF @rec > 0 THEN
          SELECT  `approver_id`, `condition`, `sequence`, c.lastname, c.firstname, `position`
          FROM `ww_approver_class_position` a
          JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
          JOIN `users_profile` c ON a.`approver_id`=c.`user_id` 
          LEFT JOIN `ww_users_position` d ON c.`position_id`=d.`position_id` 
          JOIN `users_profile` e ON e.position_id = a.`position_id` AND e.`user_id`=userid
          WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`position_id`=@positions AND 
                a.department_id = e.department_id AND a.company_id = e.company_id;
       ELSE     
	    
          -- 
          -- [2] Override from DEPARTMENT
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @department = '';
          
          SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`) INTO @class, @department, @rec
          FROM `ww_approver_class_department` a
          JOIN `users_profile` b ON b.department_id = a.`department_id`
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
	  WHERE a.`deleted`=0 AND b.`user_id`=userid AND  c.`class_code`=formcode AND 
	        a.company_id = b.company_id;
  
          IF @rec > 0 THEN
	     SELECT  `approver_id`, `condition`, `sequence`, c.lastname, c.firstname, `position`
	     FROM `ww_approver_class_department` a
	     JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
	     JOIN `users_profile` c ON a.`approver_id`=c.`user_id` 
	     LEFT JOIN `ww_users_position` d ON c.`position_id`=d.`position_id` 
	     JOIN `users_profile` e ON e.department_id = a.`department_id` AND e.`user_id`=userid
	     WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`department_id`=@department AND a.company_id = e.company_id;
          ELSE
             
	     -- 
	     -- [3] Override from COMPANY
	     -- 
	     SET @rec = 0;
	     SET @class = '';
	     SET @company = '';
               
	     SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`) INTO @class, @company, @rec
	     FROM `ww_approver_class_company` a
	     JOIN `users_profile` b ON b.company_id = a.`company_id`
	     JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
	     WHERE b.`user_id`=userid AND  c.`class_code`=formcode AND a.`deleted`=0;
  
	    IF @rec > 0 THEN
	       SELECT  `approver_id`, `condition`, `sequence`, c.lastname, c.firstname, `position`
	       FROM `ww_approver_class_company` a
	       JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
	       JOIN `users_profile` c ON a.`approver_id`=c.`user_id` 
	       LEFT JOIN `ww_users_position` d ON c.`position_id`=d.`position_id` 
	       JOIN `users_profile` e ON e.company_id = a.`company_id` AND e.`user_id`=userid
	       WHERE a.`deleted`=0 AND b.`class_code`=@class AND a.`company_id`=@company;
	    END IF; -- IF COMPANY
            
         END IF; -- IF DEPARTMENT
         
      END IF; -- IF POSITION  
      
   END IF; -- IF USER  
   
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_maternity` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_maternity` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_maternity`(formsid INT(11))
BEGIN
    
    /* Time Record Population of Maternity */
	 
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_ot_leave_expired` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_ot_leave_expired` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_ot_leave_expired`(IN odate DATE)
BEGIN
    
	   INSERT INTO ww_time_forms_ot_leave_used
	   (forms_id, used_by_form, used)
	   SELECT otleave.forms_id, -1, otleave.credit 
	   FROM ww_time_forms_ot_leave otleave
		    WHERE otleave.expiration_date <= odate
		    AND otleave.used_by_form=0
		    AND NOT EXISTS (SELECT t1.forms_id FROM ww_time_forms_ot_leave_used t1 WHERE otleave.forms_id = t1.forms_id);
		    
	     UPDATE ww_time_forms_ot_leave
		    SET used=credit,
			remarks=CONCAT(remarks,' expired on ',expiration_date),
			used_by_form=-1
		    WHERE expiration_date <= odate
		    AND used_by_form=0;
		    
	     UPDATE ww_time_form_balance
	     SET deleted=0
	     WHERE deleted=0;
	     
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_populate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_populate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_populate_approvers`(IN formsid INT(11), IN userid INT(11))
BEGIN
       -- 
       -- [1] Override from user
       -- 
       SET @rec = 0;
       SET @class = '';
       SET @positions = '';
       SET @conditions = '';
       
       SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`), a.condition INTO @class, @positions, @rec, @conditions
       FROM `ww_approver_class_user` a
       JOIN `users_profile` b ON b.user_id = a.`user_id` 
       JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
       JOIN `time_forms` d ON d.`user_id` = b.`user_id`
       WHERE a.`deleted`=0 AND b.`user_id`=userid AND d.`forms_id`=formsid AND UPPER(c.`class_code`)= UPPER(d.`form_code`);
       
       IF @rec > 0 THEN
          INSERT INTO `ww_time_forms_approver`
          (`forms_id`, `user_id`, `condition`, `sequence`, `form_status_id`)
          SELECT formsid, `approver_id`, `condition`, `sequence`, IF(@conditions='By Level',IF(@rec=1,2,IF(`sequence`=1,2,3)),2)
          FROM `ww_approver_class_user` a
          JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
          JOIN `users_profile` u ON u.user_id=userid
          WHERE a.`deleted`=0 AND UPPER(b.`class_code`)=UPPER(@class) AND a.`user_id`=userid AND 
                -- a.`position_id`=u.`position_id` AND a.`department_id`=u.`department_id` AND 
                a.`company_id`=u.`company_id` AND a.`approver_id`<>userid
          GROUP BY 2
          ON DUPLICATE KEY UPDATE `deleted`=0;             
       ELSE  
          
          -- 
          -- [1] Override from POSITION
          -- 
          SET @rec = 0;
          SET @class = '';
          SET @positions = '';
          SET @conditions = '';
          
          SELECT c.`class_code`, b.`position_id`, COUNT(a.`id`), a.condition INTO @class, @positions, @rec, @conditions
          FROM `ww_approver_class_position` a
          JOIN `users_profile` b ON b.position_id = a.`position_id` AND b.`company_id`=a.`company_id` AND b.department_id=a.department_id
          JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
          JOIN `time_forms` d ON d.`user_id` = b.`user_id`
          WHERE a.`deleted`=0 AND b.`user_id`=userid AND d.`forms_id`=formsid AND UPPER(c.`class_code`)= UPPER(d.`form_code`);
          
          IF @rec > 0 THEN
             INSERT INTO `ww_time_forms_approver`
             (`forms_id`, `user_id`, `condition`, `sequence`, `form_status_id`)
             SELECT formsid, `approver_id`, `condition`, `sequence`, IF(@conditions='By Level',IF(@rec=1,2,IF(`sequence`=1,2,3)),2)
             FROM `ww_approver_class_position` a
             JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
             JOIN `users_profile` u ON u.company_id=a.company_id AND u.department_id=a.department_id AND u.user_id=userid
             WHERE a.`deleted`=0 AND UPPER(b.`class_code`)=UPPER(@class) AND a.`position_id`=@positions AND a.`approver_id`<>userid
             GROUP BY 2
             ON DUPLICATE KEY UPDATE `deleted`=0;             
          ELSE     
                    
             -- [2] Override from DEPARTMENT
             -- 
             SET @rec = 0;
             SET @class = '';
             SET @department = '';
          
             SELECT c.`class_code`, b.`department_id`, COUNT(a.`id`), a.condition INTO @class, @department, @rec, @conditions
             FROM `ww_approver_class_department` a
             JOIN `users_profile` b ON b.department_id = a.`department_id` AND b.`company_id`=a.`company_id`
             JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
             JOIN `time_forms` d ON d.`user_id` = b.`user_id`
             WHERE a.`deleted`=0 AND b.`user_id`=userid AND d.`forms_id`=formsid AND UPPER(c.`class_code`)=UPPER(d.`form_code`) AND a.`approver_id`<>userid;
          
             IF @rec > 0 THEN
                INSERT INTO `ww_time_forms_approver`
                (`forms_id`, `user_id`, `condition`, `sequence`, `form_status_id`)
                SELECT formsid, `approver_id`, `condition`, `sequence`, IF(@conditions='By Level',IF(@rec=1,2,IF(`sequence`=1,2,3)),2)
                FROM `ww_approver_class_department` a
                JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                JOIN `users_profile` u ON u.company_id=a.company_id AND u.user_id=userid
                WHERE a.`deleted`=0 AND UPPER(b.`class_code`)=UPPER(@class) AND a.`department_id`=@department AND a.`approver_id`<>userid
                GROUP BY 2
                ON DUPLICATE KEY UPDATE `form_status_id`=VALUES(`form_status_id`), `sequence`=VALUES(`sequence`), `deleted`=0;             
             ELSE
                
                --   
                -- [3] Override from COMPANY
                -- 
                SET @rec = 0;
                SET @class = '';
                SET @company = '';
          
                SELECT c.`class_code`, b.`company_id`, COUNT(a.`id`), a.condition INTO @class, @company, @rec, @conditions
                FROM `ww_approver_class_company` a
                JOIN `users_profile` b ON b.company_id = a.`company_id`
                JOIN `ww_approver_class` c ON c.`class_id` = a.`class_id`
                JOIN `time_forms` d ON d.`user_id` = b.`user_id`
                WHERE a.`deleted`=0 AND b.`user_id`=userid AND d.`forms_id`=formsid AND UPPER(c.`class_code`)=UPPER(d.`form_code`);
          
                IF @rec > 0 THEN
                   INSERT INTO `ww_time_forms_approver`
                   (`forms_id`, `user_id`, `condition`, `sequence`, `form_status_id`)
                   SELECT formsid, `approver_id`, `condition`, `sequence`, IF(@conditions='By Level',IF(@rec=1,2,IF(`sequence`=1,2,3)),2)
                   FROM `ww_approver_class_company` a
                   JOIN `ww_approver_class` b ON b.`class_id`=a.`class_id` AND b.`deleted`=0
                   WHERE a.`deleted`=0 AND UPPER(b.`class_code`)=UPPER(@class) AND a.`company_id`=@company AND a.`approver_id`<>userid
                   GROUP BY 2
                   ON DUPLICATE KEY UPDATE `deleted`=0;             
                END IF; -- IF COMPANY
             
             END IF; -- IF DEPARTMENT
             
          END IF; -- IF POSITION    
       END IF; -- IF user          
          
          
       IF @rec > 0 THEN
          -- email approver/s application content
          CALL sp_time_forms_email(formsid);
       END IF;
          
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_reminder` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_reminder` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_reminder`()
BEGIN
    
    DECLARE done TINYINT(1) DEFAULT 0;
    DECLARE userid INT(11);
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE forms CURSOR FOR
    SELECT tfa.`user_id`
    FROM `time_forms` tf
    JOIN `ww_time_forms_approver` tfa ON tfa.`form_status_id`=2 AND tfa.`deleted`=0 AND tfa.`forms_id`=tf.`forms_id`
    WHERE tf.`form_status_id` IN (2,3,4)
    GROUP BY 1;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
	OPEN forms;
	REPEAT
	   FETCH forms INTO userid;
	   IF NOT done THEN
          SET rec = rec + 1;
          
          CALL sp_time_forms_reminder_user(userid);
          
	   END IF;
	UNTIL done END REPEAT;
    CLOSE forms;
	   
	SELECT rec;
	 
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_reminder_user` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_reminder_user` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_reminder_user`(IN userid INT(11))
BEGIN
    
    DECLARE done TINYINT(1) DEFAULT 0;
    
    DECLARE formsid INT(11);
    DECLARE dname VARCHAR(128);
    DECLARE formcode VARCHAR(16);
    DECLARE created DATE;
    DECLARE datefrom DATE;
    DECLARE dateto DATE;
    DECLARE reason VARCHAR(64);
    
    DECLARE forms CURSOR FOR
       SELECT tf.`forms_id`, tf.`form_code`, tf.`display_name`, tf.`created_on`,
              tf.`date_from`, tf.`date_to`, CONCAT(LEFT(tf.`reason`,30), IF(LENGTH(tf.`reason`)>30,'...',''))reason
       FROM `time_forms` tf
       JOIN `ww_time_forms_approver` tfa ON tfa.`form_status_id`=2 AND tfa.`deleted`=0 AND tfa.`forms_id`=tf.`forms_id`
       WHERE tf.`form_status_id` IN (2,3,4) AND 
             tfa.`user_id`=userid
       ORDER BY tf.`date_from`;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
        
    SET @emailto = '';
    SET @emailsubject = '';
    SET @emailbody = '';
    SET @tbody = '';
    SET @bcc = '';
    SET @url = '';
    
	-- template 
    SELECT `subject`,`body` INTO @emailsubject, @emailbody
    FROM `ww_system_template`
    WHERE `code`='TIME-FORMS-REMINDER' AND deleted=0 LIMIT 1;
    
    
    IF @emailsubject <> '' THEN
       
	   SET @emailto = (SELECT `email` FROM `users` WHERE `user_id`=userid LIMIT 1);
       
	   IF @emailto <> '' THEN
	      OPEN forms;
	      REPEAT
	         FETCH forms INTO formsid, formcode, dname, created, datefrom, dateto, reason;
	         IF NOT done THEN
                SET @tbody = CONCAT(@tbody,'<tr>');
                SET @tbody = CONCAT(@tbody,'<td style="text-align:left">',	
                             DATE_FORMAT(datefrom,'%b-%e %a'), ' ', IF(datefrom=dateto,'', DATE_FORMAT(dateto,'%b-%e %a')), '</td>' );
                SET @tbody = CONCAT(@tbody,'<td>',formcode,'</td>');	
                SET @tbody = CONCAT(@tbody,'<td style="text-align:left">',dname,'</td>');	
                SET @tbody = CONCAT(@tbody,'<td>',created,'</td>');	
                SET @tbody = CONCAT(@tbody,'<td style="text-align:left">',reason,'</td>');	
                SET @tbody = CONCAT(@tbody,'</tr>');
	         END IF;
	      UNTIL done END REPEAT;
          CLOSE forms;
          
          IF @tbody <> '' THEN
             -- {{link}}
             SET @url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
	         IF RIGHT(TRIM(@url),1) <> '/' THEN
	            SET @url = CONCAT(TRIM(@url),'/');
	         END IF;
	         
             SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='form_application_manage' LIMIT 1);
             SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
          
             SET @emailbody = REPLACE(@emailbody, '{{table_body}}', @tbody);
             SET @emailbody = REPLACE(@emailbody, '{{link}}', CONCAT(@url,@route));
             SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
             SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
             SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
             
             SET @urgent = '';
             SET @cutoff = '';
             SELECT cutoff, 'URGENT!!! ' INTO @cutoff, @urgent
             FROM ww_time_period tp, users_profile up
             WHERE tp.company_id = up.company_id AND up.`user_id`=userid AND 
                   CURDATE() BETWEEN (cutoff - INTERVAL 2 DAY) AND cutoff;
             
             IF TRIM(@urgent) <> '' THEN
                SET @emailsubject = CONCAT(@urgent, @emailsubject, ' CUT-OFF is ', DATE_FORMAT(@cutoff,'%M %e %W'));
             END IF;
             
             INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`,`bcc`)
             SELECT @emailto,@emailsubject,@emailbody,@bcc;
          END IF;
       END IF;
       
    END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_forms_reserved_leave` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_forms_reserved_leave` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_forms_reserved_leave`(IN dateform DATE, IN userid INT(10), IN daysused DECIMAL(6,3))
BEGIN
	UPDATE ww_time_form_balance tfb 
	SET tfb.reserved_used = daysused 
	WHERE
	tfb.year = YEAR(dateform) AND
	tfb.form_id = 2 AND
	tfb.deleted = 0 AND
	tfb.user_id = userid;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_balance_carry_over` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_balance_carry_over` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_balance_carry_over`(IN iYear INT(11))
BEGIN
    
    DECLARE time_form_balance_process TINYINT(1) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE userid INT(11);
    DECLARE balance DECIMAL(12,2);
    DECLARE cyear INT(11);
    
    -- [2017.04.11]
    
    -- [1] CHECK AFFECTED
    DECLARE balance_process CURSOR FOR
    SELECT p.`user_id`, tfb.`balance`, tfb.`year`
    FROM `ww_partners` `p`
    JOIN `ww_users_profile` up ON up.`user_id` = p.`user_id`
    JOIN `ww_time_form_balance` tfb ON tfb.`user_id`=p.user_id
    WHERE p.`deleted`=0 AND IFNULL(p.`resigned_date`,'0000-00-00')='0000-00-00' AND
          IFNULL(p.`effectivity_date`,'0000-00-00') <> '0000-00-00' AND
          tfb.`year` = iYear; 
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET time_form_balance_process = 1;
    
    -- [2] CREDIT SETUP
    OPEN balance_process;
    
    
    REPEAT
       FETCH balance_process INTO userid, balance, cyear;
       
       IF NOT time_form_balance_process THEN   
	   SET @previous = IF(balance > 10, balance - 10, 0);
	   SET @cnt = 0;
	   
	   SELECT COUNT(`id`) INTO @cnt FROM ww_time_form_balance 
	   WHERE user_id = userid AND form_id = 22 AND `year` = (iYear + 1) AND deleted = 0;
	   
	   IF @cnt = 0 THEN    
		   INSERT INTO `ww_time_form_balance`
		   (`year`, `user_id`, `form_id`, `form_code`, `previous`) values
		   (iYear, userid, 22,'LIP',@previous);
	   ELSE
		   update `ww_time_form_balance` set previous = @previous
		   WHERE user_id = userid AND form_id = 22 AND `year` = (iYear + 1) AND deleted = 0;
	   END IF;
       END IF;
    
    UNTIL time_form_balance_process END REPEAT;
    
    CLOSE balance_process;
    
    SELECT rec;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_balance_insert` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_balance_insert` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_balance_insert`(IN formid INT(11), IN formsid INT(11), IN userid INT(1))
BEGIN
    DECLARE specialLeave TINYINT(1) DEFAULT 0;
    DECLARE formCode VARCHAR(250);
    DECLARE leaveYear INT(1);
    DECLARE balanceCount INT(1) DEFAULT 0;
    
    SELECT special_leave, form_code INTO specialLeave, formCode 
    FROM ww_time_form 
    WHERE form_id = formid;
    
    IF specialLeave = 1 THEN
        SELECT YEAR(date_from) INTO leaveYear 
        FROM ww_time_forms 
        WHERE forms_id = formsid;
        
        SELECT COUNT(id) INTO balanceCount 
        FROM ww_time_form_balance 
        WHERE form_id = formid AND `year` = leaveYear AND user_id = userid;
        
        IF balanceCount = 0 THEN
	   INSERT INTO `ww_time_form_balance` (`year`, `user_id`, `form_id`, `form_code`, `created_on`, `created_by`) 
	   VALUES (leaveYear, userid, formid, formCode, NOW(), 1);
        END IF;
        
    END IF;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_balance_process` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_balance_process` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_balance_process`(IN pyear INT(1), IN puserid INT(11))
BEGIN
    
    DECLARE time_form_balance_process TINYINT(11) DEFAULT 0;
    
    -- 2017.04.11
    -- [1] CHECK SETUP POLICY
    
    
    -- [2] CREDITS
	
    
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_balance_process_ahi` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_balance_process_ahi` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_balance_process_ahi`(IN pdate DATE, IN pclassid INT(11), puserid INT(11))
BEGIN
    
    DECLARE time_form_balance_process TINYINT(1) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE userid INT(11);
    DECLARE creditid INT(1);
    DECLARE datehired DATE;
    DECLARE statusid INT(11);
    DECLARE typeid INT(11);
    
    -- [2017.04.11]
    
    -- [1] CHECK AFFECTED
    DECLARE balance_process CURSOR FOR
    SELECT p.`user_id`, up.`credit_setup_id`, p.`effectivity_date`, p.`status_id`, p.`employment_type_id`
    FROM `ww_partners` `p`
    JOIN `ww_users_profile` up ON up.`user_id` = p.`user_id`
    JOIN `ww_time_form_balance_setup_policy` tfbsp ON tfbsp.`class_id`=up.credit_setup_id
    WHERE p.`deleted`=0 AND IFNULL(p.`resigned_date`,'0000-00-00')='0000-00-00' AND
          IF(pclassid=0, 1, up.credit_setup_id = pclassid) AND
          IF(puserid=0, 1, p.user_id = puserid) AND
          FIND_IN_SET(p.`status_id`, tfbsp.`employment_status_ids`) AND FIND_IN_SET(p.`employment_type_id`, p.`employment_type_id`) AND 
          IFNULL(p.`effectivity_date`,'0000-00-00') <> '0000-00-00' AND
          p.`effectivity_date` < pdate; 
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET time_form_balance_process = 1;
    
    -- [2] CREDIT SETUP
    OPEN balance_process;
    
    
    REPEAT
       FETCH balance_process INTO userid, creditid, datehired, statusid, typeid;
       
       IF NOT time_form_balance_process THEN
       
          /* check per user*/
          SET rec = rec + 1;
          
          SET @cstatusid = statusid;
          SET @ctypeid = typeid;
          
          SET @min_credit = 0;
          SET @max_credit = 0;
          SET @eff_date = '';
          SET @pol_id = 0;
          SET @frm_id = '';
          SET @fmr_code = '';
          SET @ids_stat = '';
          SET @ids_type = '';
          SET @id_class = creditid;
          
          IF @id_class > 0 THEN
             SELECT tfbsp.`policy_id`, tfbsp.`form_id`, tfbsp.`form_code`, tfbsp.`starting_credit`, tfbsp.`max_credit`, 
                    tfbsp.`effectivity`, tfbsp.`employment_status_ids`, tfbsp.`employment_type_ids`
             INTO @pol_id, @frm_id, @frm_code, @min_credit, @max_credit, @eff_date, @ids_stat, @ids_type
             FROM `ww_time_form_balance_setup_policy` `tfbsp`
             LEFT JOIN `ww_time_form_balance_credit_class` `tfbcc` ON tfbcc.`deleted`=0 AND tfbcc.`class_id`=tfbsp.`class_id` 
             WHERE tfbsp.`deleted`=0 AND tfbsp.`class_id`=@id_class LIMIT 1;
             
             SET @isok = 0;
             
             
             -- [2.1] CHECK EFFECTIVITY, EMPLOYMENT STATUS, EMPLOYMENT TYPE
                      -- STATUS: permananent, probationary
                      -- TYPE: manager, supervisor, rank & file
             IF IFNULL(@eff_date,'0000-00-00') <> '0000-00-00' THEN
                IF pdate > @eff_date THEN 
                   IF FIND_IN_SET(@cstatusid,@ids_stat) AND FIND_IN_SET(@ctypeid, @ids_type) THEN
                      SET @isok = 1;
                   END IF;
                END IF;
             END IF;
             
             
             -- [2.2] ACCRUAL
             IF @isok = 1 THEN
                SET @id_leave = 0;
                SET @credit = 0;
                SET @tenure = YEAR(pdate) - YEAR(datehired); -- getage(datehired);
                SET @daysvalid = 0;
                
                /* this query causes this stored procedure to malfunction 2017-09-04
                SELECT `id` INTO @id_leave
                FROM `ww_time_form_balance`
                WHERE `deleted`=0 AND form_code=@frm_code AND `year`=YEAR(pdate) AND `user_id`=userid LIMIT 1; */
                
                IF @tenure = 0 THEN
                   -- CHECK FOR DAYS NA PINASOK
                   SET @daysvalid = (pdate - INTERVAL 13 DAY) >= datehired;
                   
                   IF @daysvalid = 0 THEN
                      -- THIS MEANS NO CREDIT SHOULD BE PASS ON
                      SET @tenure = -1;
                   END IF;
                END IF;
                
                SELECT `credits` INTO @credit
                FROM `ww_time_form_balance_setup_increment` 
                WHERE `deleted`=0 AND `policy_id`=@pol_id AND @tenure BETWEEN `from` AND `to`;
                
                IF @credit > 0 THEN
                   IF creditid = 3 THEN
                      IF MONTH(datehired) = MONTH(pdate) AND DAY(datehired) = DAY(pdate) THEN
                         SET @credit = @credit;
                      ELSE
                         SET @credit = 0;
                      END IF;
                   END IF;
                END IF;
                
                INSERT INTO `logtable_leave_balance_accrual` (`log`) VALUES (CONCAT(pdate,' | ',userid,' | ',@credit,' | ',@frm_id));
                
                IF @credit > 0 THEN
		   SET @cnt = 0;
		   SELECT COUNT(`id`) INTO @cnt FROM ww_time_form_balance 
		   WHERE user_id = userid AND form_id = @frm_id AND `year` = YEAR(pdate) AND deleted = 0;
	           
	           INSERT INTO `logtable_leave_balance_accrual` (`log`) VALUES (CONCAT(@cnt,' | ',userid,' | ',@credit,' | ',@frm_id));
	           
	           IF @cnt = 0 THEN    
			   INSERT INTO `ww_time_form_balance`
			   (`year`, `user_id`, `form_id`, `form_code`, `period_from`, `period_to`, `period_extension`)
			   SELECT YEAR(pdate), userid, @frm_id, @frm_code, MAKEDATE(YEAR(pdate),1), LAST_DAY(MAKEDATE(YEAR(pdate),365)), LAST_DAY(MAKEDATE(YEAR(pdate)+1,90))
			   ON DUPLICATE KEY UPDATE modified_on = NOW();
                   END IF;
                      
                   INSERT INTO `ww_time_form_balance_accrual` (user_id, leave_balance_id, form_id, form_code, date_accrued, accrual)
                   SELECT `user_id`, `id`, `form_id`, `form_code`, IF(creditid = 3, pdate, pdate - INTERVAL 1 DAY), @credit
                   FROM `ww_time_form_balance` 
                   WHERE user_id = userid AND form_id = @frm_id AND `year` = YEAR(pdate) AND deleted = 0
                   ON DUPLICATE KEY UPDATE accrual=@credit, modified_on=NOW();
                   
                   UPDATE `ww_time_form_balance` SET modified_on = NOW()
                   WHERE user_id = userid AND form_id = @frm_id AND `year` = YEAR(pdate) AND deleted = 0;
                END IF;
             
             END IF; -- @isok = 1
          
          END IF; -- @id_class > 0
          
       END IF;
    
    UNTIL time_form_balance_process END REPEAT;
    
    CLOSE balance_process;
    
    SELECT rec;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_balance_process_credit` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_balance_process_credit` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_balance_process_credit`()
BEGIN
    
    DECLARE time_form_balance_process_credit TINYINT(11) DEFAULT 0;
    DECLARE policyid INT(11);
    DECLARE formid INT(1);
    DECLARE formcode VARCHAR(32);
    DECLARE classid INT(1);
    DECLARE classcode VARCHAR(32);
    
    
    -- 2017.04.11
    -- [1] CHECK SETUP POLICY
    DECLARE balance_process_credit CURSOR FOR
    SELECT tfbsp.`policy_id`, tfbsp.`form_id`, tfbsp.`form_code`, tfbsp.`class_id`, tfbcc.`class_code`
    FROM `ww_time_form_balance_setup_policy` `tfbsp`
    LEFT JOIN `ww_time_form_balance_credit_class` `tfbcc` ON tfbcc.`deleted`=0 AND tfbcc.`class_id`=tfbsp.`class_id` 
    WHERE tfbsp.`deleted`=0 AND CURDATE()>=tfbsp.`effectivity` ;
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET time_form_balance_process_credit = 1;
    
    
    -- [2] CREDITS
    OPEN balance_process_credit;
    
    REPEAT
       FETCH balance_process_credit INTO policyid, formid, formcode, classid, classcode;
       
       IF NOT time_form_balance_process_credit THEN
          
          if formid = 22 then  -- for LIP
		  IF LEFT(classcode,3) = 'AHI' THEN
		     -- CUSTOM
		     IF classcode = 'AHI-003' THEN
			-- (SRDC) TO BE GIVEN EVERY EVERY YEAR/HIRED DATE
			CALL sp_time_form_balance_process_ahi(CURDATE(), classid, 0);
		     ELSE
			IF DAY(CURDATE()) = 1 THEN
			   -- TO BE GIVEN EVERY 1ST DAY OF EVERY MONTH
			   CALL sp_time_form_balance_process_ahi(CURDATE(), classid, 0);
			END IF;
		     END IF;
		  ELSE
		     -- DEFAULT
		     CALL sp_time_form_balance_process(YEAR(CURDATE()), 0);
		  END IF;
	  else  -- For Home Leave
		CALL sp_time_form_balance_process_hl(CURDATE(), classid, 0);
	  end if;
          
       END IF;
    
    UNTIL time_form_balance_process_credit END REPEAT;
    
    CLOSE balance_process_credit;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_balance_process_credit_manual` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_balance_process_credit_manual` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_balance_process_credit_manual`(IN pdate DATE)
BEGIN
    
    DECLARE time_form_balance_process_credit TINYINT(11) DEFAULT 0;
    DECLARE policyid INT(11);
    DECLARE formid INT(1);
    DECLARE formcode VARCHAR(32);
    DECLARE classid INT(1);
    DECLARE classcode VARCHAR(32);
    
    
    -- 2017.04.11
    -- [1] CHECK SETUP POLICY
    DECLARE balance_process_credit CURSOR FOR
    SELECT tfbsp.`policy_id`, tfbsp.`form_id`, tfbsp.`form_code`, tfbsp.`class_id`, tfbcc.`class_code`
    FROM `ww_time_form_balance_setup_policy` `tfbsp`
    LEFT JOIN `ww_time_form_balance_credit_class` `tfbcc` ON tfbcc.`deleted`=0 AND tfbcc.`class_id`=tfbsp.`class_id` 
    WHERE tfbsp.`deleted`=0 AND pdate>=tfbsp.`effectivity` ;
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET time_form_balance_process_credit = 1;
    
    
    -- [2] CREDITS
    OPEN balance_process_credit;
    
    REPEAT
       FETCH balance_process_credit INTO policyid, formid, formcode, classid, classcode;
       
       IF NOT time_form_balance_process_credit THEN
          
          IF LEFT(classcode,3) = 'AHI' THEN
             -- CUSTOM
             IF classcode = 'AHI-003' THEN
                -- (SRDC) TO BE GIVEN EVERY EVERY YEAR/HIRED DATE
                CALL sp_time_form_balance_process_ahi(pdate, classid, 0);
             ELSE
                IF DAY(pdate) = 1 THEN
                   -- TO BE GIVEN EVERY 1ST DAY OF EVERY MONTH
                   CALL sp_time_form_balance_process_ahi(pdate, classid, 0);
                END IF;
             END IF;
          ELSE
             -- DEFAULT
             CALL sp_time_form_balance_process(YEAR(pdate), 0);
          END IF;
       END IF;
    
    UNTIL time_form_balance_process_credit END REPEAT;
    
    CLOSE balance_process_credit;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_balance_process_hl` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_balance_process_hl` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_balance_process_hl`(IN pdate DATE, IN pclassid INT(11), puserid INT(11))
BEGIN
    
    DECLARE time_form_balance_process TINYINT(1) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE userid INT(11);
    DECLARE creditid INT(1);
    DECLARE datehired DATE;
    DECLARE statusid INT(11);
    DECLARE typeid INT(11);
    
    -- [2017.04.11]
    
    -- [1] CHECK AFFECTED
    DECLARE balance_process CURSOR FOR
    SELECT p.`user_id`, 7, p.`effectivity_date`, p.`status_id`, p.`employment_type_id`
    FROM `ww_partners` `p`
    join `ww_partners_personal` pp on (pp.partner_id = p.partner_id and key_id = 209)
    JOIN `ww_users_profile` up ON up.`user_id` = p.`user_id`
    WHERE p.`deleted`=0 AND IFNULL(p.`resigned_date`,'0000-00-00')='0000-00-00' AND
          pp.key_value = 1 AND
          IF(puserid=0, 1, p.user_id = puserid) AND
          IFNULL(p.`effectivity_date`,'0000-00-00') <> '0000-00-00' AND
          dayofmonth(p.`effectivity_date`) = dayofmonth(pdate) AND
          p.`effectivity_date` < pdate; 
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET time_form_balance_process = 1;
    
    -- [2] CREDIT SETUP
    OPEN balance_process;
    
    
    REPEAT
       FETCH balance_process INTO userid, creditid, datehired, statusid, typeid;
       
       IF NOT time_form_balance_process THEN
       
          /* check per user*/
          SET rec = rec + 1;
          
          SET @cstatusid = statusid;
          SET @ctypeid = typeid;
          
          SET @min_credit = 0;
          SET @max_credit = 0;
          SET @eff_date = '';
          SET @pol_id = 0;
          SET @frm_id = '';
          SET @fmr_code = '';
          SET @ids_stat = '';
          SET @ids_type = '';
          SET @id_class = creditid;
          
          IF @id_class > 0 THEN
             SELECT tfbsp.`policy_id`, tfbsp.`form_id`, tfbsp.`form_code`, tfbsp.`starting_credit`, tfbsp.`max_credit`, 
                    tfbsp.`effectivity`, tfbsp.`employment_status_ids`, tfbsp.`employment_type_ids`
             INTO @pol_id, @frm_id, @frm_code, @min_credit, @max_credit, @eff_date, @ids_stat, @ids_type
             FROM `ww_time_form_balance_setup_policy` `tfbsp`
             LEFT JOIN `ww_time_form_balance_credit_class` `tfbcc` ON tfbcc.`deleted`=0 AND tfbcc.`class_id`=tfbsp.`class_id` 
             WHERE tfbsp.`deleted`=0 AND tfbsp.`class_id`=@id_class LIMIT 1;
             
             SET @isok = 1;
             
             -- [2.2] ACCRUAL
             IF @isok = 1 THEN
                SET @id_leave = 0;
                SET @credit = 0;
                SET @tenure = YEAR(pdate) - YEAR(datehired); -- getage(datehired);
                SELECT `credits` INTO @credit
                FROM `ww_time_form_balance_setup_increment` 
                WHERE `deleted`=0 AND `policy_id`=@pol_id AND @tenure BETWEEN `from` AND `to`;
                
                IF @credit > 0 THEN
		   SET @cnt = 0;
		   SELECT COUNT(`id`) INTO @cnt FROM ww_time_form_balance 
		   WHERE user_id = userid AND form_id = @frm_id AND `year` = YEAR(pdate) AND deleted = 0;
	           
	           IF @cnt = 0 THEN    
			   INSERT INTO `ww_time_form_balance`
			   (`year`, `user_id`, `form_id`, `form_code`, `period_from`, `period_to`, `period_extension`)
			   SELECT YEAR(pdate), userid, @frm_id, @frm_code, MAKEDATE(YEAR(pdate),1), LAST_DAY(MAKEDATE(YEAR(pdate),365)), LAST_DAY(MAKEDATE(YEAR(pdate)+1,90))
			   ON DUPLICATE KEY UPDATE modified_on = NOW();
                   END IF;
                      
                   INSERT INTO `ww_time_form_balance_accrual` (user_id, leave_balance_id, form_id, form_code, date_accrued, accrual)
                   SELECT `user_id`, `id`, `form_id`, `form_code`, IF(creditid = 3, pdate, pdate - INTERVAL 1 DAY), @credit
                   FROM `ww_time_form_balance` 
                   WHERE user_id = userid AND form_id = @frm_id AND `year` = YEAR(pdate) AND deleted = 0
                   ON DUPLICATE KEY UPDATE accrual=@credit, modified_on=NOW();
                   
                   UPDATE `ww_time_form_balance` SET modified_on = NOW()
                   WHERE user_id = userid AND form_id = @frm_id AND `year` = YEAR(pdate) AND deleted = 0;
                END IF;
             
             END IF; -- @isok = 1
          
          END IF; -- @id_class > 0
          
       END IF;
    
    UNTIL time_form_balance_process END REPEAT;
    
    CLOSE balance_process;
    
    SELECT rec;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_balance_process_id` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_balance_process_id` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_balance_process_id`(IN puserid INT(11), IN pdate DATE)
BEGIN
   
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE userid INT;
    DECLARE statusid INT;
    DECLARE positioncode VARCHAR(10) ;
    DECLARE tenure_month INT;
    DECLARE tenure INT;
    DECLARE nday INT;
    DECLARE nmonth INT;
    DECLARE effdate DATE;
    DECLARE birthdate DATE;
    
    -- [1] INCREMENTS FOR EVERY MONTH OF TENURE
    DECLARE balance CURSOR FOR    
    SELECT partners.`user_id`, 
           partners.`status_id`,
	   ww_users_position.position_code,
           `regularization_date`,
	   `birth_date`,
           MONTH(`regularization_date`) AS tenure_month,
           getage(regularization_date) AS tenure,
           DAY(regularization_date) AS applicable_day, 
           IF(TIMESTAMPDIFF(MONTH,regularization_date, pdate) = 12,12,
           TIMESTAMPDIFF(MONTH,regularization_date, pdate) % 12) AS applicable_month
    FROM `partners` 
    JOIN ww_users_profile ON ww_users_profile.partner_id = partners.partner_id
    LEFT JOIN ww_users_position ON ww_users_profile.`position_id` = ww_users_position.position_id
    WHERE 
          IFNULL(`regularization_date`,'0000-00-00')<>'0000-00-00' AND 
          IFNULL(`resigned_date`,'0000-00-00')='0000-00-00' AND 
          `regularization_date` <= pdate AND
          IF(puserid=0,1,partners.`user_id`=puserid)
    ORDER BY `applicable_day`,partners.`user_id`;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
        
    -- START TRANSACTION;
    OPEN balance;
    
    REPEAT
       FETCH balance INTO userid, statusid, positioncode, effdate, birthdate, tenure_month, tenure, nday, nmonth;
       
       IF NOT done THEN	
           SET rec = rec + 1;
           -- execute processing
           INSERT INTO `ww_time_form_balance` (`year`, `user_id`, `form_id`, `form_code`, `current`, `period_from`, `period_to`, `period_extension`)
              /* SELECT YEAR(pdate) applicable_year, 
                     userid, 	
                     2 formid,
                     'VL' formcode,
                     ROUND(((nmonth / 12) * 15),2) prorate, */
           SELECT YEAR(get_fiscaldate_start(pdate) + INTERVAL 1 YEAR) applicable_year, 
                  userid, 
                  ww_time_form.form_id formid,
                  ww_time_form.form_code formcode,
                  ROUND(((nmonth / 12) * 15),2) prorate,
                  get_fiscaldate_start(pdate)  period_from,
                  get_fiscaldate_end(pdate)  period_to,
                  CASE 
                  WHEN form_code = 'VL'
                  THEN get_fiscaldate_end(pdate) + INTERVAL 2 MONTH
                  WHEN form_code = 'SL'
                  THEN get_fiscaldate_end(pdate) 
                  END period_extension
           FROM ww_time_form
           WHERE form_code IN ('SL', 'VL')              
           ON DUPLICATE KEY UPDATE 
              `modified_on` = NOW(), 
              current = VALUES(current), 
              period_from = VALUES(period_from), 
              period_to = VALUES(period_to), 
              period_extension = VALUES(period_extension);
           
           -- Inserting to time_form_balance_accrual
           SET @regularization_date = (SELECT regularization_date FROM ww_partners WHERE user_id=userid);
           SET @accrual_date = @regularization_date + INTERVAL 1 MONTH;
           
           WHILE @accrual_date <= CURDATE() DO 
		 IF (SELECT COUNT(id) FROM ww_time_form_balance WHERE @accrual_date BETWEEN period_from AND period_to AND form_code IN ('SL','VL') AND user_id=userid
		 AND user_id=userid) = 0 THEN
		   	IF (SELECT COUNT(*) FROM ww_time_form_balance_accrual WHERE user_id=userid AND date_accrued=@accrual_date) = 0 THEN
				INSERT INTO ww_time_form_balance_accrual 
				(date_accrued,accrual,user_id,form_code)
				VALUES (@accrual_date, (1 / 12) * 15,userid,'SL');
				
				INSERT INTO ww_time_form_balance_accrual 
				(date_accrued,accrual,user_id,form_code)
				VALUES (@accrual_date, (1 / 12) * 15,userid,'VL');
			END IF;
		ELSE
			IF (SELECT COUNT(*) FROM ww_time_form_balance_accrual WHERE user_id=userid AND date_accrued=@accrual_date) = 0 THEN
			
			INSERT INTO ww_time_form_balance_accrual
			(leave_balance_id,date_accrued,accrual,user_id,form_code)
			VALUES(
			(SELECT id FROM ww_time_form_balance 
			WHERE @accrual_date BETWEEN period_from AND period_to
			AND form_code='SL'
			AND user_id=userid
			AND period_from != '0000-00-00'
			AND YEAR=YEAR(get_fiscaldate_start(@accrual_date))),
			@accrual_date,
			(1 / 12) * 15,
			userid,
			'SL');
			
			INSERT INTO ww_time_form_balance_accrual
			(leave_balance_id,date_accrued,accrual,user_id,form_code)
			VALUES(
			(SELECT id FROM ww_time_form_balance 
			WHERE @accrual_date BETWEEN period_from AND period_to
			AND form_code='VL'
			AND user_id=userid
			AND period_from != '0000-00-00'
			AND YEAR=YEAR(get_fiscaldate_start(@accrual_date))),
			@accrual_date,
			(1 / 12) * 15,
			userid,
			'VL');
			END IF;
		END IF;
		SET @accrual_date = @accrual_date + INTERVAL 1 MONTH;
		 
	   END WHILE;
             -- Birthday Leave
           IF (statusid = 1) THEN
		      IF (MONTH(birthdate) = MONTH(pdate)) THEN
			     INSERT INTO `ww_time_form_balance` (`year`, `user_id`, `form_id`, `form_code`, `current`, `period_from`, `period_to`, `period_extension`)
			     SELECT YEAR(pdate) applicable_year, 
			            userid, 
			            ww_time_form.form_id formid,
			            ww_time_form.form_code formcode,
			            1 prorate,
			            DATE_FORMAT(pdate,'%Y-%m-01') period_from,
			            LAST_DAY(pdate) period_to,
			            LAST_DAY(pdate) period_extension
			     FROM ww_time_form
			     WHERE form_code IN ('BL')              
			     ON DUPLICATE KEY UPDATE 
			        `modified_on` = NOW(), 
			        current = VALUES(current), 
			        period_from = VALUES(period_from), 
			        period_to = VALUES(period_to), 
			        period_extension = VALUES(period_extension);
		      END IF;
           END IF;
             
           IF (positioncode = 'GM' || positioncode = 'DOS' || positioncode = 'DOSM') THEN
		      UPDATE `ww_time_form_balance` 
			 SET 	period_to = 	CASE
						WHEN form_code = 'VL'
						THEN '2099-12-31'
						WHEN form_code = 'SL'
						THEN get_fiscaldate_end(pdate)
						END,
								
			  period_extension = 	CASE
						WHEN form_code = 'VL'
						THEN '2099-12-31'
						WHEN form_code = 'SL'
						THEN get_fiscaldate_end(pdate)
						END
		      WHERE `year` = YEAR(get_fiscaldate_start(pdate)) AND form_code = 'VL' AND `user_id` = userid;
		      
		   /*   UPDATE `ww_time_form_balance` 
		      SET period_to = get_fiscaldate_end(pdate), period_extension = get_fiscaldate_end(pdate)
		      WHERE `year` = YEAR(get_fiscaldate_start(pdate)) AND form_code = 'SL' AND `user_id` = userid;*/
           END IF;
             
        END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE balance;
    
    -- COMMIT;
    SELECT rec;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_balance_process_prorated` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_balance_process_prorated` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_balance_process_prorated`(IN userid INT(11), IN actionid INT(11))
BEGIN
    
    SET @effectivitydate = '';
    SET @pyear = '';
    
    -- [1] GET REGULARIZATION EFFECTIVITY DATE
    SELECT `effectivity_date`, YEAR(`effectivity_date`), effectivity_date INTO @effectivitydate, @pyear, @effectdate
    FROM `ww_partners_movement_action`
    WHERE `action_id` = actionid 
    LIMIT 1;
    
    -- [2] INITIAL CREDITS
    -- CALL sp_time_form_balance_process_credit();    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_balance_process_sil` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_balance_process_sil` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_balance_process_sil`(IN puserid INT(11), IN pdate DATE)
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE userid INT(11);
    DECLARE tenure INT(11);
    DECLARE effdate DATE;
    DECLARE credit INT(11);
    DECLARE form_id INT(11);
    DECLARE form_code VARCHAR(128);
    
    -- [1] INCREMENTS FOR EVERY MONTH OF TENURE
    DECLARE balance CURSOR FOR
    SELECT p.user_id, 
           p.effectivity_date,
           getage(effectivity_date) AS tenure,
           bsp.starting_credit,
           bsp.form_code, 
           bsp.form_id
    FROM `partners` p
    JOIN `users` u 
         ON u.user_id = p.user_id AND u.active = 1
    JOIN `ww_time_form_balance_setup` bs 
         ON bs.deleted = 0 AND bs.employment_status_id = p.status_id AND bs.employment_type_id = p.employment_type_id
    JOIN `ww_time_form_balance_setup_policy` bsp 
         ON bsp.deleted = 0 AND bsp.balance_setup_id = bs.balance_setup_id AND 
            p.effectivity_date BETWEEN bs.from AND bs.to 
    WHERE 
          IFNULL(p.effectivity_date,'0000-00-00')<>'0000-00-00' AND 
          IFNULL(`resigned_date`,'0000-00-00')='0000-00-00' AND 
          p.effectivity_date = pdate AND
          IF(puserid=0,1,p.user_id=puserid)
          AND bsp.form_code = 'SIL'
    ORDER BY p.user_id;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
        
    -- START TRANSACTION;
    OPEN balance;
    
    REPEAT
       FETCH balance INTO userid, effdate, tenure, credit, form_code, form_id;
       
       IF NOT done THEN
           SET rec = rec + 1;
           
           -- execute processing
           IF (tenure >= 1) THEN
              
              INSERT INTO `ww_time_form_balance` (`year`, `user_id`, `form_id`, `form_code`, `current`)
              SELECT YEAR(pdate) applicable_year, 
                     userid, 
                     form_id formid,
                     form_code formcode,
                     credit
              ON DUPLICATE KEY UPDATE 
                 `modified_on` = NOW();
              
           END IF;
           
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE balance;
    
    -- COMMIT;
    SELECT rec;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_leave_conversion` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_leave_conversion` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_leave_conversion`()
BEGIN
	update ww_time_form_balance tfb,ww_users u
	set tfb.paid_unit = if(tfb.balance > 10, 10, tfb.balance)
	where ((tfb.user_id = u.user_id )
	AND (u.user_id = p.user_id )
	AND tfb.year = YEAR(CURDATE() - INTERVAL 1 YEAR) 
	AND (u.active = 1)
	AND (p.status_id <> 2 AND p.status_id <> 5)
	AND (form_id = 22));	  
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_leave_conversion_curr_year` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_leave_conversion_curr_year` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_leave_conversion_curr_year`()
BEGIN
	update ww_time_form_balance tfb,ww_users u,ww_partners p
	set tfb.paid_unit = if(tfb.balance > 10, 10, if(tfb.balance > 0,tfb.balance,0))
	where ((tfb.user_id = u.user_id)
	and (u.user_id = p.user_id )
	AND (tfb.year = year(curdate())) 
	AND (u.active = 1)
	and (p.status_id <> 2)
	AND (form_id = 22));	      
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_form_leave_forfeiture` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_form_leave_forfeiture` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_form_leave_forfeiture`()
BEGIN
	UPDATE ww_time_form_balance tfb
	SET tfb.forfeited = IF(tfb.previous > 0 AND get_leave_used_carry_over(tfb.user_id,YEAR(CURDATE())) > 0,IF(tfb.previous - get_leave_used_carry_over(tfb.user_id,YEAR(CURDATE())) > 0,tfb.previous - get_leave_used_carry_over(tfb.user_id,YEAR(CURDATE())),0),0)
	WHERE tfb.year=YEAR(CURDATE())
	AND tfb.form_id = 22;  
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_generate_approvers` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_generate_approvers` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_generate_approvers`()
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE forms CURSOR FOR
       SELECT  tr.`forms_id`, tr.`user_id` FROM `time_forms` tr WHERE `deleted`=0;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- START TRANSACTION;
        
    OPEN forms;
    
    REPEAT
       FETCH forms INTO recordid, userid;
       
       IF NOT done THEN
       
           CALL `sp_time_forms_populate_approvers`(recordid, userid);
          
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE forms;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_generate_aux` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_generate_aux` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_generate_aux`()
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE userid INT;
    DECLARE formcode VARCHAR(8);
    DECLARE formsid INT; 
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE forms CURSOR FOR
       SELECT  tr.`form_code`, tr.`user_id`, tr.`forms_id` 
       FROM `time_forms` tr WHERE `form_status_id`=6;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
 
    -- START TRANSACTION;
        
    OPEN forms;
    
    REPEAT
       FETCH forms INTO formcode, userid, formsid;
       
       IF NOT done THEN
           SET rec = rec + 1;
           CALL `sp_time_forms_aux_shift`(formcode, userid, formsid);
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE forms;
    
    -- COMMIT;
    
    SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_performace_planning_reminder` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_performace_planning_reminder` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_performace_planning_reminder`()
BEGIN
    
    DECLARE done TINYINT(1) DEFAULT 0;
    DECLARE userid INT(11);
    DECLARE planningid INT(11);
    DECLARE yearid INT(1);
    DECLARE email VARCHAR(128);
     
    DECLARE rec INT(11) DEFAULT 0;
     
    DECLARE planning CURSOR FOR
       SELECT pp.`planning_id`, ppa.`user_id`, u.`email`, pp.`year`
       FROM `ww_performance_planning` pp
       JOIN `ww_performance_planning_reminder` ppr ON ppr.`planning_id`=pp.`planning_id` AND ppr.`deleted`=0
       JOIN `ww_performance_planning_applicable` ppa ON ppa.`planning_id`=pp.`planning_id`
       JOIN `users` u ON u.`user_id`=ppa.`user_id`
       WHERE pp.`deleted`=0 AND ppr.`notification_id`=1 AND ppr.`date`=CURDATE();
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    SET @system_url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
    SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
    SET @system_author = (SELECT `value` FROM `ww_config` WHERE `key`='author' LIMIT  1);
    SET @system_fromaddress = (SELECT `value` FROM `ww_config` WHERE `key`='from_address' LIMIT  1);
    
    SET @emailto = @system_fromaddress;
    SET @emailsubject = '';
    SET @emailbody = '';
    SET @tbody = '';
    SET @bcc = ''; 
    SET @url = '';
     
    -- template 
    SELECT `subject`,`body` INTO @emailsubject, @emailbody
    FROM `ww_system_template`
    WHERE `code`='PPA-REMINDER' AND deleted=0 LIMIT 1;
    
    IF @emailsubject <> '' THEN
       SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
       SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @system_url);
       SET @emailbody = REPLACE(@emailbody, '{{system_author}}', @system_author);
       
       SET @count_recipients = 0;
       SET @is_hundred = 0;
       
       
       OPEN planning;
         
       REPEAT
          FETCH planning INTO planningid, userid, email, yearid;
          
          IF NOT done THEN
       
             SET rec = rec + 1;
             SET @bcc = CONCAT(email,', ', @bcc);
             SET @is_hundred = @count_recipients % 100;
             
             -- 
             SET @emailbody = REPLACE(@emailbody, '{{year}}', yearid);
             
             -- 
             IF @is_hundred = 0 AND @count_recipients > 0 THEN
                INSERT INTO `ww_system_email_queue` (`to`, `bcc`, `subject`,`body`)
                SELECT @emailto, @bcc, @emailsubject, @emailbody;
                SET @bcc = ''; -- reset
             END IF;
             
             SET @count_recipients = @count_recipients + 1;
          
          END IF;
       UNTIL done END REPEAT;
	 
       CLOSE planning;
       
       IF (CHAR_LENGTH(@bcc) > 0) THEN 
          INSERT INTO `ww_system_email_queue` (`to`, bcc, `subject`,`body`)
          SELECT @emailto, @bcc, @emailsubject, @emailbody;
       END IF;
       
    END IF;
     
    SELECT rec;
     
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_late_attnd_deduction` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_late_attnd_deduction` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_late_attnd_deduction`(
	IN prev_periodid INT(11),
	IN puserid INT(11),
	in dtPay date,
	IN cur_periodid INT(11)
    )
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE employee_id INT(11);
	DECLARE comp_id INT(11);
	DECLARE salary DECIMAL(12,2);
	DECLARE dates DATE;
	DECLARE orig_paydate DATE;
	DECLARE rec_id INT(11);
	DECLARE absent TINYINT(1);
	DECLARE lwop DECIMAL(5,2);
	DECLARE late DECIMAL(5,2);
	DECLARE undertime DECIMAL(5,2);
	DECLARE total_days DECIMAL(5,2);
	DECLARE day_type VARCHAR(32);
	
	DECLARE dtr CURSOR FOR
		SELECT p.`user_id`, u.`company_id`, AES_DECRYPT( p.`salary`,encryption_key() ) AS salary ,
			rp.`date`, rs.`payroll_date`, rs.`record_id`, 
			SUM((CASE transaction_code WHEN 'ABSENCES' THEN rp.quantity ELSE 0 END))*COUNT(DISTINCT rp.date)/COUNT(*) AS absent,
			SUM((CASE transaction_code WHEN 'LWOP' THEN rp.quantity ELSE 0 END))*COUNT(DISTINCT rp.date)/COUNT(*) AS lwop,
			SUM((CASE transaction_code WHEN 'DEDUCTION_LATE' THEN rp.quantity ELSE 0 END))*COUNT(DISTINCT rp.date)/COUNT(*) AS late,
			SUM((CASE transaction_code WHEN 'DEDUCTION_UNDERTIME' THEN rp.quantity ELSE 0 END))*COUNT(DISTINCT rp.date)/COUNT(*) AS undertime,
			-- SUM((CASE transaction_code WHEN 'ABSENCES' THEN rp.quantity ELSE 0 END)) AS absent,
			-- SUM((CASE transaction_code WHEN 'LWOP' THEN rp.quantity ELSE 0 END)) AS lwop,
			-- SUM((CASE transaction_code WHEN 'DEDUCTION_LATE' THEN rp.quantity ELSE 0 END)) AS late,
			-- SUM((CASE transaction_code WHEN 'DEDUCTION_UNDERTIME' THEN rp.quantity ELSE 0 END)) AS undertime,
			p.`total_year_days`, rs.`day_type`, dtPay, cur_periodid
		FROM ww_time_record_process rp
		INNER JOIN ww_time_record_summary rs ON rp.date = rs.date AND rs.`user_id` = rp.user_id
		INNER JOIN ww_payroll_partners p ON rp.`user_id` = p.`user_id`
		INNER JOIN ww_time_period t ON t.`payroll_date` = rs.`payroll_date`
		INNER JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		WHERE rp.`date` BETWEEN t.`date_from` AND t.`date_to` 
			AND IF(puserid=0,1,p.`user_id`=puserid) AND t.`period_id` = prev_periodid AND t.`company_id` = u.`company_id`
			AND rp.transaction_code in ('ABSENCES','LWOP','DEDUCTION_UNDERTIME','DEDUCTION_LATE')
		GROUP BY rp.date, rp.`user_id`;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	
	OPEN dtr;
	
	myLoop: LOOP
		FETCH dtr INTO employee_id, comp_id, salary, dates, orig_paydate, rec_id, absent, lwop, late, undertime, total_days, day_type, dtPay, cur_periodid ;
		
		IF done THEN
		    CLOSE dtr;
		    LEAVE myLoop;
		END IF;		
		
		SET @hourly_rate = 0;
		SET @hourly_rate = ( salary / ( total_days / 12 ) ) / 8;
		SET @OrigPaydate = orig_paydate;
		SET @latefile = 1;
		
		IF absent != 0 THEN 
			DELETE FROM ww_time_record_process 
			WHERE user_id = employee_id AND payroll_date = dtPay and `date` = dates
				AND original_payroll_date = orig_paydate AND transaction_code = 'ABSENCES_ADJ';
			SET @tran_code = 'ABSENCES_ADJ';
			SET @qty = 0;
			SET @qty = time_validate_attendance_deduction( employee_id, dates, absent, 'ABSENCES' );
			if @qty != 0 then
				CALL sp_time_period_summary_insert( rec_id, employee_id, dates, dtPay, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, cur_periodid);
			end if;
		END IF;
		
		/* IF lwop != 0 THEN
			DELETE FROM ww_time_record_process 
			WHERE user_id = employee_id AND payroll_date = dtPay AND `date` = dates
				AND original_payroll_date = orig_paydate AND transaction_code = 'LWOP_ADJ';
			SET @tran_code = 'LWOP_ADJ';
			SET @qty = 0;
			SET @qty = time_validate_attendance_deduction( employee_id, dates, lwop, 'LWOP' );
			IF @qty != 0 THEN
				CALL sp_time_period_summary_insert( rec_id, employee_id, dates, dtPay, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, cur_periodid);
			end if;
		END IF; */
		
		IF late != 0 THEN
			DELETE FROM ww_time_record_process 
			WHERE user_id = employee_id AND payroll_date = dtPay AND `date` = dates
				AND original_payroll_date = orig_paydate AND transaction_code = 'DEDUCTION_LATE_ADJ';
			SET @tran_code = 'DEDUCTION_LATE_ADJ';
			SET @qty = 0;
			SET @qty = time_validate_attendance_deduction( employee_id, dates, late, 'DEDUCTION_LATE' );
			IF @qty != 0 THEN
				CALL sp_time_period_summary_insert( rec_id, employee_id, dates, dtPay, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, cur_periodid);
			end if;
		END IF;
		
		IF undertime != 0 THEN
			DELETE FROM ww_time_record_process 
			WHERE user_id = employee_id AND payroll_date = dtPay AND `date` = dates
				AND original_payroll_date = orig_paydate AND transaction_code = 'DEDUCTION_UNDERTIME_ADJ';
			SET @tran_code = 'DEDUCTION_UNDERTIME_ADJ';
			SET @qty = 0;
			SET @qty = time_validate_attendance_deduction( employee_id, dates, undertime, 'DEDUCTION_UNDERTIME' );
			IF @qty != 0 THEN
				CALL sp_time_period_summary_insert( rec_id, employee_id, dates, dtPay, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, cur_periodid);
			end if;
		END IF;
	END LOOP;
	
	END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_late_attnd_deduction_2` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_late_attnd_deduction_2` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_late_attnd_deduction_2`(
	IN prev_periodid INT(11),
	IN puserid INT(11),
	in dtPay date,
	IN cur_periodid INT(11)
    )
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE employee_id INT(11);
	DECLARE comp_id INT(11);
	DECLARE salary DECIMAL(12,2);
	DECLARE dates DATE;
	DECLARE orig_paydate DATE;
	DECLARE rec_id INT(11);
	DECLARE absent TINYINT(1);
	DECLARE lwop DECIMAL(5,2);
	DECLARE late DECIMAL(5,2);
	DECLARE undertime DECIMAL(5,2);
	DECLARE total_days DECIMAL(5,2);
	DECLARE day_type VARCHAR(32);
	
	DECLARE dtr CURSOR FOR
		SELECT p.`user_id`, u.`company_id`, AES_DECRYPT( p.`salary`,encryption_key() ) AS salary ,
			rp.`date`, rs.`payroll_date`, rs.`record_id`, 
			SUM((CASE transaction_code WHEN 'ABSENCES' THEN rp.quantity ELSE 0 END)) AS absent,
			SUM((CASE transaction_code WHEN 'LWOP' THEN rp.quantity ELSE 0 END)) AS lwop,
			SUM((CASE transaction_code WHEN 'DEDUCTION_LATE' THEN rp.quantity ELSE 0 END)) AS late,
			SUM((CASE transaction_code WHEN 'DEDUCTION_UNDERTIME' THEN rp.quantity ELSE 0 END)) AS undertime,
			p.`total_year_days`, rs.`day_type`, dtPay, cur_periodid
		FROM ww_time_record_process rp
		INNER JOIN ww_time_record_summary rs ON rp.date = rs.date AND rs.`user_id` = rp.user_id
		INNER JOIN ww_payroll_partners p ON rp.`user_id` = p.`user_id`
		INNER JOIN ww_time_period t ON t.`payroll_date` = rs.`payroll_date`
		INNER JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		WHERE rp.`date` BETWEEN t.`date_from` AND t.`date_to` 
			AND IF(puserid=0,1,p.`user_id`=puserid) AND t.`period_id` = prev_periodid AND t.`company_id` = u.`company_id`
			AND rp.transaction_code in ('ABSENCES','LWOP','DEDUCTION_UNDERTIME','DEDUCTION_LATE')
		GROUP BY rp.date, rp.`user_id`;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
	
	OPEN dtr;
	
	INSERT INTO `logtable` (`log`) SELECT 'Start.';
	myLoop: LOOP
		FETCH dtr INTO employee_id, comp_id, salary, dates, orig_paydate, rec_id, absent, lwop, late, undertime, total_days, day_type, dtPay, cur_periodid ;
		
		IF done THEN
		    CLOSE dtr;
		    LEAVE myLoop;
		END IF;		
		
		SET @hourly_rate = 0;
		SET @hourly_rate = ( salary / ( total_days / 12 ) ) / 8;
		SET @OrigPaydate = orig_paydate;
		SET @latefile = 1;
		
		IF absent != 0 THEN 
			DELETE FROM ww_time_record_process 
			WHERE user_id = employee_id AND payroll_date = dtPay and `date` = dates
				AND original_payroll_date = orig_paydate AND transaction_code = 'ABSENCES_ADJ';
			SET @tran_code = 'ABSENCES_ADJ';
			SET @qty = 0;
			INSERT INTO `logtable` (`log`) SELECT CONCAT('time_validate_attendance_deduction', ', ', employee_id, ', ', dates, ', ', absent, ', ', 'ABSENCES' );
			SET @qty = time_validate_attendance_deduction( employee_id, dates, absent, 'ABSENCES' );
			if @qty != 0 then
				-- CALL sp_time_period_summary_insert( rec_id, employee_id, dates, dtPay, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, cur_periodid);
				INSERT INTO `logtable` (`log`) SELECT CONCAT('sp_time_period_summary_insert', ', ',rec_id, ', ',employee_id, ', ',dates, ', ',dtPay, ', ',@OrigPaydate, ', ',@latefile, ', ',@tran_code, ', ',@qty, ', ',@hourly_rate, ', ',cur_periodid);
			end if;
		END IF;
		
		IF lwop != 0 THEN
			DELETE FROM ww_time_record_process 
			WHERE user_id = employee_id AND payroll_date = dtPay AND `date` = dates
				AND original_payroll_date = orig_paydate AND transaction_code = 'LWOP_ADJ';
			SET @tran_code = 'LWOP_ADJ';
			SET @qty = 0;
			INSERT INTO `logtable` (`log`) SELECT CONCAT('time_validate_attendance_deduction', ', ', employee_id, ', ', dates, ', ', lwop, ', ', 'LWOP' );
			SET @qty = time_validate_attendance_deduction( employee_id, dates, lwop, 'LWOP' );
			IF @qty != 0 THEN
				-- CALL sp_time_period_summary_insert( rec_id, employee_id, dates, dtPay, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, cur_periodid);
				INSERT INTO `logtable` (`log`) SELECT CONCAT('sp_time_period_summary_insert', ', ',rec_id, ', ',employee_id, ', ',dates, ', ',dtPay, ', ',@OrigPaydate, ', ',@latefile, ', ',@tran_code, ', ',@qty, ', ',@hourly_rate, ', ',cur_periodid);
			end if;
		END IF;
		
		IF late != 0 THEN
			DELETE FROM ww_time_record_process 
			WHERE user_id = employee_id AND payroll_date = dtPay AND `date` = dates
				AND original_payroll_date = orig_paydate AND transaction_code = 'DEDUCTION_LATE_ADJ';
			SET @tran_code = 'DEDUCTION_LATE_ADJ';
			SET @qty = 0;
			INSERT INTO `logtable` (`log`) SELECT CONCAT('time_validate_attendance_deduction', ', ', employee_id, ', ', dates, ', ', late, ', ', 'DEDUCTION_LATE' );
			SET @qty = time_validate_attendance_deduction( employee_id, dates, late, 'DEDUCTION_LATE' );
			IF @qty != 0 THEN
				-- CALL sp_time_period_summary_insert( rec_id, employee_id, dates, dtPay, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, cur_periodid);
				INSERT INTO `logtable` (`log`) SELECT CONCAT('sp_time_period_summary_insert', ', ',rec_id, ', ',employee_id, ', ',dates, ', ',dtPay, ', ',@OrigPaydate, ', ',@latefile, ', ',@tran_code, ', ',@qty, ', ',@hourly_rate, ', ',cur_periodid);
			end if;
		END IF;
		
		IF undertime != 0 THEN
			DELETE FROM ww_time_record_process 
			WHERE user_id = employee_id AND payroll_date = dtPay AND `date` = dates
				AND original_payroll_date = orig_paydate AND transaction_code = 'DEDUCTION_UNDERTIME_ADJ';
			SET @tran_code = 'DEDUCTION_UNDERTIME_ADJ';
			SET @qty = 0;
			INSERT INTO `logtable` (`log`) SELECT CONCAT('time_validate_attendance_deduction', ', ', employee_id, ', ', dates, ', ', undertime, ', ', 'DEDUCTION_UNDERTIME' );
			SET @qty = time_validate_attendance_deduction( employee_id, dates, undertime, 'DEDUCTION_UNDERTIME' );
			IF @qty != 0 THEN
				-- CALL sp_time_period_summary_insert( rec_id, employee_id, dates, dtPay, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, cur_periodid);
				INSERT INTO `logtable` (`log`) SELECT CONCAT('sp_time_period_summary_insert', ', ',rec_id, ', ',employee_id, ', ',dates, ', ',dtPay, ', ',@OrigPaydate, ', ',@latefile, ', ',@tran_code, ', ',@qty, ', ',@hourly_rate, ', ',cur_periodid);
			end if;
		END IF;
	END LOOP;
	INSERT INTO `logtable` (`log`) SELECT 'Done.';
	END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_late_overtime` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_late_overtime` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_late_overtime`( 
	IN periodid INT(11),
	IN puserid INT(11)	
	)
BEGIN
	SET @nCompID = 0;
	SET @dtPay = '0000-00-00';	
	SELECT company_id, payroll_date INTO @nCompID, @dtPay FROM ww_time_period
	WHERE period_id = periodid;
	
	SET @nPeriod = time_get_previous_period(periodid);
	SET @dtFrom = get_time_period_from(@nPeriod, @nCompID);
	SET @dtTo = get_time_period_to(@nPeriod, @nCompID);
	
	BEGIN
		DECLARE done TINYINT(1) DEFAULT 0;
		DECLARE emp_id INT(11);
		DECLARE frm_id INT(11);
		DECLARE dtApprv DATETIME;
		DECLARE dtTimeFrm DATETIME;
		DECLARE dtTimeTo DATETIME;
		DECLARE dtDate DATE;
		DECLARE paydate DATE;
		DECLARE comp_id INT(11);
		DECLARE period_id INT(11);
		DECLARE overtime CURSOR FOR
			SELECT a.`user_id`, a.`forms_id`, DATE(a.`date_approved`), b.`time_from`, b.`time_to`, b.`date`, @nCompID, @dtPay, @nPeriod
			FROM ww_time_forms a
			LEFT JOIN ww_time_forms_date b ON a.forms_id = b.forms_id
			LEFT JOIN ww_users_profile up ON up.`user_id` = a.`user_id`
			WHERE a.`deleted` = 0 AND b.`deleted` = 0
				AND a.`form_status_id` = 6 AND a.`date_approved` IS NOT NULL AND a.`form_code` = 'OT'
				AND IF(puserid=0,1,a.`user_id`=puserid)
				AND up.company_id = @nCompID
				AND b.`date` BETWEEN @dtFrom AND @dtTo
				AND date(a.`date_approved`) > time_get_cut_off( b.`date`, @nCompID )
			UNION
			SELECT tfb.`user_id`, tf.`forms_id`, DATE(tf.`created_on`), tfd.`time_from`, tfd.`time_to`, tfd.`date`, @nCompID, @dtPay, @nPeriod
			FROM ww_time_forms tf, ww_time_forms_date tfd, ww_time_forms_blanket tfb, ww_users_profile up
			WHERE tf.`forms_id` = tfd.`forms_id` AND tf.`deleted` = 0 AND tfd.`deleted` = 0
				AND tf.`forms_id` = tfb.`forms_id` AND tfb.deleted = 0
				and tfb.user_id = up.user_id
				AND if(puserid=0,1,tfb.user_id=puserid) AND tfd.date BETWEEN @dtFrom AND @dtTo 
				AND DATE(tf.created_on) > time_get_cut_off( tfd.date, @nCompID)
				AND tf.`form_code` = 'OT'
				and up.company_id = @nCompID;
		DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
		
		OPEN overtime;
		
		myLoop: LOOP
			FETCH overtime INTO emp_id, frm_id, dtApprv, dtTimeFrm, dtTimeTo, dtDate, comp_id,  paydate, period_id ;
			
			IF done THEN
			    CLOSE overtime;
			    LEAVE myLoop;
			END IF;
			-- get shift
			DELETE FROM ww_time_record_process WHERE record_id = frm_id AND user_id = emp_id ;
			
			SET @ActualIN = "";
			SET @ActualOUT = "";
			SET @otStart = "";
			SET @otEnd = "";
			SET @nHourlyRate = 0;
			SET @nSalary = 0;
			SET @nTotalDays = 0;
			SELECT AES_DECRYPT(salary, encryption_key()), total_year_days
			INTO @nSalary, @nTotalDays
			FROM ww_payroll_partners WHERE user_id = emp_id;
			
			SET @nHourlyRate = ( @nSalary / ( @nTotalDays / 12 ) ) / 8;
			
			SET @sDayType = get_time_daytype(emp_id, dtDate);
			SET @ShiftID = 0;
			SET @ShiftID = time_get_shift(emp_id, dtDate);
			-- get sched out
			SET @SchedOut = CONCAT(dtDate, ' ', time_get_sched_out( @ShiftID ) );
			SET @SchedIn = CONCAT(dtDate, ' ', time_get_sched_in( @ShiftID ) );
			-- get current ND set up
			SET @curStartND = CONCAT(dtDate, ' ', time_get_nd_start( @ShiftID, comp_id ) );
			SET @curEndND = CONCAT( ADDDATE( dtDate, 1 ), ' ', time_get_nd_end( @ShiftID, comp_id ) );
			-- get previous ND set up
			SET @prevStartND = CONCAT( ADDDATE( dtDate, -1 ), ' ', time_get_nd_start( @ShiftID, comp_id ) );
			SET @prevEndND = CONCAT( dtDate, ' ', time_get_nd_end( @ShiftID, comp_id ) );
			-- get actual time in / out
			SET @ActualIN = time_get_time_in( emp_id, dtDate);
			SET @ActualOUT = time_get_time_out( emp_id, dtDate);
			
			SET @OrigPaydate = '0000-00-00';
			SET @dtPaydate = '0000-00-00';
			SET @latefile = 0;
			SET @cutoff = time_get_cut_off( dtDate, comp_id );
			IF dtApprv > @cutoff THEN
				-- set original payroll date
				SET @latefile = 1;
				SET @OrigPaydate = time_get_payroll_date( dtDate, comp_id );
				SET @dtPaydate = time_get_payroll_date( dtApprv, comp_id );
			ELSE 
				SET @latefile = 0;
				SET @dtPaydate = paydate;
				SET @OrigPaydate = paydate;
			END IF;
			
			-- start of regular 
			IF @sDayType = 'REGULAR' THEN
				-- pre shift ot
				IF dtTimeFrm < @SchedIn THEN
					
					IF dtTimeTo >= @SchedIn THEN
						SET @otEnd =  @SchedIn;
					END IF;
					IF dtTimeTo < @SchedIn THEN
						SET @otEnd =  dtTimeTo;
					END IF;
					
					SET @otStart = dtTimeFrm;
					IF dtTimeFrm < @ActualIN THEN
						SET @otStart = @ActualIN;
					END IF;
					
					SET @otUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = 'REGOT';
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
					-- check if has ND
					IF @ActualIN < @prevEndND THEN
						IF dtTimeFrm <= @prevStartND THEN
							SET @ndStart = @prevStartND;
						END IF;
						IF dtTimeFrm > @prevStartND THEN
							SET @ndStart = dtTimeFrm;
						END IF;
						SET @ndStart = @ActualIN;
						IF @ActualIN < dtTimeFrm THEN
							SET @ndStart = dtTimeFrm;
						END IF;
						SET @ndEnd = @prevEndND;
						IF dtTimeTo < @prevEndND THEN
							SET @ndEnd = dtTimeTo;
						END IF;
						
						SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );					
						IF @ndUnit > 0 THEN
							SET @tran_code = '';
							SET @tran_code = 'REGOT_ND';
							SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
							CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
						END IF;
					END IF;
				-- after shift ot
				ELSEIF dtTimeFrm > @SchedIn THEN
					IF dtTimeFrm <= @SchedOut THEN
						SET @otStart = @SchedOut;
					END IF;
					IF dtTimeFrm > @SchedOut THEN
						SET @otStart = dtTimeFrm;
					END IF;
					
					SET @otEnd = dtTimeTo;
					IF dtTimeTo > @ActualOUT THEN	
						SET @otEnd = @ActualOUT;
					END IF;
					
					SET @otUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = 'REGOT';
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
					-- check if has ND
					IF @ActualOUT > @curStartND THEN
						IF dtTimeTo >= @curEndND THEN
							SET @ndEnd = @curEndND;
						END IF;
						IF dtTimeTo < @curEndND THEN
							SET @ndEnd = dtTimeTo;
						END IF;
						IF dtTimeTo > @ActualOUT THEN
							SET @ndEnd = @ActualOUT;
						END IF;
						
						IF dtTimeFrm <= @curStartND THEN
							SET @ndStart = @curStartND;
						END IF;
						IF dtTimeFrm > @curStartND THEN
							SET @ndStart = dtTimeFrm;
						END IF;
						
						SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
						IF @ndUnit > 0 THEN
							SET @tran_code = '';
							SET @tran_code = 'REGOT_ND';
							SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
							CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
						END IF;
					END IF;
				END IF;
				-- end of regular
			
			ELSE 
				IF @sDayType = 'RESTDAY' OR @sDayType = 'OFF' THEN
					SET @trans = 'RDOT';
				ELSEIF @sDayType = 'LEGAL' THEN
					IF @ShiftID = 1 THEN
						SET @trans = 'LEGRDOT';
					ELSE		
						SET @trans = 'LEGOT';
					END IF;
				ELSEIF @sDayType = 'SPECIAL' THEN
					IF @ShiftID = 1 THEN
						SET @trans = 'SPERDOT';
					ELSE
						SET @trans = 'SPEOT';
					END IF;
				ELSEIF @sDayType = 'DOUBLE' THEN
					IF @ShiftID = 1 THEN
						SET @trans = 'DOBRDOT';
					ELSE
						SET @trans = 'DOBOT';
					END IF;
				END IF;
				
				IF @ActualIN <= dtTimeFrm THEN
					SET @otStart = dtTimeFrm;
				ELSEIF @ActualIN > dtTimeFrm THEN
					SET @otStart = @ActualIN;
				END IF;
				SET @otStart = dtTimeFrm;
				
				IF @ActualOUT >= dtTimeTo THEN
					SET @otEnd = dtTimeTo;
				ELSEIF @ActualOUT < dtTimeTo THEN
					SET @otEnd = @ActualOUT;
				END IF;
				SET @otEnd = dtTimeTo;
				
				SET @Unit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
				
				IF @Unit > 8 THEN
					SET @otUnit = 8.00;
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = @trans;
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
					SET @otUnitExcess = @Unit - 8.00;
					IF @otUnitExcess > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_EXCESS');
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnitExcess, @ot_rate, period_id);
					END IF;
				ELSE 
					SET @otUnit = @Unit;
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = @trans;
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
				END IF;
				-- check if first 8 hours has ND
				-- ND on the Ot Start
				IF @otStart < @prevEndND THEN
					SET @ndStart = @otStart;
					SET @ndEnd = @prevEndND;
					SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_ND');
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;
				END IF;
				-- ND on the First 8 Hrs
				SET @firstEight = ADDTIME( @otStart, '08:00:00' );
				
				IF @curStartND < @firstEight THEN
					SET @ndStart = @curStartND;
					SET @ndEnd = @firstEight;
					IF @firstEight > @otEnd THEN
						SET @ndEnd = @otEnd;
					END IF;
					SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_ND');
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;
				END IF;
				-- ND on the Remaining Hrs
				IF @firstEight < @otEnd THEN
					IF @firstEight > @curStartND THEN
						SET @ndStart = @firstEight;
					ELSE 
						SET @ndStart = @curStartND;
					END IF;
					
					SET @ndEnd = @otEnd;
					IF @otEnd > @curEndND THEN
						SET @ndEnd = @curEndND;
					END IF;
					IF @ndEnd > @ndStart THEN
						SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					END IF;		
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_ND_EXCESS');
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;	
				END IF;			
			END IF;		
		END LOOP;
		END;
	END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_late_overtime_2` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_late_overtime_2` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_late_overtime_2`( 
	IN periodid INT(11),
	IN puserid INT(11)	
	)
BEGIN
	SET @nCompID = 0;
	SET @dtPay = '0000-00-00';	
	SELECT company_id, payroll_date INTO @nCompID, @dtPay FROM ww_time_period
	WHERE period_id = periodid;
	
	SET @nPeriod = time_get_previous_period(periodid);
	SET @dtFrom = get_time_period_from(@nPeriod, @nCompID);
	SET @dtTo = get_time_period_to(@nPeriod, @nCompID);
	
	BEGIN
		DECLARE done TINYINT(1) DEFAULT 0;
		DECLARE emp_id INT(11);
		DECLARE frm_id INT(11);
		DECLARE dtApprv DATETIME;
		DECLARE dtTimeFrm DATETIME;
		DECLARE dtTimeTo DATETIME;
		DECLARE dtDate DATE;
		DECLARE paydate DATE;
		DECLARE comp_id INT(11);
		DECLARE period_id INT(11);
		DECLARE overtime CURSOR FOR
			SELECT a.`user_id`, a.`forms_id`, DATE(a.`date_approved`), b.`time_from`, b.`time_to`, b.`date`, @nCompID, @dtPay, @nPeriod
			FROM ww_time_forms a
			LEFT JOIN ww_time_forms_date b ON a.forms_id = b.forms_id
			LEFT JOIN ww_users_profile up ON up.`user_id` = a.`user_id`
			WHERE a.`deleted` = 0 AND b.`deleted` = 0
				AND a.`form_status_id` = 6 AND a.`date_approved` IS NOT NULL AND a.`form_code` = 'OT'
				AND IF(puserid=0,1,a.`user_id`=puserid)
				AND up.company_id = @nCompID
				AND b.`date` BETWEEN @dtFrom AND @dtTo
				AND date(a.`date_approved`) > time_get_cut_off( b.`date`, @nCompID )
			UNION
			SELECT tfb.`user_id`, tf.`forms_id`, DATE(tf.`created_on`), tfd.`time_from`, tfd.`time_to`, tfd.`date`, @nCompID, @dtPay, @nPeriod
			FROM ww_time_forms tf, ww_time_forms_date tfd, ww_time_forms_blanket tfb, ww_users_profile up
			WHERE tf.`forms_id` = tfd.`forms_id` AND tf.`deleted` = 0 AND tfd.`deleted` = 0
				AND tf.`forms_id` = tfb.`forms_id` AND tfb.deleted = 0
				and tfb.user_id = up.user_id
				AND if(puserid=0,1,tfb.user_id=puserid) AND tfd.date BETWEEN @dtFrom AND @dtTo 
				AND DATE(tf.created_on) > time_get_cut_off( tfd.date, @nCompID)
				AND tf.`form_code` = 'OT'
				and up.company_id = @nCompID;
		DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
		
		OPEN overtime;
		
		myLoop: LOOP
			FETCH overtime INTO emp_id, frm_id, dtApprv, dtTimeFrm, dtTimeTo, dtDate, comp_id,  paydate, period_id ;
			
			IF done THEN
			    CLOSE overtime;
			    LEAVE myLoop;
			END IF;
			-- get shift
			SELECT 'start';
			DELETE FROM ww_time_record_process WHERE record_id = frm_id AND user_id = emp_id ;
			
			SET @ActualIN = "";
			SET @ActualOUT = "";
			SET @otStart = "";
			SET @otEnd = "";
			SET @nHourlyRate = 0;
			SET @nSalary = 0;
			SET @nTotalDays = 0;
			SELECT AES_DECRYPT(salary, encryption_key()), total_year_days
			INTO @nSalary, @nTotalDays
			FROM ww_payroll_partners WHERE user_id = emp_id;
			
			SET @nHourlyRate = ( @nSalary / ( @nTotalDays / 12 ) ) / 8;
			SELECT 'get_time_daytype',emp_id, dtDate;
			SET @sDayType = get_time_daytype(emp_id, dtDate);
			SET @ShiftID = 0;
			SELECT 'time_get_shift', emp_id, dtDate;
			SET @ShiftID = time_get_shift(emp_id, dtDate);
			-- get sched out
			SELECT 'time_get_sched_out', @ShiftID;
			SET @SchedOut = CONCAT(dtDate, ' ', time_get_sched_out( @ShiftID ) );
			SELECT 'time_get_sched_in', @ShiftID;
			SET @SchedIn = CONCAT(dtDate, ' ', time_get_sched_in( @ShiftID ) );
			-- get current ND set up
			SELECT 'time_get_nd_start', @ShiftID, comp_id;
			SET @curStartND = CONCAT(dtDate, ' ', time_get_nd_start( @ShiftID, comp_id ) );
			SELECT 'time_get_nd_end', @ShiftID, comp_id;
			SET @curEndND = CONCAT( ADDDATE( dtDate, 1 ), ' ', time_get_nd_end( @ShiftID, comp_id ) );
			-- get previous ND set up
			SELECT 'prev-time_get_nd_start', @ShiftID, comp_id;
			SET @prevStartND = CONCAT( ADDDATE( dtDate, -1 ), ' ', time_get_nd_start( @ShiftID, comp_id ) );
			SELECT 'prev-time_get_nd_end', @ShiftID, comp_id;
			SET @prevEndND = CONCAT( dtDate, ' ', time_get_nd_end( @ShiftID, comp_id ) );
			-- get actual time in / out
			SET @ActualIN = time_get_time_in( emp_id, dtDate);
			SET @ActualOUT = time_get_time_out( emp_id, dtDate);
			
			SET @OrigPaydate = '0000-00-00';
			SET @dtPaydate = '0000-00-00';
			SET @latefile = 0;
			SET @cutoff = time_get_cut_off( dtDate, comp_id );
			IF dtApprv > @cutoff THEN
				-- set original payroll date
				SET @latefile = 1;
				SET @OrigPaydate = time_get_payroll_date( dtDate, comp_id );
				SET @dtPaydate = time_get_payroll_date( dtApprv, comp_id );
			ELSE 
				SET @latefile = 0;
				SET @dtPaydate = paydate;
				SET @OrigPaydate = paydate;
			END IF;
			
			-- start of regular 
			IF @sDayType = 'REGULAR' THEN
				-- pre shift ot
				IF dtTimeFrm < @SchedIn THEN
					
					IF dtTimeTo >= @SchedIn THEN
						SET @otEnd =  @SchedIn;
					END IF;
					IF dtTimeTo < @SchedIn THEN
						SET @otEnd =  dtTimeTo;
					END IF;
					
					SET @otStart = dtTimeFrm;
					IF dtTimeFrm < @ActualIN THEN
						SET @otStart = @ActualIN;
					END IF;
					
					SET @otUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = 'REGOT';
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
					-- check if has ND
					IF @ActualIN < @prevEndND THEN
						IF dtTimeFrm <= @prevStartND THEN
							SET @ndStart = @prevStartND;
						END IF;
						IF dtTimeFrm > @prevStartND THEN
							SET @ndStart = dtTimeFrm;
						END IF;
						SET @ndStart = @ActualIN;
						IF @ActualIN < dtTimeFrm THEN
							SET @ndStart = dtTimeFrm;
						END IF;
						SET @ndEnd = @prevEndND;
						IF dtTimeTo < @prevEndND THEN
							SET @ndEnd = dtTimeTo;
						END IF;
						
						SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );					
						IF @ndUnit > 0 THEN
							SET @tran_code = '';
							SET @tran_code = 'REGOT_ND';
							SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
							CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
						END IF;
					END IF;
				-- after shift ot
				ELSEIF dtTimeFrm > @SchedIn THEN
					IF dtTimeFrm <= @SchedOut THEN
						SET @otStart = @SchedOut;
					END IF;
					IF dtTimeFrm > @SchedOut THEN
						SET @otStart = dtTimeFrm;
					END IF;
					
					SET @otEnd = dtTimeTo;
					IF dtTimeTo > @ActualOUT THEN	
						SET @otEnd = @ActualOUT;
					END IF;
					
					SET @otUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = 'REGOT';
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
					-- check if has ND
					IF @ActualOUT > @curStartND THEN
						IF dtTimeTo >= @curEndND THEN
							SET @ndEnd = @curEndND;
						END IF;
						IF dtTimeTo < @curEndND THEN
							SET @ndEnd = dtTimeTo;
						END IF;
						IF dtTimeTo > @ActualOUT THEN
							SET @ndEnd = @ActualOUT;
						END IF;
						
						IF dtTimeFrm <= @curStartND THEN
							SET @ndStart = @curStartND;
						END IF;
						IF dtTimeFrm > @curStartND THEN
							SET @ndStart = dtTimeFrm;
						END IF;
						
						SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
						IF @ndUnit > 0 THEN
							SET @tran_code = '';
							SET @tran_code = 'REGOT_ND';
							SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
							CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
						END IF;
					END IF;
				END IF;
				-- end of regular
			
			ELSE 
				IF @sDayType = 'RESTDAY' OR @sDayType = 'OFF' THEN
					SET @trans = 'RDOT';
				ELSEIF @sDayType = 'LEGAL' THEN
					IF @ShiftID = 1 THEN
						SET @trans = 'LEGRDOT';
					ELSE		
						SET @trans = 'LEGOT';
					END IF;
				ELSEIF @sDayType = 'SPECIAL' THEN
					IF @ShiftID = 1 THEN
						SET @trans = 'SPERDOT';
					ELSE
						SET @trans = 'SPEOT';
					END IF;
				ELSEIF @sDayType = 'DOUBLE' THEN
					IF @ShiftID = 1 THEN
						SET @trans = 'DOBRDOT';
					ELSE
						SET @trans = 'DOBOT';
					END IF;
				END IF;
				
				IF @ActualIN <= dtTimeFrm THEN
					SET @otStart = dtTimeFrm;
				ELSEIF @ActualIN > dtTimeFrm THEN
					SET @otStart = @ActualIN;
				END IF;
				SET @otStart = dtTimeFrm;
				
				IF @ActualOUT >= dtTimeTo THEN
					SET @otEnd = dtTimeTo;
				ELSEIF @ActualOUT < dtTimeTo THEN
					SET @otEnd = @ActualOUT;
				END IF;
				SET @otEnd = dtTimeTo;
				
				SET @Unit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
				
				IF @Unit > 8 THEN
					SET @otUnit = 8.00;
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = @trans;
						SELECT '1',@tran_code, comp_id, @nHourlyRate;
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						SELECT '1.a',@tran_code, comp_id, @nHourlyRate;
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
					SET @otUnitExcess = @Unit - 8.00;
					IF @otUnitExcess > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_EXCESS');
						SELECT '_excess',@tran_code, comp_id, @nHourlyRate;
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						SELECT '_excess.a',@tran_code, comp_id, @nHourlyRate;
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnitExcess, @ot_rate, period_id);
					END IF;
				ELSE 
					SET @otUnit = @Unit;
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = @trans;
						SELECT '2',@tran_code, comp_id, @nHourlyRate;
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						SELECT '2.a',@tran_code, comp_id, @nHourlyRate;
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
				END IF;
				-- check if first 8 hours has ND
				-- ND on the Ot Start
				IF @otStart < @prevEndND THEN
					SET @ndStart = @otStart;
					SET @ndEnd = @prevEndND;
					SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_ND');
						SELECT '3',@tran_code, comp_id, @nHourlyRate;
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						SELECT '3.1',@tran_code, comp_id, @nHourlyRate;
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;
				END IF;
				-- ND on the First 8 Hrs
				SET @firstEight = ADDTIME( @otStart, '08:00:00' );
				
				IF @curStartND < @firstEight THEN
					SET @ndStart = @curStartND;
					SET @ndEnd = @firstEight;
					IF @firstEight > @otEnd THEN
						SET @ndEnd = @otEnd;
					END IF;
					SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_ND');
						SELECT '4',@tran_code, comp_id, @nHourlyRate;
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						SELECT '4.a',@tran_code, comp_id, @nHourlyRate;
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;
				END IF;
				-- ND on the Remaining Hrs
				IF @firstEight < @otEnd THEN
					IF @firstEight > @curStartND THEN
						SET @ndStart = @firstEight;
					ELSE 
						SET @ndStart = @curStartND;
					END IF;
					
					SET @ndEnd = @otEnd;
					IF @otEnd > @curEndND THEN
						SET @ndEnd = @curEndND;
					END IF;
					IF @ndEnd > @ndStart THEN
						SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					END IF;		
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_ND_EXCESS');
						SELECT '5',@tran_code, comp_id, @nHourlyRate;
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						SELECT '5.a',@tran_code, comp_id, @nHourlyRate;
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;	
				END IF;			
			END IF;		
		END LOOP;
		END;
	END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_populate` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_populate` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_populate`(IN FromDate DATE, IN ToDate DATE, IN CompanyID INT(11))
BEGIN
    SET @done = 0;
    SET @dates = FromDate;
    SET @rec = 0;
       
    -- [1] Loop inclusive supplied from parameters    
    REPEAT
       
       IF @dates >= ToDate THEN
          SET @done = 1;
       END IF;
        
       -- [2] All ACTIVE partners only
       --     2017-03-18: Use partners calendar_id instead of shift_id
       INSERT INTO `ww_time_record` (`user_id`, `date`, `shift_id`)
       SELECT p.`user_id`, @dates, IF(IFNULL(tswc.`shift_id`,0)=0, p.`shift_id`, tswc.`shift_id`) `shiftx`
       FROM `ww_partners` p
       INNER JOIN `ww_users_profile` up ON up.`user_id`=p.`user_id`
       LEFT JOIN `ww_time_shift_weekly_calendar` tswc ON tswc.calendar_id=p.calendar_id AND tswc.`week_name`=DAYNAME(@dates)
       WHERE
          -- Check for Resignation Date later: p.`resigned_date` 
          IF(IFNULL(p.`resigned_date`,'0000-00-00') = '0000-00-00', 1, IF(p.`resigned_date` >= @dates, 1, 0)) AND
          IF(CompanyID=0, 1, up.`company_id` = CompanyID)
       ON DUPLICATE KEY UPDATE `shift_id` = IF(IFNULL(tswc.`shift_id`,0)=0, p.`shift_id`, tswc.`shift_id`);
       
       SET @dates = @dates + INTERVAL 1 DAY;
       SET @rec = @rec + 1;
             
    UNTIL @done END REPEAT;
    
    SELECT @rec;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_populate_user` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_populate_user` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_populate_user`(IN FromDate DATE, IN ToDate DATE, IN UserID INT(11))
BEGIN
    SET @time_period_populate_user_done = 0;
    SET @dates = FromDate;
    SET @rec = 0;
       
    -- [1] Loop inclusive supplied from parameters    
    REPEAT
       
       IF @dates >= ToDate THEN
          SET @time_period_populate_user_done = 1;
       END IF;
       
       -- [2] All ACTIVE partners only
       --     2017-03-18: Use partners calendar_id instead of shift_id
       INSERT INTO `ww_time_record` (`user_id`, `date`, `shift_id`)
       SELECT 
          p.`user_id`, 
          @dates,
          IF(IFNULL(tswc.`shift_id`,0)=0, p.`shift_id`, tswc.`shift_id`) `shiftx`
          
       FROM `ww_partners` p
       INNER JOIN `ww_users_profile` up ON up.`user_id`=p.`user_id`
       LEFT JOIN `ww_time_shift_weekly_calendar` tswc ON tswc.calendar_id=p.calendar_id AND tswc.`week_name`=DAYNAME(@dates)
       WHERE
          -- Check for Resignation Date later: p.`resigned_date` 
          IF(IFNULL(p.`resigned_date`,'0000-00-00') = '0000-00-00', 1, IF(p.`resigned_date` >= @dates, 1, 0)) AND
          p.`user_id` = UserID 
       ON DUPLICATE KEY UPDATE `shift_id` = IF(IFNULL(tswc.`shift_id`,0)=0, p.`shift_id`, tswc.`shift_id`);
       
       SET @dates = @dates + INTERVAL 1 DAY;
       SET @rec = @rec + 1;
             
    UNTIL @time_period_populate_user_done END REPEAT;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process`(IN periodid INT(11), IN userid INT(11))
BEGIN
    
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE dtStart DATE;
    DECLARE dtEnd DATE;
    DECLARE dtPay DATE;
    
    
    -- STEP 1: CREATE A TEMPORARY TABLE TO HOLD INITIAL SUMMARY
    -- [[
    DROP TEMPORARY TABLE IF EXISTS `timeprocess`;
    CREATE TEMPORARY TABLE `timeprocess` (
           `record_id` INT(11) UNSIGNED NOT NULL DEFAULT '0',
           `user_id` INT(11) NOT NULL DEFAULT '0',
           `id_number` VARCHAR(8) NOT NULL DEFAULT '',
           `date` DATE NOT NULL DEFAULT '0000-00-00',
           `period_id` INT(11) NOT NULL DEFAULT '0',
           `payroll_date` DATE NOT NULL DEFAULT '0000-00-00',
           `shift_id` INT(11) NOT NULL DEFAULT '0',
           `shift` VARCHAR(16) NOT NULL DEFAULT '',
           `timein` DATETIME DEFAULT '0000-00-00 00:00:00',
           `timeout` DATETIME DEFAULT '0000-00-00 00:00:00',
           `day_type` VARCHAR(16) DEFAULT 'REGULAR',
           `hrs_rendered` DECIMAL(5,2) DEFAULT '0.00',
           `hrs_actual` DECIMAL(5,2) DEFAULT '0.00',
           `hrs_break` DECIMAL(5,2) DEFAULT '0.00',
           `absent` TINYINT(1) DEFAULT '0',
           `lwp` DECIMAL(5,2) DEFAULT '0.00',
           `lwop` DECIMAL(5,2) DEFAULT '0.00',
           `late` DECIMAL(5,2) DEFAULT '0.00',
           `undertime` DECIMAL(5,2) DEFAULT '0.00',
           `nd` decimal(5,2) default '0.00',
           `ot` DECIMAL(5,2) DEFAULT '0.00',
           `ot_break` DECIMAL(5,2) DEFAULT '0.00',
           `meal` DECIMAL(5,2) DEFAULT '0.00',
           `transpo` DECIMAL(5,2) DEFAULT '0.00',
           `resigned` TINYINT(1) DEFAULT '0',
           `awol` TINYINT(1) DEFAULT '0',
           `lip_approved_below_13_days` TINYINT(1) DEFAULT '0',
           `override` TINYINT(1) DEFAULT '0', -- >> (VALUE: 1=not to include, 0=include) field tag to check whether to include in the time record
    PRIMARY KEY (`record_id`,`user_id`,`date`,`payroll_date`),
            KEY `user_id` (`user_id`),
            KEY `date` (`date`),
            KEY `payroll_date` (`payroll_date`)
    ) ENGINE=INNODB DEFAULT CHARSET=utf8;
    -- ]] STEP 1
    
    
        
    -- STEP 2: INSERT TIME RECORDS NET OF ATTENDANCE LOGS
    -- [[
    CALL sp_time_period_process_cws(periodid,userid); -- last minute check on cws
    
    INSERT INTO `timeprocess`
       ( `record_id`, `user_id`, `date`, `period_id`, `payroll_date`, `shift_id`, `shift`, `timein`, `timeout`,
         `hrs_rendered` )
       SELECT 
          tr.`record_id`, tr.`user_id`, tr.`date`, tp.`period_id`, tp.`payroll_date`, 
          IF( IFNULL(tr.`aux_shift_id`, 0) = 0, tr.`shift_id`, IFNULL(tr.`aux_shift_id`, 0) ) `shift_id`,
          IF( IFNULL(tr.`aux_shift_id`, 0) = 0, tr.`shift`, IFNULL(tr.`aux_shift`, 0) ) `shift`,
          IF( IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') = '0000-00-00 00:00:00', 
              IFNULL(tr.`time_in`, '0000-00-00 00:00:00'), 
              IF( IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') > IFNULL(tr.`time_in`, '0000-00-00 00:00:00') AND IFNULL(tr.`time_in`, '0000-00-00 00:00:00') <> '0000-00-00 00:00:00',
                 IFNULL(tr.`time_in`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') 
              )
          ) `timein`,
          IF( IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00') = '0000-00-00 00:00:00', 
              IFNULL(tr.`time_out`, '0000-00-00 00:00:00'), 
              IF( IFNULL(tr.`time_out`, '0000-00-00 00:00:00') > IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`time_out`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00') 
              )
          ) `timeout`,
          
          time_period_process_workhrs(tr.`user_id`, tr.`date`)
       /*
       FROM  `time_record` tr, `ww_time_period` tp, `users_profile` up
       WHERE  up.`company_id` = tp.`company_id` AND
              up.`user_id` = tr.`user_id` AND
              tp.period_id = periodid AND
              IF(userid = 0, 1, tr.`user_id` = userid) AND
              tr.`date` BETWEEN tp.date_from AND IF(tp.date_to > DATE(NOW()), DATE(NOW()), tp.date_to); */
       FROM `ww_time_record` tr
       JOIN `ww_users_profile` up ON up.`user_id` = tr.`user_id`
       JOIN `ww_time_period` tp ON up.`company_id` = tp.`company_id`
       LEFT JOIN `ww_time_period_apply_to_id` tpati ON tpati.`period_id` = tp.`period_id`
       JOIN `ww_partners` p ON p.`user_id` = tr.`user_id`
       WHERE 
              tp.period_id = periodid AND
              IF(userid = 0, 1, tr.`user_id` = userid) AND
              tr.`date` BETWEEN tp.date_from AND IF(tp.date_to > DATE(NOW()), DATE(NOW()), tp.date_to) 
              AND
              IF(tp.`apply_to_id` = 0, 1, 
                 IF(tp.`apply_to_id` = 1, tpati.`apply_to_id` = tr.`user_id`, 
                    IF(tp.`apply_to_id` = 2, tpati.`apply_to_id` = p.`status_id`, 
                       IF(tp.`apply_to_id` = 3, tpati.`apply_to_id` = up.`division_id`, 
                          IF(tp.`apply_to_id` = 4, tpati.`apply_to_id` = up.`department_id`, 1))))) ;
    -- ]] STEP 2
    
    
    
    -- STEP 3: SET RESTDAY, ABSENT, LWOP, LEAVE, etc... (AWOL is executed outside this script)
    -- [[
    -- > 3.1 RESTDAY
    UPDATE `timeprocess` t, `time_shift` ts 
           SET t.`day_type` = UPPER(ts.`shift`), 
               t.`hrs_rendered` = 0
           WHERE t.`shift_id` = ts.`shift_id` AND 
                 UPPER(ts.`shift`) IN ('OFF','RESTDAY');
                     
      -- > 3.2 HOLIDAY / LEGAL / SPECIAL 
    UPDATE `timeprocess` t
    INNER JOIN `ww_time_holiday` th ON th.deleted = 0
    LEFT JOIN `ww_time_holiday_location` thl ON thl.deleted = 0 AND thl.`holiday_id` = th.`holiday_id` AND thl.`user_id` = t.`user_id`
    
           SET t.`day_type` = IF( th.`legal` = 1, 
                                  -- TRUE: IF(t.`day_type`='RESTDAY', 'RDHOL', 'LEGAL'),
                                  'LEGAL',
                                  -- FALSE:
                                  IF( IFNULL(th.`location_count`,0) = 0,
                                      -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                      'SPECIAL',
                                      -- FALSE:
                                      IF( thl.`user_id` = t.`user_id`,
                                          -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                          'SPECIAL',
                                          -- FALSE:
                                          t.`day_type`
                                      )
                                  )
                              )
           WHERE t.`date` = th.`holiday_date`; -- AND th.legal = 1;  -- AND t.`day_type` = 'REGULAR'; -- remove temporary since legal rest day does not compute 02/15/2019
    
    -- > 3.2 HOLIDAY / LEGAL / SPECIAL 
    UPDATE `timeprocess` t
    INNER JOIN `ww_time_holiday` th ON th.deleted = 0
    LEFT JOIN `ww_time_holiday_location` thl ON thl.deleted = 0 AND thl.`holiday_id` = th.`holiday_id` AND thl.`user_id` = t.`user_id`
    
           SET t.`day_type` = IF( th.`legal` = 1, 
                                  -- TRUE: IF(t.`day_type`='RESTDAY', 'RDHOL', 'LEGAL'),
                                  'LEGAL',
                                  -- FALSE:
                                  IF( IFNULL(th.`location_count`,0) = 0,
                                      -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                      'SPECIAL',
                                      -- FALSE:
                                      IF( thl.`user_id` = t.`user_id`,
                                          -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                          'SPECIAL',
                                          -- FALSE:
                                          t.`day_type`
                                      )
                                  )
                              )
           WHERE t.`date` = th.`holiday_date`; -- AND th.legal = 0  AND t.`day_type` = 'REGULAR';
           
    SELECT date_from,cutoff INTO @period_date_from,@period_cutoff
    FROM `ww_time_period` WHERE period_id = periodid;
        
    /*UPDATE `timeprocess` t
           SET t.`timein` = if(time_period_process_absent_w_in_cutoff(t.`user_id`,t.`date`,@period_date_from,@period_cutoff) = 0,t.`timein`,'0000-00-00 00:00:00'),
               t.`timeout` = IF(time_period_process_absent_w_in_cutoff(t.`user_id`,t.`date`,@period_date_from,@period_cutoff) = 0,t.`timeout`,'0000-00-00 00:00:00')
           WHERE t.`day_type` = 'REGULAR'; */    
    
    -- > 3.3 ABSENT
    UPDATE `timeprocess` t
           SET t.`absent` = 1, t.`hrs_rendered` = 0
           WHERE `day_type` = 'REGULAR' AND 
                 (`timein` = '0000-00-00 00:00:00' OR `timeout` = '0000-00-00 00:00:00');
    
    -- > 3.4 LEAVE WITH PAY /AND/ LEAVE WITHOUT PAY
    SET @lwop = 0;
    SELECT GROUP_CONCAT(`form_id`) INTO @lwop FROM `ww_time_form` WHERE `form_code`='LWOP' OR `form_code`='FLV' LIMIT 1;
    
    UPDATE `timeprocess` t
           SET t.`lwop` = time_period_process_lwop(t.`user_id`,t.`date`,@lwop,@period_cutoff,@period_date_from),
               t.`lwp` = time_period_process_lwp(t.`user_id`,t.`date`,@lwop,@period_cutoff),
               t.`hrs_break` = time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') / 60,
               t.`lip_approved_below_13_days` = time_record_form_lwp(t.`user_id`,year(t.`date`),month(t.`date`))
           WHERE t.`day_type` = 'REGULAR';
    -- ]] STEP 3    
    
    
    
    -- STEP 4: SET LATE AND UNDERTIME
    -- [[
    -- > 4.1 LATE (Converted to HOUR): limited to regular schedule only and its assigned schedule including all applications
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF(t.`absent` = 1, 
                             -- TRUE: assigned no lates since it is already absent
                             0,
                             -- FALSE: get minutes considering grace period
                             IF( (TIMESTAMPDIFF(MINUTE, 
                                                (CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_start`) + INTERVAL 
                                                (time_period_process_shift_department('GRACE-PERIOD-IN-MINUTES','EMPLOYMENT-TYPE', 
                                                    u.company_id, t.`shift_id`, t.`user_id`, '0')) MINUTE),
                                  t.`timein` )*1) <= 0,
                                  -- TRUE: assigned no lates
                                  0,
                                  -- FALSE: get minutes lates disregarding grace period
                                  TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_start`), t.`timein`) / 60
                             )
                          )
           WHERE t.`day_type` = 'REGULAR' AND 
		 t.`shift_id` = ts.`shift_id` and
		 t.user_id = u.user_id;
		 
    -- 4.1 LATE (Converted to HOUR): limited to regular schedule only and its assigned schedule including all applications
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF(time_period_process_ut(t.`user_id`,t.`date`,ts.`time_start`,ts.`time_end`) > 0, 
                             -- TRUE: assigned no lates since it is already undertime
                             0,
                             -- FALSE: no changes on the value
                             t.`late`
                          )
           WHERE t.`day_type` = 'REGULAR' AND 
		 t.`shift_id` = ts.`shift_id` AND
		 t.user_id = u.user_id;
		            
    -- > 4.1.1 EXEMPTIONS ON SPECIAL PARTNERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      u.company_id, t.`shift_id`, t.`user_id`, '00:00:00') <> '00:00:00',
                            -- TRUE: special condition normally on managers (e.g. flexi until 10am)
                            IF( TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')), t.`timein`) > 0,
                                -- TRUE:
                                TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')), t.`timein`) / 60,
                                -- FALSE:
                                0
                            ),
                            -- FALSE: no changes on the value
                            t.`late`
                        )
           WHERE t.`late` > 0 AND 
		 t.`shift_id` = ts.`shift_id` and
		 t.user_id = u.user_id;           
    
    -- > 4.1.2 EXEMPTIONS ON MANAGERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      u.company_id, t.`shift_id`, t.`user_id`,'00:00:00') <> '00:00:00',
                            -- TRUE: special condition normally on managers (e.g. flexi until 10am)
                            IF( TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      u.company_id, t.`shift_id`, t.`user_id`,'00:00:00')), t.`timein`) > 0,
                                -- TRUE:
                                TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      u.company_id, t.`shift_id`, t.`user_id`,'00:00:00')), t.`timein`) / 60,
                                -- FALSE:
                                0
                            ),
                            -- FALSE: no changes on the value
                            t.`late`
                        )
           WHERE t.`late` > 0 AND 
		 t.`shift_id` = ts.`shift_id` and
		 t.user_id = u.user_id;           
    
    
    -- > 4.1.3 EXEMPTIONS ON EXCUSED TARDINESS
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`late` = 0
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'ET' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    
    
    -- > 4.2 UNDERTIME (Converted to HOUR)
    -- >
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`undertime` = IF(t.`absent` = 1, 
                           -- TRUE: assigned no undertime since it is already absent
                           0,
                           -- FALSE: get minutes interval
                           IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`) ) <= 0,
                               -- TRUE: assigned no lates
                               0,
                               -- FALSE: get minutes interval
                               IF( TIME(time_period_process_shift('FIRST-HALF-END','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '00:00:00')) = TIME(t.`timeout`),
                                  -- TRUE: less break
                                  (TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`)) / 60) - t.`hrs_break`,
                                  -- FALSE: 
                                  TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`)) / 60
                               )
                           )
                        )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 -- t.`lwp` = 0 AND 
                 -- t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id`;
    
    -- > 4.2.1 UNDERTIME (Converted to HOUR)
    -- >
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`undertime` = IF(t.`absent` = 1, 
                           -- TRUE: assigned no undertime since it is already absent
                           0,
                           -- FALSE: get undertime am
                           if(time_period_process_ut_checking(t.`user_id`,t.`date`) > 0,
				   time_period_process_ut(t.`user_id`,t.`date`,ts.`time_start`,ts.`time_end`),
				   IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`) ) <= 0,
				       -- TRUE: assigned no lates
				       0,
				       -- FALSE: get minutes interval
				       IF( TIME(time_period_process_shift('FIRST-HALF-END','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '00:00:00')) = TIME(t.`timeout`),
					  -- TRUE: less break
					  (TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`)) / 60) - t.`hrs_break`,
					  -- FALSE: 
					  TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`)) / 60
				       )
				   )
		           )
                        )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`shift_id` = ts.`shift_id`;
                 
    -- > 4.2.1 EXEMPTIONS ON SPECIAL PARTNERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u 
           SET t.`undertime` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                             u.company_id, t.`shift_id`, t.`user_id`, '00:00:00') <> '00:00:00',
                               
                                   IF( t.`timein` <= CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', 
                                                            time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                             u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')),
                                
                                       -- TRUE: special condition on special partner (e.g. flexi until 10am)
                                       IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL t.`hrs_break` HOUR
                                                                 ) ) > 0,
                                           TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL t.`hrs_break` HOUR
                                                                 ) ) / 60,
                                           -- FALSE: no changes on the value
                                           0
                                       ),
                                       0
                                   ),
                                   -- FALSE: no changes on the value
                                   t.`undertime`
                               )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id` and
                 t.user_id = u.user_id;
    
    
    -- > 4.2.2 EXEMPTIONS ON MANAGERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`undertime` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                             u.company_id, t.`user_id`, t.`shift_id`,'00:00:00') <> '00:00:00',
                               
                                   IF( t.`timein` <= CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', 
                                                            time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                             u.company_id, t.`user_id`, t.`shift_id`,'00:00:00')),
                                
                                       -- TRUE: special condition on special partner (e.g. flexi until 10am)
                                       IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') MINUTE
                                                                 ) ) > 0,
                                           TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') MINUTE
                                                                 ) ) / 60,
                                           -- FALSE: no changes on the value
                                           0
                                       ),
                                       0
                                   ),
                                   -- FALSE: no changes on the value
                                   t.`undertime`
                               )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id` and 
                 t.user_id = u.user_id;
    
    
    -- > 4.2.3 EXEMPTIONS ON EXCUSED UNDERTIME
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`undertime` = 0
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'UT' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    
    
    -- > 4.2.4 EXEMPTIONS ON EMERGENCY LEAVE
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`late` = 0, 
               t.`undertime` = 0, 
               t.`absent` = 0,
               t.`hrs_rendered` = IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0)
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'EL' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    -- ]] STEP 4
    -- (classcode VARCHAR(32), classgroup VARCHAR(32), comp_id INT(11), shiftid INT(11), userid INT(11), optreturn VARCHAR(32))
    -- STEP 5: COMPLETING RENDERED HOURS... FINAL CHECK
    -- [[
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                              u.company_id, t.`shift_id`, t.`user_id`, '00:00:00') <> '00:00:00'
                                    ,
                                    -- TRUE                                    
                                    IF( TIME(t.`timein`) > TIME(time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                              u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')),
                                        -- TRUE
                                        IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) / 2,
                                        -- FALSE
                                        t.`late`
                                    )
                                    ,
                                    -- FALSE
                                    t.`late`
                                )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id` and
                 t.user_id = u.user_id;
            
    UPDATE `timeprocess` t
           SET t.`absent` = 0, t.`hrs_rendered` = IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) * IF(t.`lwp` * 8 IN (4,6), .5, 1)
           WHERE t.`lwp` > 0 AND t.absent = 1;
    
    UPDATE `timeprocess` t
           SET t.`absent` = 0, t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime` - (IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) * IF(t.`lwop` * 8 IN (4,6), .5, IF(t.`lwop`=0, 0,1) ))
           WHERE t.`day_type` = 'REGULAR' AND t.`lwop` > 0;
    
    -- To process LIP
    UPDATE `timeprocess` t
           SET t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime`
           WHERE t.`day_type` = 'REGULAR' AND t.`lwp` > 0;
               
    UPDATE `timeprocess` t
           SET t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime`
           WHERE t.`day_type` = 'REGULAR' AND t.`lwop` = 0 AND t.`lwp` = 0;
    
    UPDATE `timeprocess` t
           SET t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime`
           WHERE t.`day_type` IN ('SPECIAL','LEGAL');
    -- ]] STEP 5
    
    
    
    -- STEP 6: RESIGNED TAGGING / COMPUTE OVERTIME
    -- [[
    -- > 6.1 RESIGNED
    UPDATE `timeprocess` t
           SET t.`resigned` = time_period_process_resigned(t.`user_id`, t.`date`);
    
    -- > 6.2 OVERTIME
    UPDATE ww_time_record_summary SET ot = 0 WHERE period_id = periodid AND IF(user_id = 0, 1, user_id = userid);
    CALL sp_time_period_process_summary_ot(periodid, userid);
    
    -- > 6.2.1 OVERTIME BREAK
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_break` tdtb ON tdtb.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_break` tdb ON tdb.`deleted` = 0 AND tdb.`break_id` = tdtb.`break_id`
    JOIN `ww_time_day_break_range` tdbr ON tdbr.`break_id` = tdb.`break_id`
    join `ww_users` u on u.user_id = t.user_id and u.company_id = tdbr.company_id
           SET t.`ot_break` = IFNULL(tdbr.`deduction`, 0)
           WHERE t.`ot` > 0 AND (t.`ot` BETWEEN tdbr.`hour_from` AND tdbr.`hour_to`);
    
    -- > 6.2.2 MEAL ALLOWANCE
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_allowance` tdta ON tdta.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_meal` tdm ON tdm.`deleted` = 0 AND tdm.`meal_id` = tdta.`meal_id`
    JOIN `ww_time_day_meal_range` tdmr ON tdmr.`meal_id` = tdm.`meal_id`
    JOIN `partners` p ON p.`user_id` = t.`user_id`
    JOIN `ww_time_day_allowance` tda ON tda.`employment_type_id` = p.`employment_type_id`
           SET t.`meal` = IFNULL(tdmr.`multiplier`, 0) * IFNULL(tda.`meal`, 0)
           WHERE t.`ot` > 0 AND ((t.`ot` - t.`ot_break`) BETWEEN tdmr.`hour_from` AND tdmr.`hour_to`);
    
    -- > 6.2.3 TRANSPO ALLOWANCE
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_allowance` tdta ON tdta.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_transpo` tdm ON tdm.`deleted` = 0 AND tdm.`transpo_id` = tdta.`transpo_id`
    JOIN `ww_time_day_transpo_range` tdmr ON tdmr.`transpo_id` = tdm.`transpo_id`
    JOIN `partners` p ON p.`user_id` = t.`user_id`
    JOIN `ww_time_day_allowance` tda ON tda.`employment_type_id` = p.`employment_type_id`
           SET t.`transpo` = IFNULL(tdmr.`multiplier`, 0) * IFNULL(tda.`transpo`, 0)
           WHERE t.`ot` > 0 AND ((t.`ot` - t.`ot_break`) BETWEEN tdmr.`hour_from` AND tdmr.`hour_to`);
    -- > 6.2.4 EXEMPTION ON ABSENT TAGGING ON CURRENT DATE
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`absent` = IF(NOW() < CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`), 0, t.`absent`)
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`date` = CURDATE() AND
                 t.`absent` = 1 AND
                 t.`shift_id` = ts.`shift_id`;
    
    -- > 6.2.5 MOVE LATE TO UNDERTIME
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd
           SET t.`undertime` = IF(IFNULL(t.`late`,0) > 0, IFNULL(t.`undertime`,0)+t.`late`, t.`undertime`),
               t.`late` = IF(t.`late` > 0, 0, t.`late`)
           WHERE tf.`user_id` = t.`user_id` AND 
                 tf.`form_code` = 'UT' AND 
                 tf.`form_status_id` = 6 AND 
                 tf.`forms_id` =  tfd.`forms_id` AND 
                 tfd.`duration_id` IN (1,2) AND
                 tfd.`date` =  t.`date`;
   -- ]] STEP 6
    
    
    -- > STEP 7: FINAL EXEMPTION
    -- [[
    -- > 7.1 DTR UPLOAD
    UPDATE `timeprocess` t
           SET t.`late`       =  IF(t.`hrs_actual` < 0, 0, t.`late`),
               t.`undertime`  =  IF(t.`hrs_actual` < 0, 0, t.`undertime`),
               t.`absent`     =  IF(t.`hrs_actual` < 0, 1, t.`absent`),
               t.`hrs_actual` = IF(t.`hrs_actual` < 0, 0, t.`hrs_actual`)
           WHERE t.`hrs_actual` < 0;
    
    UPDATE `timeprocess` t
           SET t.`absent` = 0
           WHERE t.`day_type` = 'REGULAR' AND t.`lwop` > 0;
    
    -- > 7.2 ATTENDANCE BASE
    UPDATE `timeprocess` t, `ww_payroll_partners` pp
           SET t.`late`       =  0,
               t.`undertime`  =  0,
               t.`absent`     =  0,
               t.`hrs_actual` = time_period_process_workhrs(t.`user_id`, t.`date`)
           WHERE (t.`hrs_rendered` > 0 OR t.`absent` = 1) AND
                 t.`lwop` = 0 AND
                 t.`user_id` = pp.`user_id` AND 
                 pp.`attendance_base` = 0 AND
                 pp.`deleted` = 0;
    
    -- > 7.3 NIGHT DIFF
    UPDATE timeprocess t, ww_users u
    SET t.nd = get_ndiff(u.user_id, t.date, u.company_id)
    WHERE u.user_id = t.user_id AND
	  (t.hrs_actual > 0 OR t.ot > 0);
    
    -- > 7.4 UNDER SUSPENSION
    
    -- ]] STEP 7
    
    
    -- STEP 7: INSERT SUMMARY
    -- [[
    INSERT INTO `ww_time_record_summary` (
           `record_id`,
           `user_id`,
           `id_number`,
           `date`,
           `period_id`,
           `payroll_date`,
           `day_type`,
           `hrs_rendered`,
           `hrs_actual`,
           `hrs_break`,
           `absent`,
           `lwp`,
           `lwop`,
           `late`,
           `undertime`,
           `nd`,
           `ot`,
           `ot_break`,
           `meal`,
           `transpo`,
           `resigned`,
           `awol` ,
           `lip_approved_below_13_days`)
    SELECT `record_id`,
           `user_id`,
           `id_number`,
           `date`,
           `period_id`,
           `payroll_date`,
           `day_type`,
           `hrs_rendered`,
           `hrs_actual`,
           `hrs_break`,
           `absent`,
           `lwp`,
           `lwop`,
           `late`,
           `undertime`,
           `nd`,
           `ot`,
           `ot_break`,
           `meal`,
           `transpo`,
           `resigned`,
           `awol`,
           `lip_approved_below_13_days`
    FROM `timeprocess`
    ON DUPLICATE KEY UPDATE 
           `user_id`      = VALUES(`user_id`),
           `date`         = VALUES(`date`),    
           `day_type`     = VALUES(`day_type`),
           `hrs_rendered` = VALUES(`hrs_rendered`),
           `hrs_actual`   = VALUES(`hrs_actual`),
           `hrs_break`    = VALUES(`hrs_break`),
           `absent`       = VALUES(`absent`),
           `lwp`          = VALUES(`lwp`),
           `lwop`         = VALUES(`lwop`),
           `late`         = VALUES(`late`),
           `undertime`    = VALUES(`undertime`),
           `nd` 	  = VALUES(`nd`),
           `ot`           = VALUES(`ot`),
           `ot_break`     = VALUES(`ot_break`),
           `meal`         = VALUES(`meal`),
           `transpo`      = VALUES(`transpo`),
           `resigned`     = VALUES(`resigned`),
           `awol`         = VALUES(`awol`),
           `lip_approved_below_13_days` = values(`lip_approved_below_13_days`),
           `modified_on`  = NOW(); 
    
    -- ]]
    
    -- STEP 8: PROCESS FOR PAYROLL INPUT
    -- [[
    SET @absent_before_holiday = 0;
    SELECT IFNULL(`value`,0) INTO @absent_before_holiday
    FROM `ww_config`
    WHERE `key`='absent_before_holiday' AND `deleted`=0;
    
    IF @absent_before_holiday = 1 THEN
       CALL sp_time_period_validate_holiday( periodid, userid );
    END IF;
    
    
    SET @notlatefile = 0;
    SELECT period_id INTO @notlatefile
    FROM `ww_time_period` WHERE (CURDATE() BETWEEN date_from AND (cutoff + INTERVAL 25 DAY)) AND period_id = periodid;
    
    -- INSERT INTO `logtable` (`log`) VALUES (CONCAT(periodid,' ',@notlatefile));
    
    IF periodid = @notlatefile THEN
       CALL sp_time_period_summary( periodid, userid );
    END IF;
    
    -- CALL `sp_time_period_process_latefile`(periodid, userid);
    
    -- ]]
    /*
    -- this will update ww_time_record_summary project id
	    select date_from, date_to, payroll_date
	    into dtStart, dtEnd, dtPay
	    from ww_time_period where period_id = periodid;
 	    -- set project to default assigned project
	    UPDATE ww_time_record_summary trs
	    left join ww_users_profile up on trs.user_id = up.user_id
	    SET trs.project_id = up.project_id
	    WHERE trs.user_id = userid AND trs.`date` BETWEEN dtStart AND dtEnd AND payroll_date = dtPay;
	    -- this will set the project if it has movement
	    call sp_time_period_set_project(userid, dtStart, dtEnd, dtPay);
    */
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process_2` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process_2` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process_2`(IN periodid INT(11), IN userid INT(11))
BEGIN
    
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE dtStart DATE;
    DECLARE dtEnd DATE;
    DECLARE dtPay DATE;
    
    
    -- STEP 1: CREATE A TEMPORARY TABLE TO HOLD INITIAL SUMMARY
    -- [[
    DROP TEMPORARY TABLE IF EXISTS `timeprocess`;
    CREATE TEMPORARY TABLE `timeprocess` (
           `record_id` INT(11) UNSIGNED NOT NULL DEFAULT '0',
           `user_id` INT(11) NOT NULL DEFAULT '0',
           `id_number` VARCHAR(8) NOT NULL DEFAULT '',
           `date` DATE NOT NULL DEFAULT '0000-00-00',
           `period_id` INT(11) NOT NULL DEFAULT '0',
           `payroll_date` DATE NOT NULL DEFAULT '0000-00-00',
           `shift_id` INT(11) NOT NULL DEFAULT '0',
           `shift` VARCHAR(16) NOT NULL DEFAULT '',
           `timein` DATETIME DEFAULT '0000-00-00 00:00:00',
           `timeout` DATETIME DEFAULT '0000-00-00 00:00:00',
           `day_type` VARCHAR(16) DEFAULT 'REGULAR',
           `hrs_rendered` DECIMAL(5,2) DEFAULT '0.00',
           `hrs_actual` DECIMAL(5,2) DEFAULT '0.00',
           `hrs_break` DECIMAL(5,2) DEFAULT '0.00',
           `absent` TINYINT(1) DEFAULT '0',
           `lwp` DECIMAL(5,2) DEFAULT '0.00',
           `lwop` DECIMAL(5,2) DEFAULT '0.00',
           `late` DECIMAL(5,2) DEFAULT '0.00',
           `undertime` DECIMAL(5,2) DEFAULT '0.00',
           `nd` decimal(5,2) default '0.00',
           `ot` DECIMAL(5,2) DEFAULT '0.00',
           `ot_break` DECIMAL(5,2) DEFAULT '0.00',
           `meal` DECIMAL(5,2) DEFAULT '0.00',
           `transpo` DECIMAL(5,2) DEFAULT '0.00',
           `resigned` TINYINT(1) DEFAULT '0',
           `awol` TINYINT(1) DEFAULT '0',
           `override` TINYINT(1) DEFAULT '0', -- >> (VALUE: 1=not to include, 0=include) field tag to check whether to include in the time record
    PRIMARY KEY (`record_id`,`user_id`,`date`,`payroll_date`),
            KEY `user_id` (`user_id`),
            KEY `date` (`date`),
            KEY `payroll_date` (`payroll_date`)
    ) ENGINE=INNODB DEFAULT CHARSET=utf8;
    -- ]] STEP 1
    
    
        
    -- STEP 2: INSERT TIME RECORDS NET OF ATTENDANCE LOGS
    -- [[
    CALL sp_time_period_process_cws(periodid,userid); -- last minute check on cws
    
    INSERT INTO `timeprocess`
       ( `record_id`, `user_id`, `date`, `period_id`, `payroll_date`, `shift_id`, `shift`, `timein`, `timeout`,
         `hrs_rendered` )
       SELECT 
          tr.`record_id`, tr.`user_id`, tr.`date`, tp.`period_id`, tp.`payroll_date`, 
          IF( IFNULL(tr.`aux_shift_id`, 0) = 0, tr.`shift_id`, IFNULL(tr.`aux_shift_id`, 0) ) `shift_id`,
          IF( IFNULL(tr.`aux_shift_id`, 0) = 0, tr.`shift`, IFNULL(tr.`aux_shift`, 0) ) `shift`,
          IF( IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') = '0000-00-00 00:00:00', 
              IFNULL(tr.`time_in`, '0000-00-00 00:00:00'), 
              IF( IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') > IFNULL(tr.`time_in`, '0000-00-00 00:00:00') AND IFNULL(tr.`time_in`, '0000-00-00 00:00:00') <> '0000-00-00 00:00:00',
                 IFNULL(tr.`time_in`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') 
              )
          ) `timein`,
          IF( IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00') = '0000-00-00 00:00:00', 
              IFNULL(tr.`time_out`, '0000-00-00 00:00:00'), 
              IF( IFNULL(tr.`time_out`, '0000-00-00 00:00:00') > IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`time_out`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00') 
              )
          ) `timeout`,
          
          time_period_process_workhrs(tr.`user_id`, tr.`date`)
          
       FROM 
             `time_record` tr, `ww_time_period` tp, `users_profile` up
       WHERE 
              up.`company_id` = tp.`company_id` AND
              up.`user_id` = tr.`user_id` AND
              tp.period_id = periodid AND
              IF(userid = 0, 1, tr.`user_id` = userid) AND
              tr.`date` BETWEEN tp.date_from AND IF(tp.date_to > DATE(NOW()), DATE(NOW()), tp.date_to);
    -- ]] STEP 2
    
    
    
    -- STEP 3: SET RESTDAY, ABSENT, LWOP, LEAVE, etc... (AWOL is executed outside this script)
    -- [[
    -- > 3.1 RESTDAY
    UPDATE `timeprocess` t, `time_shift` ts 
           SET t.`day_type` = UPPER(ts.`shift`), 
               t.`hrs_rendered` = 0
           WHERE t.`shift_id` = ts.`shift_id` AND 
                 UPPER(ts.`shift`) IN ('OFF','RESTDAY');
    
    
    -- > 3.2 HOLIDAY / LEGAL / SPECIAL 
    UPDATE `timeprocess` t
    INNER JOIN `ww_time_holiday` th ON th.deleted = 0
    LEFT JOIN `ww_time_holiday_location` thl ON thl.deleted = 0 AND thl.`holiday_id` = th.`holiday_id` AND thl.`user_id` = t.`user_id`
    
           SET t.`day_type` = IF( th.`legal` = 1, 
                                  -- TRUE: IF(t.`day_type`='RESTDAY', 'RDHOL', 'LEGAL'),
                                  'LEGAL',
                                  -- FALSE:
                                  IF( IFNULL(th.`location_count`,0) = 0,
                                      -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                      'SPECIAL',
                                      -- FALSE:
                                      IF( thl.`user_id` = t.`user_id`,
                                          -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                          'SPECIAL',
                                          -- FALSE:
                                          t.`day_type`
                                      )
                                  )
                              )
           WHERE t.`date` = th.`holiday_date` AND t.`day_type` = 'REGULAR';
    
    
    -- > 3.3 ABSENT
    UPDATE `timeprocess` t
           SET t.`absent` = 1, t.`hrs_rendered` = 0
           WHERE `day_type` = 'REGULAR' AND 
                 (`timein` = '0000-00-00 00:00:00' OR `timeout` = '0000-00-00 00:00:00');
    
    
    -- > 3.4 LEAVE WITH PAY /AND/ LEAVE WITHOUT PAY
    SET @lwop = 0;
    SELECT GROUP_CONCAT(`form_id`) INTO @lwop FROM `ww_time_form` WHERE `form_code`='LWOP' OR `form_code`='FLV' LIMIT 1;
    
    UPDATE `timeprocess` t
           SET t.`lwop` = time_period_process_lwop(t.`user_id`,t.`date`,@lwop),
               t.`lwp` = time_period_process_lwp(t.`user_id`,t.`date`,@lwop),
               t.`hrs_break` = time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') / 60               
           WHERE t.`day_type` = 'REGULAR';
    -- ]] STEP 3    
    
    
    
    -- STEP 4: SET LATE AND UNDERTIME
    -- [[
    -- > 4.1 LATE (Converted to HOUR): limited to regular schedule only and its assigned schedule including all applications
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF(t.`absent` = 1, 
                             -- TRUE: assigned no lates since it is already absent
                             0,
                             -- FALSE: get minutes considering grace period
                             IF( (TIMESTAMPDIFF(MINUTE, 
                                                (CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_start`) + INTERVAL 
                                                (time_period_process_shift_department('GRACE-PERIOD-IN-MINUTES','EMPLOYMENT-TYPE', 
                                                    u.company_id, t.`shift_id`, t.`user_id`, '0')) MINUTE),
                                  t.`timein` )*1) <= 0,
                                  -- TRUE: assigned no lates
                                  0,
                                  -- FALSE: get minutes lates disregarding grace period
                                  TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_start`), t.`timein`) / 60
                             )
                          )
           WHERE t.`day_type` = 'REGULAR' AND 
		 t.`shift_id` = ts.`shift_id` and
		 t.user_id = u.user_id;
           
    -- > 4.1.1 EXEMPTIONS ON SPECIAL PARTNERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      u.company_id, t.`shift_id`, t.`user_id`, '00:00:00') <> '00:00:00',
                            -- TRUE: special condition normally on managers (e.g. flexi until 10am)
                            IF( TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')), t.`timein`) > 0,
                                -- TRUE:
                                TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')), t.`timein`) / 60,
                                -- FALSE:
                                0
                            ),
                            -- FALSE: no changes on the value
                            t.`late`
                        )
           WHERE t.`late` > 0 AND 
		 t.`shift_id` = ts.`shift_id` and
		 t.user_id = u.user_id;           
    
    -- > 4.1.2 EXEMPTIONS ON MANAGERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      u.company_id, t.`shift_id`, t.`user_id`,'00:00:00') <> '00:00:00',
                            -- TRUE: special condition normally on managers (e.g. flexi until 10am)
                            IF( TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      u.company_id, t.`shift_id`, t.`user_id`,'00:00:00')), t.`timein`) > 0,
                                -- TRUE:
                                TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      u.company_id, t.`shift_id`, t.`user_id`,'00:00:00')), t.`timein`) / 60,
                                -- FALSE:
                                0
                            ),
                            -- FALSE: no changes on the value
                            t.`late`
                        )
           WHERE t.`late` > 0 AND 
		 t.`shift_id` = ts.`shift_id` and
		 t.user_id = u.user_id;           
    
    
    -- > 4.1.3 EXEMPTIONS ON EXCUSED TARDINESS
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`late` = 0
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'ET' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    
    
    -- > 4.2 UNDERTIME (Converted to HOUR)
    -- >
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`undertime` = IF(t.`absent` = 1, 
                           -- TRUE: assigned no undertime since it is already absent
                           0,
                           -- FALSE: get minutes interval
                           IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`) ) <= 0,
                               -- TRUE: assigned no lates
                               0,
                               -- FALSE: get minutes interval
                               IF( TIME(time_period_process_shift('FIRST-HALF-END','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '00:00:00')) = TIME(t.`timeout`),
                                  -- TRUE: less break
                                  (TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`)) / 60) - t.`hrs_break`,
                                  -- FALSE: 
                                  TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`)) / 60
                               )
                           )
                        )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 -- t.`lwp` = 0 AND 
                 -- t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id`;
    
     
    -- > 4.2.1 EXEMPTIONS ON SPECIAL PARTNERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u 
           SET t.`undertime` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                             u.company_id, t.`shift_id`, t.`user_id`, '00:00:00') <> '00:00:00',
                               
                                   IF( t.`timein` <= CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', 
                                                            time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                             u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')),
                                
                                       -- TRUE: special condition on special partner (e.g. flexi until 10am)
                                       IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL t.`hrs_break` HOUR
                                                                 ) ) > 0,
                                           TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL t.`hrs_break` HOUR
                                                                 ) ) / 60,
                                           -- FALSE: no changes on the value
                                           0
                                       ),
                                       0
                                   ),
                                   -- FALSE: no changes on the value
                                   t.`undertime`
                               )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id` and
                 t.user_id = u.user_id;
    
    
    -- > 4.2.2 EXEMPTIONS ON MANAGERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`undertime` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                             u.company_id, t.`user_id`, t.`shift_id`,'00:00:00') <> '00:00:00',
                               
                                   IF( t.`timein` <= CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', 
                                                            time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                             u.company_id, t.`user_id`, t.`shift_id`,'00:00:00')),
                                
                                       -- TRUE: special condition on special partner (e.g. flexi until 10am)
                                       IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') MINUTE
                                                                 ) ) > 0,
                                           TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') MINUTE
                                                                 ) ) / 60,
                                           -- FALSE: no changes on the value
                                           0
                                       ),
                                       0
                                   ),
                                   -- FALSE: no changes on the value
                                   t.`undertime`
                               )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id` and 
                 t.user_id = u.user_id;
    
    
    -- > 4.2.3 EXEMPTIONS ON EXCUSED UNDERTIME
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`undertime` = 0
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'UT' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    
    
    -- > 4.2.4 EXEMPTIONS ON EMERGENCY LEAVE
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`late` = 0, 
               t.`undertime` = 0, 
               t.`absent` = 0,
               t.`hrs_rendered` = IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0)
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'EL' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    -- ]] STEP 4
    
    
    -- (classcode VARCHAR(32), classgroup VARCHAR(32), comp_id INT(11), shiftid INT(11), userid INT(11), optreturn VARCHAR(32))
    -- STEP 5: COMPLETING RENDERED HOURS... FINAL CHECK
    -- [[
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                              u.company_id, t.`shift_id`, t.`user_id`, '00:00:00') <> '00:00:00'
                                    ,
                                    -- TRUE                                    
                                    IF( TIME(t.`timein`) > TIME(time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                              u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')),
                                        -- TRUE
                                        IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) / 2,
                                        -- FALSE
                                        t.`late`
                                    )
                                    ,
                                    -- FALSE
                                    t.`late`
                                )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id` and
                 t.user_id = u.user_id;
    /*             
    UPDATE `timeprocess` t
           SET t.`absent` = 0, t.`hrs_rendered` = IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) * IF(t.`lwp` * 8 IN (4,6), .5, 1)
           WHERE t.`lwp` > 0 AND t.absent = 1;
    
    UPDATE `timeprocess` t
           SET t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime` - (IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) * IF(t.`lwop` * 8 IN (4,6), .5, IF(t.`lwop`=0, 0,1) ))
           WHERE t.`day_type` = 'REGULAR';
    
    UPDATE `timeprocess` t
           SET t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime` - (IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) * IF(t.`lwop` * 8 IN (4,6), .5, IF(t.`lwop`=0, 0,1) ))
           WHERE t.`day_type` IN ('SPECIAL','LEGAL');
    */
    -- ]] STEP 5
    
    
    
    -- STEP 6: RESIGNED TAGGING / COMPUTE OVERTIME
    -- [[
    -- > 6.1 RESIGNED
    UPDATE `timeprocess` t
           SET t.`resigned` = time_period_process_resigned(t.`user_id`, t.`date`);
    
    -- > 6.2 OVERTIME
    CALL sp_time_period_process_summary_ot(periodid, userid);
    
    -- > 6.2.1 OVERTIME BREAK
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_break` tdtb ON tdtb.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_break` tdb ON tdb.`deleted` = 0 AND tdb.`break_id` = tdtb.`break_id`
    JOIN `ww_time_day_break_range` tdbr ON tdbr.`break_id` = tdb.`break_id`
    join `ww_users` u on u.user_id = t.user_id and u.company_id = tdbr.company_id
           SET t.`ot_break` = IFNULL(tdbr.`deduction`, 0)
           WHERE t.`ot` > 0 AND (t.`ot` BETWEEN tdbr.`hour_from` AND tdbr.`hour_to`);
    
    -- > 6.2.2 MEAL ALLOWANCE
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_allowance` tdta ON tdta.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_meal` tdm ON tdm.`deleted` = 0 AND tdm.`meal_id` = tdta.`meal_id`
    JOIN `ww_time_day_meal_range` tdmr ON tdmr.`meal_id` = tdm.`meal_id`
    JOIN `partners` p ON p.`user_id` = t.`user_id`
    JOIN `ww_time_day_allowance` tda ON tda.`employment_type_id` = p.`employment_type_id`
           SET t.`meal` = IFNULL(tdmr.`multiplier`, 0) * IFNULL(tda.`meal`, 0)
           WHERE t.`ot` > 0 AND ((t.`ot` - t.`ot_break`) BETWEEN tdmr.`hour_from` AND tdmr.`hour_to`);
    
    -- > 6.2.3 TRANSPO ALLOWANCE
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_allowance` tdta ON tdta.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_transpo` tdm ON tdm.`deleted` = 0 AND tdm.`transpo_id` = tdta.`transpo_id`
    JOIN `ww_time_day_transpo_range` tdmr ON tdmr.`transpo_id` = tdm.`transpo_id`
    JOIN `partners` p ON p.`user_id` = t.`user_id`
    JOIN `ww_time_day_allowance` tda ON tda.`employment_type_id` = p.`employment_type_id`
           SET t.`transpo` = IFNULL(tdmr.`multiplier`, 0) * IFNULL(tda.`transpo`, 0)
           WHERE t.`ot` > 0 AND ((t.`ot` - t.`ot_break`) BETWEEN tdmr.`hour_from` AND tdmr.`hour_to`);
    
    -- > 6.2.4 EXEMPTION ON ABSENT TAGGING ON CURRENT DATE
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`absent` = IF(NOW() < CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`), 0, t.`absent`)
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`date` = CURDATE() AND
                 t.`absent` = 1 AND
                 t.`shift_id` = ts.`shift_id`;
    
    -- > 6.2.5 MOVE LATE TO UNDERTIME
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd
           SET t.`undertime` = IF(IFNULL(t.`late`,0) > 0, IFNULL(t.`undertime`,0)+t.`late`, t.`undertime`),
               t.`late` = IF(t.`late` > 0, 0, t.`late`)
           WHERE tf.`user_id` = t.`user_id` AND 
                 tf.`form_code` = 'UT' AND 
                 tf.`form_status_id` = 6 AND 
                 tf.`forms_id` =  tfd.`forms_id` AND 
                 tfd.`duration_id` IN (1,2) AND
                 tfd.`date` =  t.`date`;
   -- ]] STEP 6
    
    
    -- > STEP 7: FINAL EXEMPTION
    -- [[
    -- > 7.1 DTR UPLOAD
    /*
    UPDATE `timeprocess` t
           SET t.`late`       =  IF(t.`hrs_actual` < 0, 0, t.`late`),
               t.`undertime`  =  IF(t.`hrs_actual` < 0, 0, t.`undertime`),
               t.`absent`     =  IF(t.`hrs_actual` < 0, 1, t.`absent`),
               t.`hrs_actual` = IF(t.`hrs_actual` < 0, 0, t.`hrs_actual`)
           WHERE t.`hrs_actual` < 0;
    */
    -- > 7.2 ATTENDANCE BASE
    UPDATE `timeprocess` t, `ww_payroll_partners` pp
           SET t.`late`       =  0,
               t.`undertime`  =  0,
               t.`absent`     =  0,
               t.`hrs_actual` = time_period_process_workhrs(t.`user_id`, t.`date`)
           WHERE (t.`hrs_rendered` > 0 OR t.`absent` = 1) AND
                 t.`user_id` = pp.`user_id` AND 
                 pp.`attendance_base` = 0 AND
                 pp.`deleted` = 0;
    
    -- > 7.3 NIGHT DIFF
    UPDATE timeprocess t, ww_users u
    SET t.nd = get_ndiff(u.user_id, t.date, u.company_id)
    WHERE u.user_id = t.user_id AND
	  (t.hrs_actual > 0 OR t.ot > 0);
    
    -- > 7.4 UNDER SUSPENSION
    
    -- ]] STEP 7
    
    
    -- STEP 7: INSERT SUMMARY
    -- [[
    INSERT INTO `ww_time_record_summary` (
           `record_id`,
           `user_id`,
           `id_number`,
           `date`,
           `period_id`,
           `payroll_date`,
           `day_type`,
           `hrs_rendered`,
           `hrs_actual`,
           `hrs_break`,
           `absent`,
           `lwp`,
           `lwop`,
           `late`,
           `undertime`,
           `nd`,
           `ot`,
           `ot_break`,
           `meal`,
           `transpo`,
           `resigned`,
           `awol` )
    SELECT `record_id`,
           `user_id`,
           `id_number`,
           `date`,
           `period_id`,
           `payroll_date`,
           `day_type`,
           `hrs_rendered`,
           `hrs_actual`,
           `hrs_break`,
           `absent`,
           `lwp`,
           `lwop`,
           `late`,
           `undertime`,
           `nd`,
           `ot`,
           `ot_break`,
           `meal`,
           `transpo`,
           `resigned`,
           `awol`
    FROM `timeprocess`
    ON DUPLICATE KEY UPDATE 
           `day_type`     = VALUES(`day_type`),
           `hrs_rendered` = VALUES(`hrs_rendered`),
           `hrs_actual`   = VALUES(`hrs_actual`),
           `hrs_break`    = VALUES(`hrs_break`),
           `absent`       = VALUES(`absent`),
           `lwp`          = VALUES(`lwp`),
           `lwop`         = VALUES(`lwop`),
           `late`         = VALUES(`late`),
           `undertime`    = VALUES(`undertime`),
           `nd` 	  = values(`nd`),
           `ot`           = VALUES(`ot`),
           `ot_break`     = VALUES(`ot_break`),
           `meal`         = VALUES(`meal`),
           `transpo`      = VALUES(`transpo`),
           `resigned`     = VALUES(`resigned`),
           `awol`         = VALUES(`awol`),
           `modified_on`  = NOW();
    -- ]]
    
    
    
    -- STEP 8: PROCESS FOR PAYROLL INPUT
    -- [[
    SET @absent_before_holiday = 0;
    SELECT IFNULL(`value`,0) INTO @absent_before_holiday
    FROM `ww_config`
    WHERE `key`='absent_before_holiday' AND `deleted`=0;
    
    IF @absent_before_holiday = 1 THEN
       CALL sp_time_period_validate_holiday( periodid, userid );
    END IF;
    
    
    SET @notlatefile = 0;
    SELECT period_id INTO @notlatefile
    FROM `ww_time_period` WHERE (CURDATE() BETWEEN date_from AND (cutoff + INTERVAL 10 DAY)) AND period_id = periodid;
    
    -- INSERT INTO `logtable` (`log`) VALUES (CONCAT(periodid,' ',@notlatefile));
    
    IF periodid = @notlatefile THEN
       CALL sp_time_period_summary( periodid, userid );
    END IF;
    
    -- ]]
    /*
    -- this will update ww_time_record_summary project id
	    select date_from, date_to, payroll_date
	    into dtStart, dtEnd, dtPay
	    from ww_time_period where period_id = periodid;
 	    -- set project to default assigned project
	    UPDATE ww_time_record_summary trs
	    left join ww_users_profile up on trs.user_id = up.user_id
	    SET trs.project_id = up.project_id
	    WHERE trs.user_id = userid AND trs.`date` BETWEEN dtStart AND dtEnd AND payroll_date = dtPay;
	    -- this will set the project if it has movement
	    call sp_time_period_set_project(userid, dtStart, dtEnd, dtPay);
    */
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process_all` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process_all` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process_all`()
BEGIN
    DECLARE pdone TINYINT(11) DEFAULT 0;
    DECLARE prec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE periodid INT;
    DECLARE companyid INT;
    DECLARE datefrom DATE;
    DECLARE dateto DATE;
    DECLARE cutoff DATE; 
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE periods CURSOR FOR
       SELECT tp.`period_id`, tp.`company_id`, tp.`date_from`, tp.`date_to`, tp.`cutoff`
       FROM `ww_time_period` tp
       WHERE tp.`closed`=0 AND tp.`deleted`=0 AND 
             CURDATE() BETWEEN tp.`date_from` AND IF(tp.`cutoff` > tp.`date_to`, tp.`cutoff`, tp.`date_to`);
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET pdone = 1;
 
 
    -- START TRANSACTION;
        
    OPEN periods;
    
    REPEAT
       FETCH periods INTO periodid, companyid, datefrom, dateto, cutoff;
       
       IF NOT pdone THEN
           SET prec = prec + 1;
           
           -- execute processing
           -- version 1.0: CALL `sp_time_period_process`(periodid, 0);
           -- version 1.1: CALL `sp_time_period_process_summary`(periodid, 0);
            
           IF (CURDATE() BETWEEN (dateto + INTERVAL 1 DAY) AND cutoff) THEN
              CALL `sp_time_period_process_latefile`(periodid, 0);
           END IF;
           
           SET @rec = 1; -- 0;
           /*
           SELECT COUNT(tr.`user_id`) INTO @rec
           FROM `users_profile` up, `time_record` tr 
           WHERE tr.`user_id`=up.`user_id` AND up.`company_id`=companyid AND
                 (tr.`created_on` >= (NOW()- INTERVAL 1 HOUR) OR tr.`modified_on` >= (NOW()- INTERVAL 1 HOUR));
           */
           IF @rec > 0 THEN
              -- [1]
              CALL `sp_time_period_process`(periodid, 0);
              
              -- [2] update period header
              UPDATE `ww_time_period` SET `last_processed`=NOW(), `processed`=IFNULL(`processed`,0)+1
              WHERE `period_id`=periodid;
              
              -- [3] re-update time-records, initialize first: 2016-04-22
              /*
              UPDATE `ww_time_record` tr
              SET tr.time_in=NULL,tr.time_out=NULL
              WHERE tr.`aux_shift_id`<>0 AND tr.override=0 
                AND tr.`date` BETWEEN datefrom AND dateto 
                AND tr.`user_id` IN (SELECT `user_id` FROM `users_profile` WHERE `company_id`=companyid);
              */
              
              -- [4] re-update time-records, updating of raw: 2016-04-22
              /*
              UPDATE `ww_time_record_raw` trr
              SET trr.`processed`=0
              WHERE trr.`date` BETWEEN datefrom AND dateto 
                AND trr.`user_id` IN (SELECT `user_id` FROM `users_profile` WHERE `company_id`=companyid);
              */
           END IF;
       END IF;
       
    UNTIL pdone END REPEAT;
    
    CLOSE periods;
    
    -- COMMIT;
    
    SELECT prec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process_checking` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process_checking` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process_checking`(IN periodid INT(11), IN userid INT(11))
BEGIN
    
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE dtStart DATE;
    DECLARE dtEnd DATE;
    DECLARE dtPay DATE;
    
    
    -- STEP 1: CREATE A TEMPORARY TABLE TO HOLD INITIAL SUMMARY
    -- [[
    DROP TEMPORARY TABLE IF EXISTS `timeprocess`;
    CREATE TEMPORARY TABLE `timeprocess` (
           `record_id` INT(11) UNSIGNED NOT NULL DEFAULT '0',
           `user_id` INT(11) NOT NULL DEFAULT '0',
           `id_number` VARCHAR(8) NOT NULL DEFAULT '',
           `date` DATE NOT NULL DEFAULT '0000-00-00',
           `period_id` INT(11) NOT NULL DEFAULT '0',
           `payroll_date` DATE NOT NULL DEFAULT '0000-00-00',
           `shift_id` INT(11) NOT NULL DEFAULT '0',
           `shift` VARCHAR(16) NOT NULL DEFAULT '',
           `timein` DATETIME DEFAULT '0000-00-00 00:00:00',
           `timeout` DATETIME DEFAULT '0000-00-00 00:00:00',
           `day_type` VARCHAR(16) DEFAULT 'REGULAR',
           `hrs_rendered` DECIMAL(5,2) DEFAULT '0.00',
           `hrs_actual` DECIMAL(5,2) DEFAULT '0.00',
           `hrs_break` DECIMAL(5,2) DEFAULT '0.00',
           `absent` TINYINT(1) DEFAULT '0',
           `lwp` DECIMAL(5,2) DEFAULT '0.00',
           `lwop` DECIMAL(5,2) DEFAULT '0.00',
           `late` DECIMAL(5,2) DEFAULT '0.00',
           `undertime` DECIMAL(5,2) DEFAULT '0.00',
           `nd` decimal(5,2) default '0.00',
           `ot` DECIMAL(5,2) DEFAULT '0.00',
           `ot_break` DECIMAL(5,2) DEFAULT '0.00',
           `meal` DECIMAL(5,2) DEFAULT '0.00',
           `transpo` DECIMAL(5,2) DEFAULT '0.00',
           `resigned` TINYINT(1) DEFAULT '0',
           `awol` TINYINT(1) DEFAULT '0',
           `override` TINYINT(1) DEFAULT '0', -- >> (VALUE: 1=not to include, 0=include) field tag to check whether to include in the time record
    PRIMARY KEY (`record_id`,`user_id`,`date`,`payroll_date`),
            KEY `user_id` (`user_id`),
            KEY `date` (`date`),
            KEY `payroll_date` (`payroll_date`)
    ) ENGINE=INNODB DEFAULT CHARSET=utf8;
    -- ]] STEP 1
    
    
        
    -- STEP 2: INSERT TIME RECORDS NET OF ATTENDANCE LOGS
    -- [[
    CALL sp_time_period_process_cws(periodid,userid); -- last minute check on cws
    
    INSERT INTO `timeprocess`
       ( `record_id`, `user_id`, `date`, `period_id`, `payroll_date`, `shift_id`, `shift`, `timein`, `timeout`,
         `hrs_rendered` )
       SELECT 
          tr.`record_id`, tr.`user_id`, tr.`date`, tp.`period_id`, tp.`payroll_date`, 
          IF( IFNULL(tr.`aux_shift_id`, 0) = 0, tr.`shift_id`, IFNULL(tr.`aux_shift_id`, 0) ) `shift_id`,
          IF( IFNULL(tr.`aux_shift_id`, 0) = 0, tr.`shift`, IFNULL(tr.`aux_shift`, 0) ) `shift`,
          IF( IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') = '0000-00-00 00:00:00', 
              IFNULL(tr.`time_in`, '0000-00-00 00:00:00'), 
              IF( IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') > IFNULL(tr.`time_in`, '0000-00-00 00:00:00') AND IFNULL(tr.`time_in`, '0000-00-00 00:00:00') <> '0000-00-00 00:00:00',
                 IFNULL(tr.`time_in`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') 
              )
          ) `timein`,
          IF( IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00') = '0000-00-00 00:00:00', 
              IFNULL(tr.`time_out`, '0000-00-00 00:00:00'), 
              IF( IFNULL(tr.`time_out`, '0000-00-00 00:00:00') > IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`time_out`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00') 
              )
          ) `timeout`,
          
          time_period_process_workhrs(tr.`user_id`, tr.`date`)
       /*
       FROM  `time_record` tr, `ww_time_period` tp, `users_profile` up
       WHERE  up.`company_id` = tp.`company_id` AND
              up.`user_id` = tr.`user_id` AND
              tp.period_id = periodid AND
              IF(userid = 0, 1, tr.`user_id` = userid) AND
              tr.`date` BETWEEN tp.date_from AND IF(tp.date_to > DATE(NOW()), DATE(NOW()), tp.date_to); */
       FROM `ww_time_record` tr
       JOIN `ww_users_profile` up ON up.`user_id` = tr.`user_id`
       JOIN `ww_time_period` tp ON up.`company_id` = tp.`company_id`
       LEFT JOIN `ww_time_period_apply_to_id` tpati ON tpati.`period_id` = tp.`period_id`
       JOIN `ww_partners` p ON p.`user_id` = tr.`user_id`
       WHERE 
              tp.period_id = periodid AND
              tr.user_id > 0 AND
              IF(userid = 0, 1, tr.`user_id` = userid) AND
              tr.`date` BETWEEN tp.date_from AND IF(tp.date_to > DATE(NOW()), DATE(NOW()), tp.date_to) 
              AND
              IF(tp.`apply_to_id` = 0, 1, 
                 IF(tp.`apply_to_id` = 1, tpati.`apply_to_id` = tr.`user_id`, 
                    IF(tp.`apply_to_id` = 2, tpati.`apply_to_id` = p.`status_id`, 
                       IF(tp.`apply_to_id` = 3, tpati.`apply_to_id` = up.`division_id`, 
                          IF(tp.`apply_to_id` = 4, tpati.`apply_to_id` = up.`department_id`, 1))))) ;
    -- ]] STEP 2
    
    -- STEP 3: SET RESTDAY, ABSENT, LWOP, LEAVE, etc... (AWOL is executed outside this script)
    -- [[
    -- > 3.1 RESTDAY
    UPDATE `timeprocess` t, `time_shift` ts 
           SET t.`day_type` = UPPER(ts.`shift`), 
               t.`hrs_rendered` = 0
           WHERE t.`shift_id` = ts.`shift_id` AND 
                 UPPER(ts.`shift`) IN ('OFF','RESTDAY');
                     
      -- > 3.2 HOLIDAY / LEGAL / SPECIAL 
    UPDATE `timeprocess` t
    INNER JOIN `ww_time_holiday` th ON th.deleted = 0
    LEFT JOIN `ww_time_holiday_location` thl ON thl.deleted = 0 AND thl.`holiday_id` = th.`holiday_id` AND thl.`user_id` = t.`user_id`
    
           SET t.`day_type` = IF( th.`legal` = 1, 
                                  -- TRUE: IF(t.`day_type`='RESTDAY', 'RDHOL', 'LEGAL'),
                                  'LEGAL',
                                  -- FALSE:
                                  IF( IFNULL(th.`location_count`,0) = 0,
                                      -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                      'SPECIAL',
                                      -- FALSE:
                                      IF( thl.`user_id` = t.`user_id`,
                                          -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                          'SPECIAL',
                                          -- FALSE:
                                          t.`day_type`
                                      )
                                  )
                              )
           WHERE t.`date` = th.`holiday_date`; -- AND th.legal = 1;  -- AND t.`day_type` = 'REGULAR'; -- remove temporary since legal rest day does not compute 02/15/2019
           
    -- > 3.2 HOLIDAY / LEGAL / SPECIAL 
    UPDATE `timeprocess` t
    INNER JOIN `ww_time_holiday` th ON th.deleted = 0
    LEFT JOIN `ww_time_holiday_location` thl ON thl.deleted = 0 AND thl.`holiday_id` = th.`holiday_id` AND thl.`user_id` = t.`user_id`
    
           SET t.`day_type` = IF( th.`legal` = 1, 
                                  -- TRUE: IF(t.`day_type`='RESTDAY', 'RDHOL', 'LEGAL'),
                                  'LEGAL',
                                  -- FALSE:
                                  IF( IFNULL(th.`location_count`,0) = 0,
                                      -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                      'SPECIAL',
                                      -- FALSE:
                                      IF( thl.`user_id` = t.`user_id`,
                                          -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                          'SPECIAL',
                                          -- FALSE:
                                          t.`day_type`
                                      )
                                  )
                              )
           WHERE t.`date` = th.`holiday_date`; -- AND th.legal = 0  AND t.`day_type` = 'REGULAR';
           
    SELECT date_from,cutoff INTO @period_date_from,@period_cutoff
    FROM `ww_time_period` WHERE period_id = periodid;
        
    /*UPDATE `timeprocess` t
           SET t.`timein` = if(time_period_process_absent_w_in_cutoff(t.`user_id`,t.`date`,@period_date_from,@period_cutoff) = 0,t.`timein`,'0000-00-00 00:00:00'),
               t.`timeout` = IF(time_period_process_absent_w_in_cutoff(t.`user_id`,t.`date`,@period_date_from,@period_cutoff) = 0,t.`timeout`,'0000-00-00 00:00:00')
           WHERE t.`day_type` = 'REGULAR'; */    
    
    -- > 3.3 ABSENT
    UPDATE `timeprocess` t
           SET t.`absent` = 1, t.`hrs_rendered` = 0
           WHERE `day_type` = 'REGULAR' AND 
                 (`timein` = '0000-00-00 00:00:00' OR `timeout` = '0000-00-00 00:00:00');
    
    -- > 3.4 LEAVE WITH PAY /AND/ LEAVE WITHOUT PAY
    SET @lwop = 0;
    SELECT GROUP_CONCAT(`form_id`) INTO @lwop FROM `ww_time_form` WHERE `form_code`='LWOP' OR `form_code`='FLV' LIMIT 1;
    
    UPDATE `timeprocess` t
           SET t.`lwop` = time_period_process_lwop(t.`user_id`,t.`date`,@lwop,@period_cutoff,@period_date_from),
               t.`lwp` = time_period_process_lwp(t.`user_id`,t.`date`,@lwop,@period_cutoff),
               t.`hrs_break` = time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') / 60               
           WHERE t.`day_type` = 'REGULAR';
    -- ]] STEP 3    
    
    
    
    -- STEP 4: SET LATE AND UNDERTIME
    -- [[
    -- > 4.1 LATE (Converted to HOUR): limited to regular schedule only and its assigned schedule including all applications
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF(t.`absent` = 1, 
                             -- TRUE: assigned no lates since it is already absent
                             0,
                             -- FALSE: get minutes considering grace period
                             IF( (TIMESTAMPDIFF(MINUTE, 
                                                (CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_start`) + INTERVAL 
                                                (time_period_process_shift_department('GRACE-PERIOD-IN-MINUTES','EMPLOYMENT-TYPE', 
                                                    u.company_id, t.`shift_id`, t.`user_id`, '0')) MINUTE),
                                  t.`timein` )*1) <= 0,
                                  -- TRUE: assigned no lates
                                  0,
                                  -- FALSE: get minutes lates disregarding grace period
                                  TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_start`), t.`timein`) / 60
                             )
                          )
           WHERE t.`day_type` = 'REGULAR' AND 
		 t.`shift_id` = ts.`shift_id` and
		 t.user_id = u.user_id;
		 
    -- 4.1 LATE (Converted to HOUR): limited to regular schedule only and its assigned schedule including all applications
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF(time_period_process_ut(t.`user_id`,t.`date`,ts.`time_start`,ts.`time_end`) > 0, 
                             -- TRUE: assigned no lates since it is already undertime
                             0,
                             -- FALSE: no changes on the value
                             t.`late`
                          )
           WHERE t.`day_type` = 'REGULAR' AND 
		 t.`shift_id` = ts.`shift_id` AND
		 t.user_id = u.user_id;
		            
    -- > 4.1.1 EXEMPTIONS ON SPECIAL PARTNERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      u.company_id, t.`shift_id`, t.`user_id`, '00:00:00') <> '00:00:00',
                            -- TRUE: special condition normally on managers (e.g. flexi until 10am)
                            IF( TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')), t.`timein`) > 0,
                                -- TRUE:
                                TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')), t.`timein`) / 60,
                                -- FALSE:
                                0
                            ),
                            -- FALSE: no changes on the value
                            t.`late`
                        )
           WHERE t.`late` > 0 AND 
		 t.`shift_id` = ts.`shift_id` and
		 t.user_id = u.user_id;           
    
    -- > 4.1.2 EXEMPTIONS ON MANAGERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      u.company_id, t.`shift_id`, t.`user_id`,'00:00:00') <> '00:00:00',
                            -- TRUE: special condition normally on managers (e.g. flexi until 10am)
                            IF( TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      u.company_id, t.`shift_id`, t.`user_id`,'00:00:00')), t.`timein`) > 0,
                                -- TRUE:
                                TIMESTAMPDIFF(MINUTE, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      u.company_id, t.`shift_id`, t.`user_id`,'00:00:00')), t.`timein`) / 60,
                                -- FALSE:
                                0
                            ),
                            -- FALSE: no changes on the value
                            t.`late`
                        )
           WHERE t.`late` > 0 AND 
		 t.`shift_id` = ts.`shift_id` and
		 t.user_id = u.user_id;           
    
    
    -- > 4.1.3 EXEMPTIONS ON EXCUSED TARDINESS
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`late` = 0
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'ET' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    
    
    -- > 4.2 UNDERTIME (Converted to HOUR)
    -- >
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`undertime` = IF(t.`absent` = 1, 
                           -- TRUE: assigned no undertime since it is already absent
                           0,
                           -- FALSE: get minutes interval
                           IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`) ) <= 0,
                               -- TRUE: assigned no lates
                               0,
                               -- FALSE: get minutes interval
                               IF( TIME(time_period_process_shift('FIRST-HALF-END','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '00:00:00')) = TIME(t.`timeout`),
                                  -- TRUE: less break
                                  (TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`)) / 60) - t.`hrs_break`,
                                  -- FALSE: 
                                  TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`)) / 60
                               )
                           )
                        )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 -- t.`lwp` = 0 AND 
                 -- t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id`;
    
    -- > 4.2.1 UNDERTIME (Converted to HOUR)
    -- >
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`undertime` = IF(t.`absent` = 1, 
                           -- TRUE: assigned no undertime since it is already absent
                           0,
                           -- FALSE: get undertime am
                           if(time_period_process_ut_checking(t.`user_id`,t.`date`) > 0,
				   time_period_process_ut(t.`user_id`,t.`date`,ts.`time_start`,ts.`time_end`),
				   IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`) ) <= 0,
				       -- TRUE: assigned no lates
				       0,
				       -- FALSE: get minutes interval
				       IF( TIME(time_period_process_shift('FIRST-HALF-END','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '00:00:00')) = TIME(t.`timeout`),
					  -- TRUE: less break
					  (TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`)) / 60) - t.`hrs_break`,
					  -- FALSE: 
					  TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`)) / 60
				       )
				   )
		           )
                        )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`shift_id` = ts.`shift_id`;
                      
    -- > 4.2.1 EXEMPTIONS ON SPECIAL PARTNERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u 
           SET t.`undertime` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                             u.company_id, t.`shift_id`, t.`user_id`, '00:00:00') <> '00:00:00',
                               
                                   IF( t.`timein` <= CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', 
                                                            time_period_process_shift_department('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                             u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')),
                                
                                       -- TRUE: special condition on special partner (e.g. flexi until 10am)
                                       IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL t.`hrs_break` HOUR
                                                                 ) ) > 0,
                                           TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL t.`hrs_break` HOUR
                                                                 ) ) / 60,
                                           -- FALSE: no changes on the value
                                           0
                                       ),
                                       0
                                   ),
                                   -- FALSE: no changes on the value
                                   t.`undertime`
                               )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id` and
                 t.user_id = u.user_id;
    
    
    -- > 4.2.2 EXEMPTIONS ON MANAGERS
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`undertime` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                             u.company_id, t.`user_id`, t.`shift_id`,'00:00:00') <> '00:00:00',
                               
                                   IF( t.`timein` <= CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ', 
                                                            time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                             u.company_id, t.`user_id`, t.`shift_id`,'00:00:00')),
                                
                                       -- TRUE: special condition on special partner (e.g. flexi until 10am)
                                       IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') MINUTE
                                                                 ) ) > 0,
                                           TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') MINUTE
                                                                 ) ) / 60,
                                           -- FALSE: no changes on the value
                                           0
                                       ),
                                       0
                                   ),
                                   -- FALSE: no changes on the value
                                   t.`undertime`
                               )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id` and 
                 t.user_id = u.user_id;
    
    
    -- > 4.2.3 EXEMPTIONS ON EXCUSED UNDERTIME
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`undertime` = 0
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'UT' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    
    
    -- > 4.2.4 EXEMPTIONS ON EMERGENCY LEAVE
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`late` = 0, 
               t.`undertime` = 0, 
               t.`absent` = 0,
               t.`hrs_rendered` = IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0)
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'EL' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    -- ]] STEP 4
    -- (classcode VARCHAR(32), classgroup VARCHAR(32), comp_id INT(11), shiftid INT(11), userid INT(11), optreturn VARCHAR(32))
    -- STEP 5: COMPLETING RENDERED HOURS... FINAL CHECK
    -- [[
    UPDATE `timeprocess` t, `time_shift` ts, ww_users u
           SET t.`late` = IF( time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                              u.company_id, t.`shift_id`, t.`user_id`, '00:00:00') <> '00:00:00'
                                    ,
                                    -- TRUE                                    
                                    IF( TIME(t.`timein`) > TIME(time_period_process_shift_department('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                              u.company_id, t.`shift_id`, t.`user_id`, '00:00:00')),
                                        -- TRUE
                                        IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) / 2,
                                        -- FALSE
                                        t.`late`
                                    )
                                    ,
                                    -- FALSE
                                    t.`late`
                                )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id` and
                 t.user_id = u.user_id;
            
    UPDATE `timeprocess` t
           SET t.`absent` = 0, t.`hrs_rendered` = IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) * IF(t.`lwp` * 8 IN (4,6), .5, 1)
           WHERE t.`lwp` > 0 AND t.absent = 1;
    
    UPDATE `timeprocess` t
           SET t.`absent` = 0, t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime` - (IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) * IF(t.`lwop` * 8 IN (4,6), .5, IF(t.`lwop`=0, 0,1) ))
           WHERE t.`day_type` = 'REGULAR' AND t.`lwop` > 0;
    
    -- To process LIP
    UPDATE `timeprocess` t
           SET t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime`
           WHERE t.`day_type` = 'REGULAR' AND t.`lwp` > 0;
               
    UPDATE `timeprocess` t
           SET t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime`
           WHERE t.`day_type` = 'REGULAR' AND t.`lwop` = 0 AND t.`lwp` = 0;
    
    UPDATE `timeprocess` t
           SET t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime`
           WHERE t.`day_type` IN ('SPECIAL','LEGAL');
    -- ]] STEP 5
    
    
    
    -- STEP 6: RESIGNED TAGGING / COMPUTE OVERTIME
    -- [[
    -- > 6.1 RESIGNED
    UPDATE `timeprocess` t
           SET t.`resigned` = time_period_process_resigned(t.`user_id`, t.`date`);
    
    -- > 6.2 OVERTIME
    UPDATE ww_time_record_summary SET ot = 0 WHERE period_id = periodid AND IF(user_id = 0, 1, user_id = userid);
    CALL sp_time_period_process_summary_ot(periodid, userid);
    
    -- > 6.2.1 OVERTIME BREAK
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_break` tdtb ON tdtb.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_break` tdb ON tdb.`deleted` = 0 AND tdb.`break_id` = tdtb.`break_id`
    JOIN `ww_time_day_break_range` tdbr ON tdbr.`break_id` = tdb.`break_id`
    join `ww_users` u on u.user_id = t.user_id and u.company_id = tdbr.company_id
           SET t.`ot_break` = IFNULL(tdbr.`deduction`, 0)
           WHERE t.`ot` > 0 AND (t.`ot` BETWEEN tdbr.`hour_from` AND tdbr.`hour_to`);
    
    -- > 6.2.2 MEAL ALLOWANCE
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_allowance` tdta ON tdta.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_meal` tdm ON tdm.`deleted` = 0 AND tdm.`meal_id` = tdta.`meal_id`
    JOIN `ww_time_day_meal_range` tdmr ON tdmr.`meal_id` = tdm.`meal_id`
    JOIN `partners` p ON p.`user_id` = t.`user_id`
    JOIN `ww_time_day_allowance` tda ON tda.`employment_type_id` = p.`employment_type_id`
           SET t.`meal` = IFNULL(tdmr.`multiplier`, 0) * IFNULL(tda.`meal`, 0)
           WHERE t.`ot` > 0 AND ((t.`ot` - t.`ot_break`) BETWEEN tdmr.`hour_from` AND tdmr.`hour_to`);
    
    -- > 6.2.3 TRANSPO ALLOWANCE
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_allowance` tdta ON tdta.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_transpo` tdm ON tdm.`deleted` = 0 AND tdm.`transpo_id` = tdta.`transpo_id`
    JOIN `ww_time_day_transpo_range` tdmr ON tdmr.`transpo_id` = tdm.`transpo_id`
    JOIN `partners` p ON p.`user_id` = t.`user_id`
    JOIN `ww_time_day_allowance` tda ON tda.`employment_type_id` = p.`employment_type_id`
           SET t.`transpo` = IFNULL(tdmr.`multiplier`, 0) * IFNULL(tda.`transpo`, 0)
           WHERE t.`ot` > 0 AND ((t.`ot` - t.`ot_break`) BETWEEN tdmr.`hour_from` AND tdmr.`hour_to`);
    -- > 6.2.4 EXEMPTION ON ABSENT TAGGING ON CURRENT DATE
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`absent` = IF(NOW() < CONCAT(t.`date` + INTERVAL IF(ts.`time_start`='00:00:00', 1, 0) DAY,' ',ts.`time_end`), 0, t.`absent`)
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`date` = CURDATE() AND
                 t.`absent` = 1 AND
                 t.`shift_id` = ts.`shift_id`;
    
    -- > 6.2.5 MOVE LATE TO UNDERTIME
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd
           SET t.`undertime` = IF(IFNULL(t.`late`,0) > 0, IFNULL(t.`undertime`,0)+t.`late`, t.`undertime`),
               t.`late` = IF(t.`late` > 0, 0, t.`late`)
           WHERE tf.`user_id` = t.`user_id` AND 
                 tf.`form_code` = 'UT' AND 
                 tf.`form_status_id` = 6 AND 
                 tf.`forms_id` =  tfd.`forms_id` AND 
                 tfd.`duration_id` IN (1,2) AND
                 tfd.`date` =  t.`date`;
   -- ]] STEP 6
    
    
    -- > STEP 7: FINAL EXEMPTION
    -- [[
    -- > 7.1 DTR UPLOAD
    UPDATE `timeprocess` t
           SET t.`late`       =  IF(t.`hrs_actual` < 0, 0, t.`late`),
               t.`undertime`  =  IF(t.`hrs_actual` < 0, 0, t.`undertime`),
               t.`absent`     =  IF(t.`hrs_actual` < 0, 1, t.`absent`),
               t.`hrs_actual` = IF(t.`hrs_actual` < 0, 0, t.`hrs_actual`)
           WHERE t.`hrs_actual` < 0;
    
    UPDATE `timeprocess` t
           SET t.`absent` = 0
           WHERE t.`day_type` = 'REGULAR' AND t.`lwop` > 0;
    
    -- > 7.2 ATTENDANCE BASE
    UPDATE `timeprocess` t, `ww_payroll_partners` pp
           SET t.`late`       =  0,
               t.`undertime`  =  0,
               t.`absent`     =  0,
               t.`hrs_actual` = time_period_process_workhrs(t.`user_id`, t.`date`)
           WHERE (t.`hrs_rendered` > 0 OR t.`absent` = 1) AND
                 t.`lwop` = 0 AND
                 t.`user_id` = pp.`user_id` AND 
                 pp.`attendance_base` = 0 AND
                 pp.`deleted` = 0;
    
    -- > 7.3 NIGHT DIFF
    UPDATE timeprocess t, ww_users u
    SET t.nd = get_ndiff(u.user_id, t.date, u.company_id)
    WHERE u.user_id = t.user_id AND
	  (t.hrs_actual > 0 OR t.ot > 0);
    
    -- > 7.4 UNDER SUSPENSION
    
    -- ]] STEP 7
    
    
    -- STEP 7: INSERT SUMMARY
    -- [[
    INSERT INTO `ww_time_record_summary` (
           `record_id`,
           `user_id`,
           `id_number`,
           `date`,
           `period_id`,
           `payroll_date`,
           `day_type`,
           `hrs_rendered`,
           `hrs_actual`,
           `hrs_break`,
           `absent`,
           `lwp`,
           `lwop`,
           `late`,
           `undertime`,
           `nd`,
           `ot`,
           `ot_break`,
           `meal`,
           `transpo`,
           `resigned`,
           `awol` )
    SELECT `record_id`,
           `user_id`,
           `id_number`,
           `date`,
           `period_id`,
           `payroll_date`,
           `day_type`,
           `hrs_rendered`,
           `hrs_actual`,
           `hrs_break`,
           `absent`,
           `lwp`,
           `lwop`,
           `late`,
           `undertime`,
           `nd`,
           `ot`,
           `ot_break`,
           `meal`,
           `transpo`,
           `resigned`,
           `awol`
    FROM `timeprocess`
    ON DUPLICATE KEY UPDATE 
           `user_id`      = VALUES(`user_id`),
           `date`         = VALUES(`date`),    
           `day_type`     = VALUES(`day_type`),
           `hrs_rendered` = VALUES(`hrs_rendered`),
           `hrs_actual`   = VALUES(`hrs_actual`),
           `hrs_break`    = VALUES(`hrs_break`),
           `absent`       = VALUES(`absent`),
           `lwp`          = VALUES(`lwp`),
           `lwop`         = VALUES(`lwop`),
           `late`         = VALUES(`late`),
           `undertime`    = VALUES(`undertime`),
           `nd` 	  = VALUES(`nd`),
           `ot`           = VALUES(`ot`),
           `ot_break`     = VALUES(`ot_break`),
           `meal`         = VALUES(`meal`),
           `transpo`      = VALUES(`transpo`),
           `resigned`     = VALUES(`resigned`),
           `awol`         = VALUES(`awol`),
           `modified_on`  = NOW(); 
    
    -- ]]
    
    -- STEP 8: PROCESS FOR PAYROLL INPUT
    -- [[
    SET @absent_before_holiday = 0;
    SELECT IFNULL(`value`,0) INTO @absent_before_holiday
    FROM `ww_config`
    WHERE `key`='absent_before_holiday' AND `deleted`=0;
    
    IF @absent_before_holiday = 1 THEN
       CALL sp_time_period_validate_holiday( periodid, userid );
    END IF;
    
    
    SET @notlatefile = 0;
    SELECT period_id INTO @notlatefile
    FROM `ww_time_period` WHERE (CURDATE() BETWEEN date_from AND (cutoff + INTERVAL 25 DAY)) AND period_id = periodid;
    
    -- INSERT INTO `logtable` (`log`) VALUES (CONCAT(periodid,' ',@notlatefile));
    
    IF periodid = @notlatefile THEN
       CALL sp_time_period_summary( periodid, userid );
    END IF;
    
    -- CALL `sp_time_period_process_latefile`(periodid, userid);
    
    -- ]]
    /*
    -- this will update ww_time_record_summary project id
	    select date_from, date_to, payroll_date
	    into dtStart, dtEnd, dtPay
	    from ww_time_period where period_id = periodid;
 	    -- set project to default assigned project
	    UPDATE ww_time_record_summary trs
	    left join ww_users_profile up on trs.user_id = up.user_id
	    SET trs.project_id = up.project_id
	    WHERE trs.user_id = userid AND trs.`date` BETWEEN dtStart AND dtEnd AND payroll_date = dtPay;
	    -- this will set the project if it has movement
	    call sp_time_period_set_project(userid, dtStart, dtEnd, dtPay);
    */
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process_cws` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process_cws` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process_cws`(IN periodid INT(11), IN userid INT(11))
BEGIN
    
    DECLARE cwsdone TINYINT(11) DEFAULT 0;
    DECLARE cwsrec INT(11) DEFAULT 0;
    DECLARE formcode VARCHAR(8);
    DECLARE formsid INT(11);
    DECLARE formsdate DATE;
    
    DECLARE periods CURSOR FOR
       /*
       SELECT tf.form_code, tf.forms_id, tfd.`date`
       FROM ww_time_forms tf
       INNER JOIN ww_time_forms_date tfd ON tfd.forms_id=tf.forms_id
       INNER JOIN (
           SELECT tf.forms_id, tf.user_id, tfd.`date`
           FROM `ww_time_forms` tf
           INNER JOIN ww_time_forms_date tfd ON tfd.forms_id = tf.forms_id
           INNER JOIN ww_time_period tp ON tp.period_id = periodid AND tfd.`date` BETWEEN tp.date_from AND tp.date_to
           WHERE tf.`deleted`=0 AND tf.`user_id`=userid AND
                 tf.`form_status_id` = 6 AND tf.`form_code` = 'CWS'
       ) cws ON cws.`date`=tfd.`date` AND tf.user_id=userid AND tf.form_code <> 'CWS'; */
       
       SELECT tf.form_code, tf.forms_id, tfd.`date`
       FROM `ww_time_forms` tf
       JOIN ww_time_forms_date tfd ON tfd.forms_id = tf.forms_id
       JOIN ww_users_profile up ON up.`user_id`=tf.`user_id`
       JOIN ww_time_period tp ON tp.`company_id`=up.`company_id` AND tfd.`date` BETWEEN tp.date_from AND tp.date_to
       JOIN ww_time_form t ON t.`form_id`=tf.`form_id` -- AND t.`is_leave`=1
       JOIN ww_time_record_summary trs ON trs.`user_id`=tf.`user_id` AND trs.`date`=tfd.`date` 
       WHERE tf.`deleted`=0 AND 
             IF(userid=0, 1, tf.`user_id`=userid) AND
             tf.`form_status_id` = 6 AND 
             tf.`form_code` <> 'LWOP' AND 
             tp.period_id = periodid AND (trs.`absent` = 1 OR trs.`late` > 0 OR trs.`undertime`);
       
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET cwsdone = 1;
    
    OPEN periods;
    
    REPEAT
       FETCH periods INTO formcode, formsid, formsdate;
       
       IF NOT cwsdone THEN
          SET cwsrec = cwsrec + 1;
          CALL sp_time_forms_aux_shift(formcode, userid, formsid);
          CALL sp_time_record_raw_reupload(userid, formsdate);
       END IF;
       
    UNTIL cwsdone END REPEAT;
    
    CLOSE periods;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process_latefile` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process_latefile` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process_latefile`(IN periodid INT(11), IN userid INT(11))
BEGIN
    
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    -- STEP 1: RECOMPUTE PREVIOUS CUT OFF
    SET @nComp = 0;
    SET @PrevPeriod = 0;
    
    -- get previous period
    SET @PrevPeriod = time_get_previous_period(periodid);
    
    CALL sp_time_period_process( @PrevPeriod, userid ); 
    
    SET @dtPay = '0000-00-00';
    SELECT payroll_date INTO @dtPay FROM ww_time_period WHERE period_id = periodid;
    
    -- clear record
    DELETE FROM ww_time_record_process 
    WHERE time_period_id = @PrevPeriod AND payroll_date = @dtPay AND IF(userid=0,1,`user_id`=userid);
    
    -- STEP 2: VALIDATE RECORD FROM PREVIOUS CUTOFF
    -- INSERT INTO `logtable` (`log`) VALUES (CONCAT(@PrevPeriod,' - ',userid,' - ',@dtPay,' - ',periodid));
    CALL sp_time_period_late_attnd_deduction( @PrevPeriod, userid, @dtPay, periodid );
    
    -- STEP 3: RECOMPUTE OVERTIME FROM PREVIOUS CUT OFF
    CALL sp_time_period_late_overtime( periodid, userid );
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process_latefile_2` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process_latefile_2` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process_latefile_2`(IN periodid INT(11), IN userid INT(11))
BEGIN
    
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    -- STEP 1: RECOMPUTE PREVIOUS CUT OFF
    SET @nComp = 0;
    SET @PrevPeriod = 0;
    
    -- get previous period
    INSERT INTO `logtable` (`log`) SELECT CONCAT('sp_time_period_process(', @PrevPeriod, ',', userid, ' )' ); 
    SET @PrevPeriod = time_get_previous_period(periodid);
    CALL sp_time_period_process( @PrevPeriod, userid ); 
    
    SET @dtPay = '0000-00-00';
    SELECT payroll_date INTO @dtPay FROM ww_time_period WHERE period_id = periodid;
    
    -- clear record
    DELETE FROM ww_time_record_process 
    WHERE time_period_id = @PrevPeriod AND payroll_date = @dtPay AND IF(userid=0,1,`user_id`=userid);
    
    -- STEP 2: VALIDATE RECORD FROM PREVIOUS CUTOFF
    INSERT INTO `logtable` (`log`) SELECT CONCAT('sp_time_period_late_attnd_deduction( ',@PrevPeriod, ',', userid, ',',@dtPay, ',',periodid,')' );
    CALL sp_time_period_late_attnd_deduction( @PrevPeriod, userid, @dtPay, periodid );
    
    -- STEP 3: RECOMPUTE OVERTIME FROM PREVIOUS CUT OFF
    INSERT INTO `logtable` (`log`) SELECT CONCAT('sp_time_period_late_overtime( ',periodid, ',',userid,')' );
    CALL sp_time_period_late_overtime( periodid, userid );
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process_summary` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process_summary` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process_summary`(IN periodid INT(11), IN userid INT(11))
BEGIN
    
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    
    -- STEP 1: CREATE A TEMPORARY TABLE TO HOLD INITIAL SUMMARY
    -- [[
    DROP TEMPORARY TABLE IF EXISTS `timeprocess`;
    CREATE TEMPORARY TABLE `timeprocess` (
           `record_id` INT(11) UNSIGNED NOT NULL DEFAULT '0',
           `user_id` INT(11) NOT NULL DEFAULT '0',
           `id_number` VARCHAR(8) NOT NULL DEFAULT '',
           `date` DATE NOT NULL DEFAULT '0000-00-00',
           `payroll_date` DATE NOT NULL DEFAULT '0000-00-00',
           `shift_id` INT(11) NOT NULL DEFAULT '0',
           `shift` VARCHAR(16) NOT NULL DEFAULT '',
           `timein` DATETIME DEFAULT '0000-00-00 00:00:00',
           `timeout` DATETIME DEFAULT '0000-00-00 00:00:00',
           `day_type` VARCHAR(16) DEFAULT 'REGULAR',
           `hrs_rendered` DECIMAL(5,2) DEFAULT '0.00',
           `hrs_actual` DECIMAL(5,2) DEFAULT '0.00',
           `hrs_break` DECIMAL(5,2) DEFAULT '0.00',
           `absent` TINYINT(1) DEFAULT '0',
           `lwp` DECIMAL(5,2) DEFAULT '0.00',
           `lwop` DECIMAL(5,2) DEFAULT '0.00',
           `late` DECIMAL(5,2) DEFAULT '0.00',
           `undertime` DECIMAL(5,2) DEFAULT '0.00',
           `ot` DECIMAL(5,2) DEFAULT '0.00',
           `ot_break` DECIMAL(5,2) DEFAULT '0.00',
           `meal` DECIMAL(5,2) DEFAULT '0.00',
           `transpo` DECIMAL(5,2) DEFAULT '0.00',
           `resigned` TINYINT(1) DEFAULT '0',
           `awol` TINYINT(1) DEFAULT '0',
           `override` TINYINT(1) DEFAULT '0', -- >> (VALUE: 1=not to include, 0=include) field tag to check whether to include in the time record
    PRIMARY KEY (`record_id`,`user_id`,`date`,`payroll_date`),
            KEY `user_id` (`user_id`),
            KEY `date` (`date`),
            KEY `payroll_date` (`payroll_date`)
    ) ENGINE=INNODB DEFAULT CHARSET=utf8;
    -- ]] STEP 1
    
    
        
    -- STEP 2: INSERT TIME RECORDS NET OF ATTENDANCE LOGS
    -- [[
    INSERT INTO `timeprocess`
       ( `record_id`, `user_id`, `date`, `payroll_date`, `shift_id`, `shift`, `timein`, `timeout`,
         `hrs_rendered` )
       SELECT 
          tr.`record_id`, tr.`user_id`, tr.`date`, tp.`payroll_date`, 
          IF( IFNULL(tr.`aux_shift_id`, 0) = 0, tr.`shift_id`, IFNULL(tr.`aux_shift_id`, 0) ) `shift_id`,
          IF( IFNULL(tr.`aux_shift_id`, 0) = 0, tr.`shift`, IFNULL(tr.`aux_shift`, 0) ) `shift`,
          IF( IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') = '0000-00-00 00:00:00', 
              IFNULL(tr.`time_in`, '0000-00-00 00:00:00'), 
              IF( IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') > IFNULL(tr.`time_in`, '0000-00-00 00:00:00') AND IFNULL(tr.`time_in`, '0000-00-00 00:00:00') <> '0000-00-00 00:00:00',
                 IFNULL(tr.`time_in`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`aux_time_in`, '0000-00-00 00:00:00') 
              )
          ) `timein`,
          IF( IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00') = '0000-00-00 00:00:00', 
              IFNULL(tr.`time_out`, '0000-00-00 00:00:00'), 
              IF( IFNULL(tr.`time_out`, '0000-00-00 00:00:00') > IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`time_out`, '0000-00-00 00:00:00'),
                 IFNULL(tr.`aux_time_out`, '0000-00-00 00:00:00') 
              )
          ) `timeout`,
          
          time_period_process_workhrs(tr.`user_id`, tr.`date`)
          
       FROM 
             `time_record` tr, `ww_time_period` tp, `users_profile` up
       WHERE 
              up.`company_id` = tp.`company_id` AND
              up.`user_id` = tr.`user_id` AND
              tp.period_id = periodid AND
              IF(userid = 0, 1, tr.`user_id` = userid) AND
              tr.`date` BETWEEN tp.date_from AND IF(tp.date_to > DATE(NOW()), DATE(NOW()), tp.date_to);
    -- ]] STEP 2
    
    
    
    -- STEP 3: SET RESTDAY, ABSENT, LWOP, LEAVE, etc... (AWOL is executed outside this script)
    -- [[
    -- > 3.1 RESTDAY
    UPDATE `timeprocess` t, `time_shift` ts 
           SET t.`day_type` = UPPER(ts.`shift`), 
               t.`hrs_rendered` = 0
           WHERE t.`shift_id` = ts.`shift_id` AND 
                 UPPER(ts.`shift`) = 'RESTDAY';
    
    
    -- > 3.2 HOLIDAY / LEGAL / SPECIAL 
    /*
    UPDATE `timeprocess` t
    INNER JOIN `ww_time_day_type` tdt ON tdt.deleted = 0
    INNER JOIN `ww_time_holiday` th ON th.deleted = 0
    LEFT JOIN `ww_time_holiday_location` thl ON thl.deleted = 0 AND thl.`holiday_id` = th.`holiday_id` AND thl.`user_id` = t.`user_id`
    
           SET t.`day_type` = IF( th.`legal` = 1, 
                                  UPPER(tdt.`day_type_code`),
                                  IF( IFNULL(th.`location_count`,0) = 0, 
                                      UPPER(tdt.`day_type_code`),
                                      IF( thl.`user_id` = t.`user_id`,
                                          UPPER(tdt.`day_type_code`),
                                          t.`day_type`
                                      )
                                  )
                              )
           WHERE t.`date` = th.`holiday_date` AND t.`day_type` = 'REGULAR';
    */
    UPDATE `timeprocess` t
    INNER JOIN `ww_time_holiday` th ON th.deleted = 0
    LEFT JOIN `ww_time_holiday_location` thl ON thl.deleted = 0 AND thl.`holiday_id` = th.`holiday_id` AND thl.`user_id` = t.`user_id`
    
           SET t.`day_type` = IF( th.`legal` = 1, 
                                  -- TRUE: IF(t.`day_type`='RESTDAY', 'RDHOL', 'LEGAL'),
                                  'LEGAL',
                                  -- FALSE:
                                  IF( IFNULL(th.`location_count`,0) = 0,
                                      -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                      'SPECIAL',
                                      -- FALSE:
                                      IF( thl.`user_id` = t.`user_id`,
                                          -- TRUE: IF(t.`day_type`='RESTDAY', 'RDSPEC', 'SPECIAL'),
                                          'SPECIAL',
                                          -- FALSE:
                                          t.`day_type`
                                      )
                                  )
                              )
           WHERE t.`date` = th.`holiday_date` AND t.`day_type` = 'REGULAR';
    
    
    -- > 3.3 ABSENT
    UPDATE `timeprocess` t
           SET t.`absent` = 1, t.`hrs_rendered` = 0
           WHERE `day_type` = 'REGULAR' AND 
                 (`timein` = '0000-00-00 00:00:00' OR `timeout` = '0000-00-00 00:00:00');
    
    
    -- > 3.4 LEAVE WITH PAY /AND/ LEAVE WITHOUT PAY
    SET @lwop = 0;
    SELECT `form_id` INTO @lwop FROM `ww_time_form` WHERE `form_code`='LWOP' LIMIT 1;
    
    UPDATE `timeprocess` t
           SET t.`lwop` = time_period_process_lwop(t.`user_id`,t.`date`,@lwop),
               t.`lwp` = time_period_process_lwp(t.`user_id`,t.`date`,@lwop),
               t.`hrs_break` = time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') / 60               
           WHERE t.`day_type` = 'REGULAR';
    -- ]] STEP 3    
    
    
    
    -- STEP 4: SET LATE AND UNDERTIME
    -- [[
    -- > 4.1 LATE (Converted to HOUR): limited to regular schedule only and its assigned schedule including all applications
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`late` = IF(t.`absent` = 1, 
                             -- TRUE: assigned no lates since it is already absent
                             0,
                             -- FALSE: get minutes considering grace period
                             IF( (TIMESTAMPDIFF(MINUTE, 
                                                (CONCAT(t.`date`,' ',ts.`time_start`) + INTERVAL 
                                                (time_period_process_shift('GRACE-PERIOD-IN-MINUTES','EMPLOYMENT-TYPE', 
                                                    t.`user_id`, t.`shift_id`,'0')) MINUTE),
                                  t.`timein` )*1) <= 0,
                                  -- TRUE: assigned no lates
                                  0,
                                  -- FALSE: get minutes lates disregarding grace period
                                  TIMESTAMPDIFF(MINUTE, CONCAT(t.`date`,' ',ts.`time_start`), t.`timein`) / 60
                             )
                          )
           WHERE t.`day_type` = 'REGULAR' AND t.`shift_id` = ts.`shift_id`;
           
    
    -- > 4.1.1 EXEMPTIONS ON SPECIAL PARTNERS
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`late` = IF( time_period_process_shift('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      t.`user_id`, t.`shift_id`,'00:00:00') <> '00:00:00',
                            -- TRUE: special condition normally on managers (e.g. flexi until 10am)
                            IF( TIMESTAMPDIFF(MINUTE, CONCAT(t.`date`,' ', time_period_process_shift('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      t.`user_id`, t.`shift_id`,'00:00:00')), t.`timein`) > 0,
                                -- TRUE:
                                TIMESTAMPDIFF(MINUTE, CONCAT(t.`date`,' ', time_period_process_shift('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                      t.`user_id`, t.`shift_id`,'00:00:00')), t.`timein`) / 60,
                                -- FALSE:
                                0
                            ),
                            -- FALSE: no changes on the value
                            t.`late`
                        )
           WHERE t.`late` > 0 AND t.`shift_id` = ts.`shift_id`;           
    
    
    -- > 4.1.2 EXEMPTIONS ON MANAGERS
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`late` = IF( time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      t.`user_id`, t.`shift_id`,'00:00:00') <> '00:00:00',
                            -- TRUE: special condition normally on managers (e.g. flexi until 10am)
                            IF( TIMESTAMPDIFF(MINUTE, CONCAT(t.`date`,' ', time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      t.`user_id`, t.`shift_id`,'00:00:00')), t.`timein`) > 0,
                                -- TRUE:
                                TIMESTAMPDIFF(MINUTE, CONCAT(t.`date`,' ', time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                      t.`user_id`, t.`shift_id`,'00:00:00')), t.`timein`) / 60,
                                -- FALSE:
                                0
                            ),
                            -- FALSE: no changes on the value
                            t.`late`
                        )
           WHERE t.`late` > 0 AND t.`shift_id` = ts.`shift_id`;           
    
    
    -- > 4.1.3 EXEMPTIONS ON EXCUSED TARDINESS
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`late` = 0
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'ET' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    
    
    -- > 4.2 UNDERTIME (Converted to HOUR)
    -- >
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`undertime` = IF(t.`absent` = 1, 
                           -- TRUE: assigned no undertime since it is already absent
                           0,
                           -- FALSE: get minutes interval
                           IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date`,' ',ts.`time_end`) ) <= 0,
                               -- TRUE: assigned no lates
                               0,
                               -- FALSE: get minutes interval
                               TIMESTAMPDIFF(MINUTE, t.`timeout`, CONCAT(t.`date`,' ',ts.`time_end`)) / 60
                           )
                        )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id`;
    
     
    -- > 4.2.1 EXEMPTIONS ON SPECIAL PARTNERS
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`undertime` = IF( time_period_process_shift('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                             t.`user_id`, t.`shift_id`,'00:00:00') <> '00:00:00',
                               
                                   IF( t.`timein` <= CONCAT(t.`date`,' ', 
                                                            time_period_process_shift('FLEXIBLE-SHIFT','PARTNERS-ID', 
                                                            t.`user_id`, t.`shift_id`,'00:00:00')),
                                
                                       -- TRUE: special condition on special partner (e.g. flexi until 10am)
                                       IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL t.`hrs_break` HOUR
                                                                 ) ) > 0,
                                           TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL t.`hrs_break` HOUR
                                                                 ) ) / 60,
                                           -- FALSE: no changes on the value
                                           0
                                       ),
                                       0
                                   ),
                                   -- FALSE: no changes on the value
                                   t.`undertime`
                               )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id`;
    
    
    -- > 4.2.2 EXEMPTIONS ON MANAGERS
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`undertime` = IF( time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                             t.`user_id`, t.`shift_id`,'00:00:00') <> '00:00:00',
                               
                                   IF( t.`timein` <= CONCAT(t.`date`,' ', 
                                                            time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                            t.`user_id`, t.`shift_id`,'00:00:00')),
                                
                                       -- TRUE: special condition on special partner (e.g. flexi until 10am)
                                       IF( TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') MINUTE
                                                                 ) ) > 0,
                                           TIMESTAMPDIFF(MINUTE, t.`timeout`, 
                                                                 ( t.`timein` +
                                                                   INTERVAL time_period_process_workhrs(t.`user_id`, t.`date`) HOUR +
                                                                   INTERVAL time_period_process_shift('BREAK-IN-MINUTES','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`, '60') MINUTE
                                                                 ) ) / 60,
                                           -- FALSE: no changes on the value
                                           0
                                       ),
                                       0
                                   ),
                                   -- FALSE: no changes on the value
                                   t.`undertime`
                               )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id`;
    
    
    -- > 4.2.3 EXEMPTIONS ON EXCUSED UNDERTIME
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`undertime` = 0
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'UT' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    
    
    -- > 4.2.4 EXEMPTIONS ON EMERGENCY LEAVE
    UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_forms_blanket` tfb
           SET t.`late` = 0, 
               t.`undertime` = 0, 
               t.`absent` = 0,
               t.`hrs_rendered` = IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0)
           WHERE tf.`forms_id` =  tfd.`forms_id` AND 
                 tf.`user_id` = 0 AND 
                 tf.`form_code` = 'EL' AND 
                 tf.form_status_id = 6 AND 
                 tfd.`date` =  t.`date` AND 
                 tfb.`forms_id` = tf.`forms_id` AND
                 tfb.`user_id` =  t.`user_id`;
    -- ]] STEP 4
    
    
    
    -- STEP 5: COMPLETING RENDERED HOURS... FINAL CHECK
    -- [[
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`late` = IF( time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                              t.`user_id`, t.`shift_id`,'00:00:00') <> '00:00:00'
                                    ,
                                    -- TRUE                                    
                                    IF( TIME(t.`timein`) > TIME(time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`,'00:00:00')),
                                        -- TRUE
                                        IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) / 2,
                                        -- FALSE
                                        t.`late`
                                    )
                                    ,
                                    -- FALSE
                                    t.`late`
                                )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id`;
    UPDATE `timeprocess` t
           SET t.`absent` = 0, t.`hrs_rendered` = IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) * t.`lwp`
           WHERE t.`lwp` > 0 AND t.absent = 1;
    
    UPDATE `timeprocess` t
           SET t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime` - (IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) * t.`lwop`)
           WHERE t.`day_type` = 'REGULAR';
    UPDATE `timeprocess` t
           SET t.`hrs_actual` = t.`hrs_rendered` - t.`late` - t.`undertime` - (IFNULL(time_period_process_workhrs(t.`user_id`, t.`date`),0) * t.`lwop`)
           WHERE t.`day_type` IN ('SPECIAL','LEGAL');
    -- > 5.x EXEMPTIONS ON MANAGERS
    /*
    UPDATE `timeprocess` t, `time_shift` ts
           SET t.`late` = IF( time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                              t.`user_id`, t.`shift_id`,'00:00:00') <> '00:00:00'
                                    ,
                                    -- TRUE                                    
                                    IF( TIME(t.`timein`) > TIME(time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`,'00:00:00')),
                                        -- TRUE
                                        0,
                                        -- FALSE
                                        t.`late`
                                    )
                                    ,
                                    -- FALSE
                                    t.`late`
                                ),
               t.`hrs_actual` = IF( time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', 
                                                              t.`user_id`, t.`shift_id`,'00:00:00') <> '00:00:00'
                                    ,
                                    -- TRUE                                    
                                    IF( TIME(t.`timein`) > TIME(time_period_process_shift('FLEXIBLE-SHIFT','EMPLOYMENT-TYPE', t.`user_id`, t.`shift_id`,'00:00:00')),
                                        -- TRUE
                                        IF( t.`hrs_actual` >= 4, t.`hrs_actual` - 4, t.`hrs_actual`),
                                        -- FALSE
                                        t.`hrs_actual`
                                    )
                                    ,
                                    -- FALSE
                                    t.`hrs_actual`
                                )
           WHERE t.`day_type` = 'REGULAR' AND 
                 t.`absent` = 0 AND
                 t.`lwp` = 0 AND 
                 t.`lwop` = 0 AND 
                 t.`shift_id` = ts.`shift_id`;
    */
    -- ]] STEP 5
    
    
    
    -- STEP 6: RESIGNED TAGGING / COMPUTE OVERTIME
    -- [[
    -- > 6.1 RESIGNED
    UPDATE `timeprocess` t
           SET t.`resigned` = time_period_process_resigned(t.`user_id`, t.`date`);
    
    -- > 6.2 OVERTIME
    
    -- UPDATE `timeprocess` t, `time_forms` tf, `time_forms_date` tfd, `ww_time_form_status` tfs, `ww_time_form` tfc
                 
    CALL sp_time_period_process_summary_ot(periodid, userid);
    
    -- > 6.2.1 OVERTIME BREAK
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_break` tdtb ON tdtb.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_break` tdb ON tdb.`deleted` = 0 AND tdb.`break_id` = tdtb.`break_id`
    JOIN `ww_time_day_break_range` tdbr ON tdbr.`break_id` = tdb.`break_id`
           SET t.`ot_break` = IFNULL(tdbr.`deduction`, 0)
           WHERE t.`ot` > 0 AND (t.`ot` BETWEEN tdbr.`hour_from` AND tdbr.`hour_to`);
    
    -- > 6.2.2 MEAL ALLOWANCE
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_allowance` tdta ON tdta.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_meal` tdm ON tdm.`deleted` = 0 AND tdm.`meal_id` = tdta.`meal_id`
    JOIN `ww_time_day_meal_range` tdmr ON tdmr.`meal_id` = tdm.`meal_id`
    JOIN `partners` p ON p.`user_id` = t.`user_id`
    JOIN `ww_time_day_allowance` tda ON tda.`employment_type_id` = p.`employment_type_id`
           SET t.`meal` = IFNULL(tdmr.`multiplier`, 0) * IFNULL(tda.`meal`, 0)
           WHERE t.`ot` > 0 AND ((t.`ot` - t.`ot_break`) BETWEEN tdmr.`hour_from` AND tdmr.`hour_to`);
    
    -- > 6.2.3 TRANSPO ALLOWANCE
    UPDATE `timeprocess` t
    JOIN `ww_time_day_type` tdt ON tdt.`deleted` = 0 AND t.`day_type` = tdt.`day_type_code`
    JOIN `ww_time_day_type_allowance` tdta ON tdta.`day_type_id` = tdt.`day_type_id`
    JOIN `ww_time_day_transpo` tdm ON tdm.`deleted` = 0 AND tdm.`transpo_id` = tdta.`transpo_id`
    JOIN `ww_time_day_transpo_range` tdmr ON tdmr.`transpo_id` = tdm.`transpo_id`
    JOIN `partners` p ON p.`user_id` = t.`user_id`
    JOIN `ww_time_day_allowance` tda ON tda.`employment_type_id` = p.`employment_type_id`
           SET t.`transpo` = IFNULL(tdmr.`multiplier`, 0) * IFNULL(tda.`transpo`, 0)
           WHERE t.`ot` > 0 AND ((t.`ot` - t.`ot_break`) BETWEEN tdmr.`hour_from` AND tdmr.`hour_to`);
    -- ]] STEP 6
    
    /*
    SELECT `record_id`,
           `user_id`,
           `id_number`,
           `date`,
           `payroll_date`,
           `shift_id`,
           `shift`,
           `timein`,
           `timeout`,
           `day_type`,
           `hrs_rendered`,
           `hrs_actual`,
           `hrs_break`,
           `absent`,
           `lwp`,
           `lwop`,
           `late`,
           `undertime`,
           `ot`,
           `ot_break`,
           `meal`,
           `transpo`,
           `resigned`,
           `awol`
    FROM `timeprocess` 
    ORDER BY `user_id`, `date`;
    */
    
    -- STEP 7: INSERT SUMMARY
    -- [[
    INSERT INTO `ww_time_record_summary` (
           `record_id`,
           `user_id`,
           `id_number`,
           `date`,
           `payroll_date`,
           `day_type`,
           `hrs_rendered`,
           `hrs_actual`,
           `hrs_break`,
           `absent`,
           `lwp`,
           `lwop`,
           `late`,
           `undertime`,
           `ot`,
           `ot_break`,
           `meal`,
           `transpo`,
           `resigned`,
           `awol` )
    SELECT `record_id`,
           `user_id`,
           `id_number`,
           `date`,
           `payroll_date`,
           `day_type`,
           `hrs_rendered`,
           `hrs_actual`,
           `hrs_break`,
           `absent`,
           `lwp`,
           `lwop`,
           `late`,
           `undertime`,
           `ot`,
           `ot_break`,
           `meal`,
           `transpo`,
           `resigned`,
           `awol`
    FROM `timeprocess`
    ON DUPLICATE KEY UPDATE 
           `day_type`     = VALUES(`day_type`),
           `hrs_rendered` = VALUES(`hrs_rendered`),
           `hrs_actual`   = VALUES(`hrs_actual`),
           `hrs_break`    = VALUES(`hrs_break`),
           `absent`       = VALUES(`absent`),
           `lwp`          = VALUES(`lwp`),
           `lwop`         = VALUES(`lwop`),
           `late`         = VALUES(`late`),
           `undertime`    = VALUES(`undertime`),
           `ot`           = VALUES(`ot`),
           `ot_break`     = VALUES(`ot_break`),
           `meal`         = VALUES(`meal`),
           `transpo`      = VALUES(`transpo`),
           `resigned`     = VALUES(`resigned`),
           `awol`         = VALUES(`awol`),
           `modified_on`  = NOW();
    -- ]]
    
    
    
    -- STEP 8: PROCESS FOR PAYROLL INPUT
    -- [[
    CALL sp_time_period_validate_holiday( periodid, userid );
    CALL sp_time_period_summary( periodid, userid );
    CALL sp_time_period_late_overtime( periodid, userid );
    -- ]]
    
    
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process_summary_ot` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process_summary_ot` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process_summary_ot`(  IN periodid INT(11), IN userid INT(11) )
BEGIN	
	DECLARE otdone TINYINT(1) DEFAULT 0;
	DECLARE nUserID INT(11);
	DECLARE nRecID INT(11);
	DECLARE nShiftID INT(11);
	DECLARE dtDate DATE;			
	DECLARE nCompID INT(11);
	DECLARE sDayType VARCHAR(32);
	DECLARE dtTimeFrom DATETIME;
	DECLARE dtTimeTo DATETIME;
	DECLARE nHours DECIMAL(5,2);
	
	DECLARE overtime CURSOR FOR
		SELECT a.`user_id`, a.`forms_id`, time_get_shift(a.`user_id`, b.`date`), b.`date`, 
			getcompany(a.user_id), get_time_daytype( a.user_id, b.date),
			b.`time_from`, b.`time_to`
		FROM ww_time_forms a, ww_time_forms_date b, ww_time_period c, ww_users d 
		WHERE a.forms_id = b.forms_id AND a.`deleted` = 0 AND b.`deleted` = 0
		AND a.`form_status_id` = 6 AND  a.`date_approved` IS NOT NULL 
		AND IF(userid=0, 1, a.`user_id` = userid) AND a.`form_code` = 'OT'
		-- AND b.date BETWEEN get_time_period_from(periodid,getcompany(userid)) AND get_time_period_to(periodid,getcompany(userid));
		AND c.deleted = 0 AND c.period_id = periodid AND (b.date BETWEEN c.date_from AND c.date_to)
		AND c.company_id = d.company_id AND a.user_id = d.user_id
		union all
		-- Query for getting OT filed in behalf
		SELECT tfb.`user_id`, tf.`forms_id`, time_get_shift(tfb.`user_id`, tfd.`date`), tfd.`date`,
		       getcompany(tfb.`user_id`), get_time_daytype(tfb.`user_id`, tfd.`date`),
		       tfd.`time_from`, tfd.`time_to`
		FROM ww_time_forms tf, ww_time_forms_date tfd, ww_time_period tp, ww_users u, ww_time_forms_blanket tfb
		WHERE 	tf.forms_id = tfd.forms_id AND 
			tf.form_code = 'OT' AND
			tf.display_name = 'Blanket' AND
			tfd.forms_id = tfb.forms_id AND
			u.`user_id` = tfb.`user_id` AND
			tp.`deleted` = 0 AND
			tf.`deleted` = 0 AND
			tp.`period_id` = periodid AND
			u.`company_id` = tp.`company_id` AND
		       (tfd.`date` BETWEEN tp.`date_from` AND tp.`date_to`) AND
		       IF(userid=0,1,tfb.`user_id`=userid);
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET otdone = 1;
	
	OPEN overtime;
	
	myLoop: LOOP
		FETCH overtime INTO nUserID, nRecID, nShiftID, dtDate, nCompID, sDayType, dtTimeFrom, dtTimeTo;
		
		IF otdone = 1 THEN
		    CLOSE overtime;
		    LEAVE myLoop;
		END IF;
		
		SET @nHours = 0;
		SET @ActualIN = "";
		SET @ActualOUT = "";
		SET @otStart = "";
		SET @otEnd = "";
		
		-- get sched out
		IF time_get_sched_in( nShiftID ) > time_get_sched_out( nShiftID ) THEN
		    SET @SchedOut = CONCAT(dtDate + INTERVAL 1 DAY, ' ', time_get_sched_out( nShiftID ) );
		ELSE
		    SET @SchedOut = CONCAT(dtDate, ' ', time_get_sched_out( nShiftID ) );
		END IF;
		SET @SchedIn = CONCAT(dtDate, ' ', time_get_sched_in( nShiftID ) );
		
		-- get current ND set up
		-- SET @curStartND = CONCAT(dtDate, ' ', time_get_nd_start( nShiftID, nCompID ) );
		-- SET @curEndND = CONCAT( ADDDATE( dtDate, 1 ), ' ', time_get_nd_end( nShiftID, nCompID ) );
		-- get previous ND set up
		-- SET @prevStartND = CONCAT( ADDDATE( dtDate, -1 ), ' ', time_get_nd_start( nShiftID, nCompID ) );
		-- SET @prevEndND = CONCAT( dtDate, ' ', time_get_nd_end( nShiftID, nCompID ) );
		-- get actual time in / out
		
		SET @ActualIN = time_get_time_in( nUserID, dtDate);
		SET @ActualOUT = time_get_time_out( nUserID, dtDate);
		
		if @ActualIN <> '0000-00-00 00:0:00' AND @ActualOUT <> '0000-00-00 00:0:00' then
			-- update ot of timeprocess
			IF sDayType = 'REGULAR' THEN
				
				-- before shift ot
				/*
				IF dtTimeFrom < @SchedIn THEN
					IF dtTimeTo >= @SchedIn THEN
						SET @otEnd =  @SchedIn;
					END IF;
					IF dtTimeTo < @SchedIn THEN
						SET @otEnd =  dtTimeTo;
					END IF;
					
					SET @otStart = dtTimeFrom;
					IF dtTimeFrom < @ActualIN THEN
						SET @otStart = @ActualIN;
					END IF;
					
					SET @nHours = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
				END IF; */
					
				-- after shift ot
				IF dtTimeFrom > @SchedIn THEN
					IF dtTimeFrom <= @SchedOut THEN
						SET @otStart = @SchedOut;
					END IF;
					IF dtTimeFrom > @SchedOut THEN
						SET @otStart = dtTimeFrom;
					END IF;
					
					SET @otEnd = dtTimeTo;
					IF dtTimeTo > @ActualOUT THEN	
						SET @otEnd = @ActualOUT;
					END IF;
					
					SET @nHours = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
				ELSE
					SET @otStart = @SchedOut;
					IF @ActualOUT > dtTimeTo THEN
						SET @otEnd = dtTimeTo;
					ELSE
						SET @otEnd = @ActualOUT;
					END IF;
					
					SET @nHours = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
				END IF;
				-- end of regular
			
			ELSE 
				IF @ActualIN <= dtTimeFrom THEN
					SET @otStart = dtTimeFrom;
				ELSEIF @ActualIN > dtTimeFrom THEN
					SET @otStart = @ActualIN;
				END IF;
				
				IF @ActualOUT >= dtTimeTo THEN
					SET @otEnd = dtTimeTo;
				ELSEIF @ActualOUT < dtTimeTo THEN
					SET @otEnd = @ActualOUT;
				END IF;
				
				SET @nHours = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
				SET @nHours = ROUND( ( TIME_TO_SEC( TIMEDIFF( dtTimeTo, dtTimeFrom ) ) / 3600 ), 2 );
			END IF;
		end if;
		IF IFNULL(@nHours,0) > 0 THEN
			UPDATE timeprocess SET ot = ot + IFNULL(@nHours,0) WHERE user_id = nUserID AND DATE = dtDate;
			
			IF sDayType = 'DOUBLE' THEN
				UPDATE timeprocess SET day_type = 'DOUBLE' WHERE user_id = nUserID AND DATE = dtDate;
			END IF;
		END IF;
	END LOOP;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process_summary_ot_2` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process_summary_ot_2` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process_summary_ot_2`(  IN periodid INT(11), IN userid INT(11) )
BEGIN	
	DECLARE period_otdone TINYINT(1) DEFAULT 0;
	DECLARE nUserID INT(11);
	DECLARE nRecID INT(11);
	DECLARE nShiftID INT(11);
	DECLARE dtDate DATE;			
	DECLARE nCompID INT(11);
	DECLARE sDayType VARCHAR(32);
	DECLARE dtTimeFrom DATETIME;
	DECLARE dtTimeTo DATETIME;
	DECLARE nHours DECIMAL(5,2);
	
	DECLARE period_overtime CURSOR FOR
		SELECT a.`user_id`, a.`forms_id`, time_get_shift(a.`user_id`, b.`date`), b.`date`, 
			getcompany(a.user_id), get_time_daytype( a.user_id, b.date),
			b.`time_from`, b.`time_to`
		FROM ww_time_forms a, ww_time_forms_date b, ww_time_period c, ww_users d 
		WHERE a.forms_id = b.forms_id AND a.`deleted` = 0 AND b.`deleted` = 0
		AND a.`form_status_id` = 6 AND  a.`date_approved` IS NOT NULL 
		AND IF(userid=0, 1, a.`user_id` = userid) AND a.`form_code` = 'OT'
		-- AND b.date BETWEEN get_time_period_from(periodid,getcompany(userid)) AND get_time_period_to(periodid,getcompany(userid));
		AND c.deleted = 0 AND c.period_id = periodid AND (b.date BETWEEN c.date_from AND c.date_to)
		AND c.company_id = d.company_id AND a.user_id = d.user_id
		/*
		union all
		-- Query for getting OT filed in behalf
		SELECT tfb.`user_id`, tf.`forms_id`, time_get_shift(tfb.`user_id`, tfd.`date`), tfd.`date`,
		       getcompany(tfb.`user_id`), get_time_daytype(tfb.`user_id`, tfd.`date`),
		       tfd.`time_from`, tfd.`time_to`
		FROM ww_time_forms tf, ww_time_forms_date tfd, ww_time_period tp, ww_users u, ww_time_forms_blanket tfb
		WHERE 	tf.forms_id = tfd.forms_id AND 
			tf.form_code = 'OT' AND
			tf.display_name = 'Blanket' AND
			tfd.forms_id = tfb.forms_id AND
			u.`user_id` = tfb.`user_id` AND
			tp.`deleted` = 0 AND
			tf.`deleted` = 0 AND
			tp.`period_id` = periodid AND
			u.`company_id` = tp.`company_id` AND
		       (tfd.`date` BETWEEN tp.`date_from` AND tp.`date_to`) AND
		       IF(userid=0,1,tfb.`user_id`=userid)
		*/
		ORDER BY a.`user_id`, b.`date`;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET period_otdone = 1;
	
	OPEN period_overtime;
	
	myLoop: LOOP
		FETCH period_overtime INTO nUserID, nRecID, nShiftID, dtDate, nCompID, sDayType, dtTimeFrom, dtTimeTo;
		INSERT INTO `logtable` (`log`) -- SELECT CONCAT('user_id=',nUserID,', date=',dtDate);
		SELECT CONCAT(period_otdone,', ', nUserID,', ', nRecID,', ', nShiftID,', ', dtDate,', ', nCompID,', ', sDayType,', ', dtTimeFrom,', ', dtTimeTo);
		
		IF period_otdone = 1 THEN
		    CLOSE period_overtime;
		    LEAVE myLoop;
		END IF;
		INSERT INTO `logtable` (`log`) SELECT 'start';
		SET @nHours = 0;
		SET @ActualIN = "";
		SET @ActualOUT = "";
		SET @otStart = "";
		SET @otEnd = "";
		
		-- get sched out
		IF time_get_sched_in( nShiftID ) > time_get_sched_out( nShiftID ) THEN
		    SET @SchedOut = CONCAT(dtDate + INTERVAL 1 DAY, ' ', time_get_sched_out( nShiftID ) );
		ELSE
		    SET @SchedOut = CONCAT(dtDate, ' ', time_get_sched_out( nShiftID ) );
		END IF;
		SET @SchedIn = CONCAT(dtDate, ' ', time_get_sched_in( nShiftID ) );
		
		-- get current ND set up
		-- SET @curStartND = CONCAT(dtDate, ' ', time_get_nd_start( nShiftID, nCompID ) );
		-- SET @curEndND = CONCAT( ADDDATE( dtDate, 1 ), ' ', time_get_nd_end( nShiftID, nCompID ) );
		-- get previous ND set up
		-- SET @prevStartND = CONCAT( ADDDATE( dtDate, -1 ), ' ', time_get_nd_start( nShiftID, nCompID ) );
		-- SET @prevEndND = CONCAT( dtDate, ' ', time_get_nd_end( nShiftID, nCompID ) );
		-- get actual time in / out
		
		SET @ActualIN = time_get_time_in( nUserID, dtDate);
		SET @ActualOUT = time_get_time_out( nUserID, dtDate);
		
		-- update ot of timeprocess
		IF sDayType = 'REGULAR' THEN
			
			-- before shift ot
			/*
			IF dtTimeFrom < @SchedIn THEN
				IF dtTimeTo >= @SchedIn THEN
					SET @otEnd =  @SchedIn;
				END IF;
				IF dtTimeTo < @SchedIn THEN
					SET @otEnd =  dtTimeTo;
				END IF;
				
				SET @otStart = dtTimeFrom;
				IF dtTimeFrom < @ActualIN THEN
					SET @otStart = @ActualIN;
				END IF;
				
				SET @nHours = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
			END IF; */
				
			-- after shift ot
			IF dtTimeFrom > @SchedIn THEN
				IF dtTimeFrom <= @SchedOut THEN
					SET @otStart = @SchedOut;
				END IF;
				IF dtTimeFrom > @SchedOut THEN
					SET @otStart = dtTimeFrom;
				END IF;
				
				SET @otEnd = dtTimeTo;
				IF dtTimeTo > @ActualOUT THEN	
					SET @otEnd = @ActualOUT;
				END IF;
				
				SET @nHours = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
			ELSE
				SET @otStart = @SchedOut;
				IF @ActualOUT > dtTimeTo THEN
					SET @otEnd = dtTimeTo;
				ELSE
					SET @otEnd = @ActualOUT;
				END IF;
				
				SET @nHours = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
			END IF;
			-- end of regular
		
		ELSE 
			IF @ActualIN <= dtTimeFrom THEN
				SET @otStart = dtTimeFrom;
			ELSEIF @ActualIN > dtTimeFrom THEN
				SET @otStart = @ActualIN;
			END IF;
			
			IF @ActualOUT >= dtTimeTo THEN
				SET @otEnd = dtTimeTo;
			ELSEIF @ActualOUT < dtTimeTo THEN
				SET @otEnd = @ActualOUT;
			END IF;
			
			SET @nHours = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
		END IF;
		
		INSERT INTO `logtable` (`log`) SELECT CONCAT('user_id=',nUserID,', date=',dtDate,', ot_hrs=',IFNULL(@nHours,0));
		UPDATE ww_time_record_summary SET ot = ot + IFNULL(@nHours,0) WHERE user_id = nUserID AND `date` = dtDate;
	END LOOP;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_process_summary_ot_3` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_process_summary_ot_3` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_process_summary_ot_3`( 
	IN periodid INT(11),
	IN puserid INT(11)	
	)
BEGIN
	SET @nCompID = 0;
	SET @dtPay = '0000-00-00';	
	SELECT company_id, payroll_date INTO @nCompID, @dtPay FROM ww_time_period
	WHERE period_id = periodid;
	
	SET @nPeriod = periodid; -- time_get_previous_period(periodid);
	SET @dtFrom = get_time_period_from(@nPeriod, @nCompID);
	SET @dtTo = get_time_period_to(@nPeriod, @nCompID);
	
	BEGIN
		DECLARE done TINYINT(1) DEFAULT 0;
		DECLARE emp_id INT(11);
		DECLARE frm_id INT(11);
		DECLARE dtApprv DATETIME;
		DECLARE dtTimeFrm DATETIME;
		DECLARE dtTimeTo DATETIME;
		DECLARE dtDate DATE;
		DECLARE paydate DATE;
		DECLARE comp_id INT(11);
		DECLARE period_id INT(11);
		DECLARE overtime CURSOR FOR
			SELECT a.`user_id`, a.`forms_id`, DATE(a.`date_approved`), b.`time_from`, b.`time_to`, b.`date`, @nCompID, @dtPay, @nPeriod
			FROM ww_time_forms a
			LEFT JOIN ww_time_forms_date b ON a.forms_id = b.forms_id
			LEFT JOIN ww_users_profile up ON up.`user_id` = a.`user_id`
			WHERE a.`deleted` = 0 AND b.`deleted` = 0
				AND a.`form_status_id` = 6 AND a.`date_approved` IS NOT NULL AND a.`form_code` = 'OT'
				AND IF(puserid=0,1,a.`user_id`=puserid)
				AND up.company_id = @nCompID
				AND b.`date` BETWEEN @dtFrom AND @dtTo
				AND date(a.`date_approved`) > time_get_cut_off( b.`date`, @nCompID )
			UNION
			SELECT tfb.`user_id`, tf.`forms_id`, DATE(tf.`created_on`), tfd.`time_from`, tfd.`time_to`, tfd.`date`, @nCompID, @dtPay, @nPeriod
			FROM ww_time_forms tf, ww_time_forms_date tfd, ww_time_forms_blanket tfb, ww_users_profile up
			WHERE tf.`forms_id` = tfd.`forms_id` AND tf.`deleted` = 0 AND tfd.`deleted` = 0
				AND tf.`forms_id` = tfb.`forms_id` AND tfb.deleted = 0
				and tfb.user_id = up.user_id
				AND if(puserid=0,1,tfb.user_id=puserid) AND tfd.date BETWEEN @dtFrom AND @dtTo 
				AND DATE(tf.created_on) > time_get_cut_off( tfd.date, @nCompID)
				AND tf.`form_code` = 'OT'
				and up.company_id = @nCompID;
		DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
		
		OPEN overtime;
		
		myLoop: LOOP
			FETCH overtime INTO emp_id, frm_id, dtApprv, dtTimeFrm, dtTimeTo, dtDate, comp_id,  paydate, period_id ;
			
			IF done THEN
			    CLOSE overtime;
			    LEAVE myLoop;
			END IF;
			-- get shift
			DELETE FROM ww_time_record_process WHERE record_id = frm_id AND user_id = emp_id ;
			
			SET @ActualIN = "";
			SET @ActualOUT = "";
			SET @otStart = "";
			SET @otEnd = "";
			SET @nHourlyRate = 0;
			SET @nSalary = 0;
			SET @nTotalDays = 0;
			SELECT AES_DECRYPT(salary, encryption_key()), total_year_days
			INTO @nSalary, @nTotalDays
			FROM ww_payroll_partners WHERE user_id = emp_id;
			
			SET @nHourlyRate = ( @nSalary / ( @nTotalDays / 12 ) ) / 8;
			
			SET @sDayType = get_time_daytype(emp_id, dtDate);
			SET @ShiftID = 0;
			SET @ShiftID = time_get_shift(emp_id, dtDate);
			-- get sched out
			SET @SchedOut = CONCAT(dtDate, ' ', time_get_sched_out( @ShiftID ) );
			SET @SchedIn = CONCAT(dtDate, ' ', time_get_sched_in( @ShiftID ) );
			-- get current ND set up
			SET @curStartND = CONCAT(dtDate, ' ', time_get_nd_start( @ShiftID, comp_id ) );
			SET @curEndND = CONCAT( ADDDATE( dtDate, 1 ), ' ', time_get_nd_end( @ShiftID, comp_id ) );
			-- get previous ND set up
			SET @prevStartND = CONCAT( ADDDATE( dtDate, -1 ), ' ', time_get_nd_start( @ShiftID, comp_id ) );
			SET @prevEndND = CONCAT( dtDate, ' ', time_get_nd_end( @ShiftID, comp_id ) );
			-- get actual time in / out
			SET @ActualIN = time_get_time_in( emp_id, dtDate);
			SET @ActualOUT = time_get_time_out( emp_id, dtDate);
			
			SET @OrigPaydate = '0000-00-00';
			SET @dtPaydate = '0000-00-00';
			SET @latefile = 0;
			SET @cutoff = time_get_cut_off( dtDate, comp_id );
			IF dtApprv > @cutoff THEN
				-- set original payroll date
				SET @latefile = 1;
				SET @OrigPaydate = time_get_payroll_date( dtDate, comp_id );
				SET @dtPaydate = time_get_payroll_date( dtApprv, comp_id );
			ELSE 
				SET @latefile = 0;
				SET @dtPaydate = paydate;
				SET @OrigPaydate = paydate;
			END IF;
			
			-- start of regular 
			IF @sDayType = 'REGULAR' THEN
				-- pre shift ot
				IF dtTimeFrm < @SchedIn THEN
					
					IF dtTimeTo >= @SchedIn THEN
						SET @otEnd =  @SchedIn;
					END IF;
					IF dtTimeTo < @SchedIn THEN
						SET @otEnd =  dtTimeTo;
					END IF;
					
					SET @otStart = dtTimeFrm;
					IF dtTimeFrm < @ActualIN THEN
						SET @otStart = @ActualIN;
					END IF;
					
					SET @otUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = 'REGOT';
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
					-- check if has ND
					IF @ActualIN < @prevEndND THEN
						IF dtTimeFrm <= @prevStartND THEN
							SET @ndStart = @prevStartND;
						END IF;
						IF dtTimeFrm > @prevStartND THEN
							SET @ndStart = dtTimeFrm;
						END IF;
						SET @ndStart = @ActualIN;
						IF @ActualIN < dtTimeFrm THEN
							SET @ndStart = dtTimeFrm;
						END IF;
						SET @ndEnd = @prevEndND;
						IF dtTimeTo < @prevEndND THEN
							SET @ndEnd = dtTimeTo;
						END IF;
						
						SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );					
						IF @ndUnit > 0 THEN
							SET @tran_code = '';
							SET @tran_code = 'REGOT_ND';
							SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
							CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
						END IF;
					END IF;
				-- after shift ot
				ELSEIF dtTimeFrm > @SchedIn THEN
					IF dtTimeFrm <= @SchedOut THEN
						SET @otStart = @SchedOut;
					END IF;
					IF dtTimeFrm > @SchedOut THEN
						SET @otStart = dtTimeFrm;
					END IF;
					
					SET @otEnd = dtTimeTo;
					IF dtTimeTo > @ActualOUT THEN	
						SET @otEnd = @ActualOUT;
					END IF;
					
					SET @otUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = 'REGOT';
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
					-- check if has ND
					IF @ActualOUT > @curStartND THEN
						IF dtTimeTo >= @curEndND THEN
							SET @ndEnd = @curEndND;
						END IF;
						IF dtTimeTo < @curEndND THEN
							SET @ndEnd = dtTimeTo;
						END IF;
						IF dtTimeTo > @ActualOUT THEN
							SET @ndEnd = @ActualOUT;
						END IF;
						
						IF dtTimeFrm <= @curStartND THEN
							SET @ndStart = @curStartND;
						END IF;
						IF dtTimeFrm > @curStartND THEN
							SET @ndStart = dtTimeFrm;
						END IF;
						
						SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
						IF @ndUnit > 0 THEN
							SET @tran_code = '';
							SET @tran_code = 'REGOT_ND';
							SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
							CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
						END IF;
					END IF;
				END IF;
				-- end of regular
			
			ELSE 
				IF @sDayType = 'RESTDAY' THEN
					SET @trans = 'RDOT';
				ELSEIF @sDayType = 'LEGAL' THEN
					IF @ShiftID = 1 THEN
						SET @trans = 'LEGRDOT';
					ELSE		
						SET @trans = 'LEGOT';
					END IF;
				ELSEIF @sDayType = 'SPECIAL' THEN
					IF @ShiftID = 1 THEN
						SET @trans = 'SPERDOT';
					ELSE
						SET @trans = 'SPEOT';
					END IF;
				ELSEIF @sDayType = 'DOUBLE' THEN
					IF @ShiftID = 1 THEN
						SET @trans = 'DOBRDOT';
					ELSE
						SET @trans = 'DOBOT';
					END IF;
				END IF;
				
				IF @ActualIN <= dtTimeFrm THEN
					SET @otStart = dtTimeFrm;
				ELSEIF @ActualIN > dtTimeFrm THEN
					SET @otStart = @ActualIN;
				END IF;
				
				IF @ActualOUT >= dtTimeTo THEN
					SET @otEnd = dtTimeTo;
				ELSEIF @ActualOUT < dtTimeTo THEN
					SET @otEnd = @ActualOUT;
				END IF;
				
				SET @Unit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
				
				IF @Unit > 8 THEN
					SET @otUnit = 8.00;
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = @trans;
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
					SET @otUnitExcess = @Unit - 8.00;
					IF @otUnitExcess > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_EXCESS');
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnitExcess, @ot_rate, period_id);
					END IF;
				ELSE 
					SET @otUnit = @Unit;
					IF @otUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = @trans;
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
					END IF;
				END IF;
				-- check if first 8 hours has ND
				-- ND on the Ot Start
				IF @otStart < @prevEndND THEN
					SET @ndStart = @otStart;
					SET @ndEnd = @prevEndND;
					SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_ND');
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;
				END IF;
				-- ND on the First 8 Hrs
				SET @firstEight = ADDTIME( @otStart, '08:00:00' );
				
				IF @curStartND < @firstEight THEN
					SET @ndStart = @curStartND;
					SET @ndEnd = @firstEight;
					IF @firstEight > @otEnd THEN
						SET @ndEnd = @otEnd;
					END IF;
					SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_ND');
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;
				END IF;
				-- ND on the Remaining Hrs
				IF @firstEight < @otEnd THEN
					IF @firstEight > @curStartND THEN
						SET @ndStart = @firstEight;
					ELSE 
						SET @ndStart = @curStartND;
					END IF;
					
					SET @ndEnd = @otEnd;
					IF @otEnd > @curEndND THEN
						SET @ndEnd = @curEndND;
					END IF;
					IF @ndEnd > @ndStart THEN
						SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					END IF;		
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_ND_EXCESS');
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, @nHourlyRate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;	
				END IF;			
			END IF;		
		END LOOP;
		END;
	END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_reminder` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_reminder` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_reminder`()
BEGIN
    
    DECLARE done TINYINT(1) DEFAULT 0;
    DECLARE done_e TINYINT(1) DEFAULT 0;
    DECLARE company VARCHAR(64);
    DECLARE email VARCHAR(128);
    
    DECLARE users_email CURSOR FOR
    SELECT u.`email`
    FROM `users` u
    JOIN `ww_roles` r ON r.`role_id`=u.`role_id`
    WHERE u.active=1 AND u.deleted=0 AND r.`role`='HR Timekeeper';
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    SET @rec = 0;
    SET @emails = '';
    SET @system_fromaddress = (SELECT `value` FROM `ww_config` WHERE `key`='from_address' LIMIT  1);
    
    SELECT COUNT(uc.company) INTO @rec
    FROM `ww_users_company` uc
    INNER JOIN `ww_time_period` tp ON 
       tp.`company_id`=uc.`company_id` AND tp.`deleted`=0 AND
       CURDATE() BETWEEN tp.`date_from` AND tp.`date_to`
    WHERE uc.`deleted`=0 AND tp.`payroll_date` IS NULL;
          
    
    IF @rec > 0 THEN   
       OPEN users_email;
       REPEAT
          FETCH users_email INTO email;
          IF NOT done THEN
             SET @emails = CONCAT(@emails,email,',');
          END IF;
       UNTIL done END REPEAT;
       CLOSE users_email;
          
       IF RIGHT(@emails,1)=',' THEN
          SET @emails = MID(@emails,1,LENGTH(@emails)-1);
       END IF;
	   
	   
       IF @emails <> '' THEN
          SET @emailto = '';
          SET @emailsubject = '';
          SET @emailbody = '';
          SET @bcc = @system_fromaddress;
          SET @url = '';
       
          SELECT `subject`,`body` INTO @emailsubject, @emailbody
          FROM `ww_system_template`
          WHERE `code` = 'TIME-PERIOD-REMINDER' AND deleted=0 LIMIT 1;
          IF @emailsubject <> '' THEN
             -- {{link}}
             SET @url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
	         IF RIGHT(TRIM(@url),1) <> '/' THEN
	            SET @url = CONCAT(TRIM(@url),'/');
	         END IF;
	         
             SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='dtr_processing' LIMIT 1);
             SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
	   
             SET @emailbody = REPLACE(@emailbody, '{{listname}}', @rec);
             SET @emailbody = REPLACE(@emailbody, '{{link}}', CONCAT(@url,@route));
             SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
             
             INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`,`bcc`)
             SELECT @emails,@emailsubject,@emailbody,@bcc;
          END IF; -- @emailsubject
          
       END IF; -- @emails
       
    END IF; -- @rec
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_set_project` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_set_project` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_set_project`( in intUser int(11), IN dtStart DATE, IN dtEnd DATE, IN dtPay DATE )
BEGIN	
	declare intEmp int(11);
	declare dtProjectFrom date;
	declare dtProjectTO date;
	declare intProject int(11);
	declare intDefaultProject int(11);
	declare proj_done TINYINT(1) DEFAULT 0;
	DECLARE movement CURSOR FOR
		SELECT ma.`user_id`, ma.`effectivity_date`, STR_TO_DATE(mat.`to_name`, '%M %d,%Y'), mat.`to_id`, up.project_id, dtStart, dtEnd, dtPay
		FROM ww_partners_movement m 
		LEFT JOIN ww_partners_movement_action ma ON m.`movement_id` = ma.`movement_id`
		LEFT JOIN ww_partners_movement_action_transfer mat ON ma.`movement_id` = mat.`movement_id` AND ma.`action_id` = mat.`action_id`
		left join ww_users_profile up on ma.user_id = up.user_id
		WHERE field_name IN ('end_date') AND m.`status_id` = 3
		AND ma.movement_id = `get_project_movement`( intUser, dtStart, dtEnd )
		AND ma.`user_id` = intUser
		AND ( ma.`effectivity_date` BETWEEN dtStart AND dtEnd
		OR STR_TO_DATE(mat.`to_name`, '%M %d,%Y') BETWEEN dtStart AND dtEnd );
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET proj_done = 1;
	
	OPEN movement;
	myMovement: LOOP
		FETCH movement INTO intEmp, dtProjectFrom, dtProjectTO, intProject, intDefaultProject, dtStart, dtEnd, dtPay;
		
		IF proj_done THEN
		    CLOSE movement;
		    LEAVE myMovement;
		END IF;
		-- set project base on movement
		UPDATE ww_time_record_summary SET project_id = intProject WHERE user_id = intEmp AND `date` BETWEEN dtProjectFrom AND dtProjectTO AND payroll_date = dtPay;
		
	END LOOP;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_summary` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_summary` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_summary`( IN periodid INT(11), IN puserid INT(11) )
BEGIN
	
	DECLARE summarydone TINYINT(1) DEFAULT 0;
	DECLARE employee_id INT(11);
	DECLARE comp_id INT(11);
	DECLARE rate_type INT(11);
	DECLARE salary DECIMAL(12,2);
	DECLARE dates DATE;
	DECLARE paydate DATE;
	DECLARE rec_id INT(11);
	DECLARE absent TINYINT(1);
	DECLARE lwp DECIMAL(5,2);
	DECLARE lwop DECIMAL(5,2);
	DECLARE late DECIMAL(5,2);
	DECLARE undertime DECIMAL(5,2);
	DECLARE nd DECIMAL(5,2);
	DECLARE ot DECIMAL(5,2);
	DECLARE total_days DECIMAL(5,2);
	DECLARE day_type VARCHAR(32);
	DECLARE lates_exemption_val DECIMAL(5,2);
	
	DECLARE dtr CURSOR FOR
		SELECT p.`user_id`, u.`company_id`, p.`payroll_rate_type_id`, AES_DECRYPT( p.`salary`,encryption_key() ) AS salary ,s.`date`, s.`payroll_date`, s.`record_id`, 
			s.`absent`, s.`lwp`, s.`lwop`, s.`late`, s.`undertime`, s.nd, s.`ot`, p.`total_year_days`, s.`day_type`, lates_exemption, periodid
		FROM ww_time_record_summary s
		INNER JOIN ww_payroll_partners p ON s.`user_id` = p.`user_id`
		INNER JOIN ww_time_period t ON t.`payroll_date` = s.`payroll_date`
		INNER JOIN ww_users_profile u ON p.`user_id` = u.`user_id`
		INNER JOIN ww_partners pp ON u.`user_id` = pp.`user_id`
		LEFT JOIN ww_payroll_late_exemption ple ON pp.`employment_type_id` = ple.`employment_type_id`		
		WHERE s.`date` BETWEEN t.`date_from` AND t.`date_to` 
			AND IF(puserid=0,1,p.`user_id`=puserid) AND t.`period_id` = periodid AND t.`company_id` = u.`company_id`;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET summarydone = 1;
	
	OPEN dtr;
	
	myLoop: LOOP
		FETCH dtr INTO employee_id, comp_id, rate_type, salary, dates, paydate, rec_id, absent, lwp, lwop, late, undertime, nd, ot, total_days, day_type, lates_exemption_val, periodid;
		
		IF summarydone THEN
		    CLOSE dtr;
		    LEAVE myLoop;
		END IF;
		
		DELETE FROM ww_time_record_process WHERE user_id = employee_id AND `date` = dates AND payroll_date = paydate;
		
		SET @workhrs = 0;
		SET @workhrs = time_period_process_workhrs(employee_id, dates);
		
		SET @hourly_rate = 0;
		IF rate_type = 6 THEN
			SET @hourly_rate = salary / @workhrs;
		else
			SET @hourly_rate = ( salary / ( total_days / 12 ) ) / @workhrs;
		END IF;
			
		-- SET @hourly_rate = ( salary / ( total_days / 12 ) ) / @workhrs;
		SET @OrigPaydate = '0000-00-00';
		SET @latefile = 0;
		
		IF absent > 0 THEN 
			
			SET @tran_code = 'ABSENCES';
			SET @qty = 0;
			SET @qty = absent * @workhrs;
			
			CALL sp_time_period_summary_insert( rec_id, employee_id, dates, paydate, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, periodid);
			
		END IF;
		
		-- payment for late approved leaves
		IF lwp > 0 THEN
			CALL sp_time_period_summary_lwp( employee_id, comp_id, dates, @hourly_rate, paydate, periodid );
		END IF;
		
		IF lwop > 0 THEN
			SET @tran_code = 'LWOP';
			SET @qty = 0;
			SET @qty = lwop * 8; -- @workhrs;
			
			CALL sp_time_period_summary_insert( rec_id, employee_id, dates, paydate, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, periodid);
			
		END IF;
			
		IF late > ifnull(lates_exemption_val,0) THEN
			SET @tran_code = 'DEDUCTION_LATE';
			SET @qty = 0;
			SET @qty = late ;
			
			CALL sp_time_period_summary_insert( rec_id, employee_id, dates, paydate, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, periodid);
			
		END IF;
		
		IF undertime > 0 THEN
			SET @tran_code = 'DEDUCTION_UNDERTIME';
			SET @qty = 0;
			SET @qty = undertime ;
			
			CALL sp_time_period_summary_insert( rec_id, employee_id, dates, paydate, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, periodid);
		END IF;
		
		IF nd > 0 THEN
			SET @tran_code = 'REGND';
			SET @qty = 0;
			SET @qty = nd;
			IF day_type = 'REGULAR' THEN
				CALL sp_time_period_summary_insert( rec_id, employee_id, dates, paydate, @OrigPaydate, @latefile, @tran_code, @qty, @hourly_rate, periodid);
			END IF;
		END IF;
				
		IF ot > 0 AND absent = 0 THEN 
			CALL sp_time_period_summary_ot( employee_id, comp_id, dates, day_type, @hourly_rate, paydate, periodid );
		END IF;
		
	END LOOP;
			
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_summary_insert` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_summary_insert` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_summary_insert`(
		in rec_id int(11), 
		in employee_id int(11), 
		in dates date,
		in paydate date, 
		in orig_paydate date,
		in lt_file tinyint(1),
		in tran_code varchar(32), 
		in qty decimal(5,2), 
		in hourly_rate decimal(5,2),
		IN period_id INT(11)
	)
BEGIN	
	SET @tran_code = '';
	set @tran_id = 0;
	set @tran_type_id = 0;
	set @frmCode = '';
	select form_code into @frmCode from ww_time_forms where forms_id = rec_id LIMIT 1;
	if @frmCode = 'OT' and lt_file = 1 then
		SELECT transaction_code, transaction_id , transaction_type_id
		INTO @tran_code, @tran_id, @tran_type_id
		FROM ww_payroll_transaction WHERE deleted=0 AND transaction_code = concat(tran_code, '_ADJ' ) LIMIT 1;
	else
		SELECT transaction_code, transaction_id , transaction_type_id
		INTO @tran_code, @tran_id, @tran_type_id
		FROM ww_payroll_transaction WHERE deleted=0 AND transaction_code = tran_code LIMIT 1;
	END IF;
	
	DELETE FROM ww_time_record_process WHERE user_id = employee_id AND transaction_code = tran_code AND `date` = dates AND payroll_date = paydate;
	
	INSERT INTO ww_time_record_process
            ( `record_id`, `user_id`, `time_period_id`, `date`, `payroll_date`, `original_payroll_date`, `latefile`, `transaction_id`, `transaction_code`, `transaction_type_id`, `quantity`, `unit_rate`)
	VALUES ( rec_id, employee_id, period_id, dates, paydate, orig_paydate, lt_file, @tran_id, @tran_code, @tran_type_id, qty, hourly_rate);
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_summary_lwp` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_summary_lwp` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_summary_lwp`(
	IN employee_id INT(11),
	IN comp_id INT(11),
	IN dates DATE,
	IN hourly_rate DECIMAL(12,2), 
	IN paydate DATE,
	IN period_id INT(11)
    )
BEGIN
	DECLARE done TINYINT(1) DEFAULT 0;
	DECLARE nFrmID INT(11);
	DECLARE sFrmCode VARCHAR(30);
	DECLARE nQty DECIMAL(5,2);
	DECLARE dtApprv DATETIME;
	DECLARE nEmpID INT(11);
	DECLARE dtDate DATE;
	DECLARE nCompID INT(11);
	DECLARE nHourlyRate DECIMAL(12,2);
	DECLARE dtPaydate DATE;
	DECLARE lvs CURSOR FOR
		SELECT a.user_id,a.`forms_id`, a.`form_code`, ( b.`day` * 8 ), a.`date_approved`, b.`date`, comp_id, hourly_rate, paydate, period_id
		FROM ww_time_forms a, ww_time_forms_date b, ww_time_form c
		WHERE a.forms_id = b.forms_id AND a.`deleted` = 0 AND b.`deleted` = 0
			AND a.`form_status_id` = 6 AND a.`date_approved` IS NOT NULL 
			AND a.`user_id` = employee_id AND dates BETWEEN `date_from` AND `date_to` 
			AND b.date = dates AND c.form_id = a.form_id AND c.is_leave = 1 AND c.form_code != 'LWOP';
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
		
	OPEN lvs;
	myLoop: LOOP
		
		FETCH lvs INTO nEmpID, nFrmID, sFrmCode, nQty, dtApprv, dtDate, nCompID, nHourlyRate, dtPaydate, period_id;
		
		IF done THEN
		    CLOSE lvs;
		    LEAVE myLoop;
		END IF;
		
		SET @cutoff = '0000-00-00';
		SET @dtOrigPaydate = '0000-00-00';
		SET @sTranCode = '';
		set @dtPayrollDate = '0000-00-00';
		-- check if within the period
		-- SET @cutoff = time_get_cut_off( dtDate, comp_id );
		-- IF DATE(dtApprv) > @cutoff THEN
		SET @nLatefile = 0;
		SET @sTranCode = sFrmCode;
		set @dtPayrollDate = dtPaydate;
		delete from ww_time_record_process where user_id = nEmpID and `date` = dtDate and transaction_code = @sTranCode and payroll_date = @dtPayrollDate and original_payroll_date = @dtOrigPaydate;
		CALL sp_time_period_summary_insert( nFrmID, nEmpID, dtDate, @dtPayrollDate, @dtOrigPaydate, @nLatefile, @sTranCode, nQty, nHourlyRate, period_id);
			
	END LOOP;
	
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_summary_ot` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_summary_ot` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_summary_ot`(
	IN employee_id INT(11),
	IN comp_id INT(11),
	IN dates DATE,
	IN day_type VARCHAR(32),
	IN hourly_rate DECIMAL(12,2),
	IN paydate DATE,
	IN period_id INT(11)
    )
BEGIN
	DECLARE doneOT TINYINT(1) DEFAULT 0;
	DECLARE frm_id INT(11);
	DECLARE hrs DECIMAL(5,2);
	DECLARE otBreak DECIMAL(5,2) default 0.00;
	DECLARE dtApprv DATETIME;
	DECLARE dtTimeFrm DATETIME;
	DECLARE dtTimeTo DATETIME;
	DECLARE emp_id INT(11);
	DECLARE dtDate DATE;	
	DECLARE overtime CURSOR FOR
		SELECT a.`user_id`, a.`forms_id`, b.`hrs`, DATE(a.`date_approved`), b.`time_from`, b.`time_to`, b.`date`, comp_id, day_type, hourly_rate, paydate, period_id
		FROM ww_time_forms a, ww_time_forms_date b 
		WHERE a.forms_id = b.forms_id AND a.`deleted` = 0 AND b.`deleted` = 0
			AND a.`form_status_id` = 6 AND ( a.`date_approved` IS NOT NULL AND DATE(a.date_approved) <= time_get_cut_off( dates, comp_id ) )
			AND a.`user_id` = employee_id  AND dates BETWEEN DATE_SUB(`date_from`, INTERVAL 1 DAY) AND `date_to` 
			AND b.date = dates AND a.`form_code` = 'OT'
		UNION
		SELECT tfb.`user_id`, tf.`forms_id`, tfd.`hrs`, DATE(tf.`created_on`), tfd.`time_from`, tfd.`time_to`, tfd.`date`, comp_id, day_type, hourly_rate, paydate, period_id
		FROM ww_time_forms tf, ww_time_forms_date tfd, ww_time_forms_blanket tfb
		WHERE tf.`forms_id` = tfd.`forms_id` AND tf.`deleted` = 0 AND tfd.`deleted` = 0
			AND tf.`forms_id` = tfb.`forms_id` AND tfb.deleted = 0
			AND tfb.`user_id` = employee_id AND dates BETWEEN DATE_SUB(tf.`date_from`, INTERVAL 1 DAY) AND tf.`date_to` AND
			(tf.created_on IS NOT NULL AND DATE(tf.created_on) <= time_get_cut_off( dates, comp_id)) 
			AND tfd.`date` = dates
			AND tf.`form_code` = 'OT';
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET doneOT = 1;
	OPEN overtime;
	myLoop: LOOP
		FETCH overtime INTO emp_id, frm_id, hrs, dtApprv, dtTimeFrm, dtTimeTo, dtDate, comp_id, day_type, hourly_rate, paydate, period_id;
		
		IF doneOT = 1 THEN
		    LEAVE myLoop;
		END IF;
		
		SET @ActualIN = "";
		SET @ActualOUT = "";
		SET @otStart = "";
		SET @otEnd = "";
		
		SET @otUnit = 0;
		SET @otUnitExcess = 0;
		SET @Unit = 0;
		SET @ndUnit = 0;
		
		-- get shift
		SET @ShiftID = 0;
		SET @ShiftID = time_get_shift(emp_id, dtDate);
		-- get sched out
		SET @SchedOut = CONCAT(dtDate, ' ', time_get_sched_out( @ShiftID ) );
		SET @SchedIn = CONCAT(dtDate, ' ', time_get_sched_in( @ShiftID ) );
		-- get current ND set up
		SET @curStartND = CONCAT(dtDate, ' ', time_get_nd_start( @ShiftID, comp_id ) );
		SET @curEndND = CONCAT( ADDDATE( dtDate, 1 ), ' ', time_get_nd_end( @ShiftID, comp_id ) );
		-- get previous ND set up
		SET @prevStartND = CONCAT( ADDDATE( dtDate, -1 ), ' ', time_get_nd_start( @ShiftID, comp_id ) );
		SET @prevEndND = CONCAT( dtDate, ' ', time_get_nd_end( @ShiftID, comp_id ) );
		-- get actual time in / out
		SET @ActualIN = time_get_time_in( emp_id, dtDate);
		SET @ActualOUT = time_get_time_out( emp_id, dtDate);
		
		SET @OrigPaydate = '0000-00-00';
		SET @dtPaydate = '0000-00-00';
		SET @latefile = 0;
		SET @cutoff = time_get_cut_off( dtDate, comp_id );
		
		IF dtApprv > @cutoff THEN
			-- set original payroll date
			SET @latefile = 1;
			SET @OrigPaydate = paydate;
			SET @dtPaydate = time_get_payroll_date( dtApprv, comp_id );
		ELSE 
			SET @latefile = 0;
			SET @dtPaydate = paydate;
			SET @OrigPaydate = paydate;
		END IF;
		
		-- start of regular 
		IF day_type = 'REGULAR' THEN
			-- pre shift ot
			IF dtTimeFrm < @SchedIn THEN
				
				IF dtTimeTo >= @SchedIn THEN
					SET @otEnd =  @SchedIn;
				END IF;
				IF dtTimeTo < @SchedIn THEN
					SET @otEnd =  dtTimeTo;
				END IF;
				
				SET @otStart = dtTimeFrm;
				IF dtTimeFrm < @ActualIN THEN
					SET @otStart = @ActualIN;
				END IF;
				
				SET @otUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
				if @otUnit > 0 then
					SET otBreak = get_overtime_break( day_type, @otUnit, comp_id );
					SET @otUnit = @otUnit - otBreak;				
				end if;
				
				IF @otUnit > 0 THEN
					SET @tran_code = '';
					SET @tran_code = 'REGOT';
					SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, hourly_rate );
					CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
				END IF;
				-- check if has ND
				IF @ActualIN < @prevEndND THEN
					IF dtTimeFrm <= @prevStartND THEN
						SET @ndStart = @prevStartND;
					END IF;
					IF dtTimeFrm > @prevStartND THEN
						SET @ndStart = dtTimeFrm;
					END IF;
					SET @ndStart = @ActualIN;
					IF @ActualIN < dtTimeFrm THEN
						SET @ndStart = dtTimeFrm;
					END IF;
					SET @ndEnd = @prevEndND;
					IF dtTimeTo < @prevEndND THEN
						SET @ndEnd = dtTimeTo;
					END IF;
					
					SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );					
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = 'REGOT_ND';
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, hourly_rate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;
				END IF;
			-- after shift ot
			ELSEIF dtTimeFrm > @SchedIn THEN
				IF dtTimeFrm <= @SchedOut THEN
					SET @otStart = @SchedOut;
				END IF;
				IF dtTimeFrm > @SchedOut THEN
					SET @otStart = dtTimeFrm;
				END IF;
				
				SET @otEnd = dtTimeTo;
				IF dtTimeTo > @ActualOUT THEN	
					SET @otEnd = @ActualOUT;
				END IF;
				
				SET @otUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
				SET @otUnit = @otUnit - `get_overtime_break`( day_type, @otUnit, comp_id ) ;
				IF @otUnit > 0 THEN
					SET @tran_code = '';
					SET @tran_code = 'REGOT';
					SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, hourly_rate );
					CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
				END IF;
				-- check if has ND
				IF @ActualOUT > @curStartND THEN
					IF dtTimeTo >= @curEndND THEN
						SET @ndEnd = @curEndND;
					END IF;
					IF dtTimeTo < @curEndND THEN
						SET @ndEnd = dtTimeTo;
					END IF;
					IF dtTimeTo > @ActualOUT THEN
						SET @ndEnd = @ActualOUT;
					END IF;
					
					IF dtTimeFrm <= @curStartND THEN
						SET @ndStart = @curStartND;
					END IF;
					IF dtTimeFrm > @curStartND THEN
						SET @ndStart = dtTimeFrm;
					END IF;
					
					SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = 'REGOT_ND';
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, hourly_rate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;
				END IF;
			END IF;
			-- end of regular
		
		ELSE 
			IF day_type = 'RESTDAY' THEN
				SET @trans = 'RDOT';
			elseIF day_type = 'OFF' THEN
				SET @trans = 'DOFF';				
			ELSEIF day_type = 'LEGAL' THEN
				IF @ShiftID = 1 THEN
					SET @trans = 'LEGRDOT';
				ELSE		
					SET @trans = 'LEGOT';
				END IF;
			ELSEIF day_type = 'SPECIAL' THEN
				IF @ShiftID = 1 THEN
					SET @trans = 'SPERDOT';
				ELSE
					SET @trans = 'SPEOT';
				END IF;
			ELSEIF day_type = 'DOUBLE' THEN
				IF @ShiftID = 1 THEN
					SET @trans = 'DOBRDOT';
				ELSE
					SET @trans = 'DOBOT';
				END IF;
			END IF;
			
			IF @ActualIN <= dtTimeFrm THEN
				SET @otStart = dtTimeFrm;
			ELSEIF @ActualIN > dtTimeFrm THEN
				SET @otStart = @ActualIN;
			END IF;
			SET @otStart = dtTimeFrm;
			
			IF @ActualOUT >= dtTimeTo THEN
				SET @otEnd = dtTimeTo;
			ELSEIF @ActualOUT < dtTimeTo THEN
				SET @otEnd = @ActualOUT;
			END IF;
			SET @otEnd = dtTimeTo;
			
			SET @Unit = 0.00;
			SET @Unit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @otEnd, @otStart ) ) / 3600 ), 2 );
			SET @Unit = @Unit - `get_overtime_break`( day_type, @Unit, comp_id ) ;
			IF @Unit > 8 THEN
				SET @otUnit = 8.00;
				IF @otUnit > 0 THEN
					SET @tran_code = '';
					SET @tran_code = @trans;
					SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, hourly_rate );
					CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
				END IF;
				SET @otUnitExcess = @Unit - 8.00;
				IF @otUnitExcess > 0 THEN
					SET @tran_code = '';
					SET @tran_code = CONCAT(@trans,'_EXCESS');
					SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, hourly_rate );
					CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnitExcess, @ot_rate, period_id);
				END IF;
			ELSE 
				SET @otUnit = @Unit;
				IF @otUnit > 0 THEN
					SET @tran_code = '';
					SET @tran_code = @trans;
					SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, hourly_rate );
					CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @otUnit, @ot_rate, period_id);
				END IF;
			END IF;
			-- check if first 8 hours has ND
			-- ND on the Ot Start
			IF @otStart < @prevEndND THEN
				SET @ndStart = @otStart;
				SET @ndEnd = @prevEndND;
				SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
				
				IF @ndUnit > 0 THEN
					SET @tran_code = '';
					SET @tran_code = CONCAT(@trans,'_ND');
					SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, hourly_rate );
					CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
				END IF;
			END IF;
			-- ND on the First 8 Hrs
			
			SET @firstEight = ADDTIME( @otStart, '08:00:00' );
			IF @curStartND < @firstEight THEN
				SET @ndStart = @curStartND;
				SET @ndEnd = @firstEight;
				IF @firstEight > @otEnd THEN
					SET @ndEnd = @otEnd;
				END IF;
				SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
				IF @ndUnit > 0 THEN
					SET @tran_code = '';
					SET @tran_code = CONCAT(@trans,'_ND');
					SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, hourly_rate );
					CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
				END IF;
			END IF;
			
			-- check if excess hour is between ND Period
			IF @otEnd > @curStartND THEN
				-- ND on the Remaining Hrs
				IF @firstEight < @otEnd THEN
					IF @firstEight > @curStartND THEN
						SET @ndStart = @firstEight;
					ELSE 
						SET @ndStart = @curStartND;
						
					END IF;
					
					SET @ndEnd = @otEnd;
					IF @otEnd > @curEndND THEN
						SET @ndEnd = @curEndND;
					END IF;
					IF @ndEnd > @ndStart THEN
						SET @ndUnit = ROUND( ( TIME_TO_SEC( TIMEDIFF( @ndEnd, @ndStart ) ) / 3600 ), 2 );
					END IF;		
					IF @ndUnit > 0 THEN
						SET @tran_code = '';
						SET @tran_code = CONCAT(@trans,'_ND_EXCESS');
						SET @ot_rate = time_get_ot_rate( @tran_code, comp_id, hourly_rate );
						CALL sp_time_period_summary_insert( frm_id, emp_id, dtDate, @dtPaydate, @OrigPaydate, @latefile, @tran_code, @ndUnit, @ot_rate, period_id);
					END IF;	
				END IF;	
			END IF;		
		END IF;		
	END LOOP myLoop;
	CLOSE overtime;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_period_validate_holiday` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_period_validate_holiday` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_period_validate_holiday`( IN periodid INT(11), IN puserid INT(11) )
BEGIN 
	SET @nCompID = 0;
	SET @dtPay = '0000-00-00';	
	SELECT company_id, payroll_date INTO @nCompID, @dtPay FROM ww_time_period
	WHERE period_id = periodid;
	-- check if present before holiday
	BEGIN
		DECLARE holidaydone TINYINT(1) DEFAULT 0;
		DECLARE nEmpID INT(11);
		DECLARE nRecID INT(11);	
		DECLARE dtDate DATE;
		DECLARE holiday CURSOR FOR
			SELECT t.user_id, t.record_id, t.`date` 
			FROM ww_time_record_summary t
			LEFT JOIN ww_users_profile u ON t.`user_id` = u.`user_id`
			WHERE t.`deleted` = 0 AND u.company_id = @nCompID AND IF(puserid=0,1,t.`user_id`=puserid) 
				AND payroll_date = @dtPay AND day_type = 'LEGAL'
			ORDER BY t.user_id, t.date;
		DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET holidaydone = 1;
			
		OPEN holiday;
		SET @nBCount = 0;
		SET @nBRow = 0;
		SELECT COUNT(t.user_id) INTO @nBCount
			FROM ww_time_record_summary t
			LEFT JOIN ww_users_profile u ON t.`user_id` = u.`user_id`
			WHERE t.`deleted` = 0 AND u.company_id = @nCompID AND IF(puserid=0,1,t.`user_id`=puserid) 
				AND payroll_date = @dtPay AND day_type = 'LEGAL';
		
		myLoop: LOOP
			FETCH holiday INTO nEmpID, nRecID, dtDate;
			
			IF @nBCount = @nBRow THEN
			    CLOSE holiday;
			    LEAVE myLoop;
			END IF;
			
			SET @dtPrevDate = '0000-00-00';
			SET @nPrevAbsent = 0;
			SET @sShift = '';
			 
			SELECT IF(aux_shift_id=0,shift,aux_shift) INTO @sShift FROM ww_time_record WHERE user_id = nEmpID AND `date` = dtDate;
			
			IF UPPER(@sShift) <> 'RESTDAY' THEN
			   SELECT MAX(DATE) INTO @dtPrevDate FROM ww_time_record_summary WHERE user_id = nEmpID AND day_type = 'REGULAR' AND DATE < dtDate;
			   
			   SELECT absent INTO @nPrevAbsent  FROM ww_time_record_summary WHERE `date` = @dtPrevDate AND user_id = nEmpID AND absent = 1;
			   
			   IF @nPrevAbsent > 0 THEN
			      UPDATE ww_time_record_summary SET hrs_rendered = 0 , hrs_actual = 0, absent = 1 WHERE record_id = nRecID;
			   END IF;
			END IF;
			 
			SET @nBRow = @nBRow + 1;
		END LOOP;
	END;
	
	-- check if present after holiday
	/* remove due to the policy: 2015-10-09
	BEGIN
		DECLARE holidaydone TINYINT(1) DEFAULT 0;
		DECLARE nEmpID INT(11);
		DECLARE nRecID INT(11);	
		DECLARE dtDate DATE;
		DECLARE holiday CURSOR FOR
			SELECT t.user_id, t.record_id, t.`date` 
			FROM ww_time_record_summary t
			LEFT JOIN ww_users_profile u ON t.`user_id` = u.`user_id`
			WHERE t.`deleted` = 0 AND u.company_id = @nCompID AND IF(puserid=0,1,t.`user_id`=puserid) 
				AND payroll_date = @dtPay AND day_type = 'LEGAL'
			ORDER BY t.user_id, t.date DESC;
		DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET holidaydone = 1;
			
		OPEN holiday;
		SET @nACount = 0;
		SET @nARow = 0;
		SELECT COUNT(t.user_id) INTO @nACount
			FROM ww_time_record_summary t
			LEFT JOIN ww_users_profile u ON t.`user_id` = u.`user_id`
			WHERE t.`deleted` = 0 AND u.company_id = @nCompID AND IF(puserid=0,1,t.`user_id`=puserid) 
				AND payroll_date = @dtPay AND day_type = 'LEGAL';
		
		myLoop: LOOP
			FETCH holiday INTO nEmpID, nRecID, dtDate;
			
			IF @nACount = @nARow THEN
			    CLOSE holiday;
			    LEAVE myLoop;
			END IF;
			
			SET @dtAfterDate = '0000-00-00';
			SET @nAfterAbsent = 0;
			
			SELECT MIN(DATE) INTO @dtAfterDate FROM ww_time_record_summary WHERE user_id = nEmpID AND day_type = 'REGULAR' AND `date` > dtDate;
			
			SELECT absent INTO @nAfterAbsent  FROM ww_time_record_summary WHERE `date` = @dtAfterDate AND user_id = nEmpID AND absent = 1;
			
			IF @nAfterAbsent > 0 THEN
				UPDATE ww_time_record_summary SET hrs_rendered = 0 , hrs_actual = 0, absent = 1 WHERE record_id = nRecID;
			END IF;
			SET @nARow = @nARow + 1;
		END LOOP;
	END;
	*/
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_populate` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_populate` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_populate`(IN startday DATE, IN endday DATE)
BEGIN
    
    DROP TEMPORARY TABLE IF EXISTS `tmpDays`;
    CREATE TEMPORARY TABLE `tmpDays` ( indate DATE, inweek INTEGER(1) ); 
    SET @done  = 0;
    SET @dates = startday;
    REPEAT
       IF @dates > endday THEN
          SET @done = 1;
       ELSE
          INSERT INTO `tmpDays` SELECT @dates, WEEKDAY(@dates);
       END IF;
       SET @dates = @dates + INTERVAL 1 DAY;
       UNTIL @done END REPEAT;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_insert` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_insert` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_insert`(IN dateid DATE)
BEGIN
   /* This will insert records to ww_time_record and executed thru events
      LAST Change: 2014-02-20 initial
                   2014-02-20 shift name and biometrics
   */
    DECLARE done TINYINT(1) DEFAULT 0;
          
    DECLARE p1 INT(11) DEFAULT 0;    
    DECLARE p2 DATE;
    DECLARE p3 DATE;
    DECLARE p4 INT(11) DEFAULT 0;
    
    -- [1] Prepare dates to be executed
    DECLARE periods CURSOR FOR
    SELECT `period_id`, `date_from`, `date_to`, `company_id`
    FROM `ww_time_period`
    WHERE `deleted` = 0 AND dateid BETWEEN `date_from` AND `date_to`;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    OPEN periods;
    
    REPEAT
       FETCH periods INTO p1, p2, p3, p4;
    
       IF NOT done THEN
          SET p3 = LAST_DAY(p3 + INTERVAL 1 MONTH);
          
          INSERT INTO `ww_system_messages` (msg_code,msg) VALUES ('EVENT_TIME_PERIOD',CONCAT(p2,'-',p3));
          -- [2] Create inclusive dates 
          CALL sp_time_period_populate(p2, p3, p4);
       
          -- [3] Update record so that it will not executed again
          UPDATE `ww_time_period` SET `pop_dates`=2 WHERE `period_id`=p1 LIMIT 1;
          INSERT INTO `ww_system_messages` (msg_code,msg) VALUES ('EVENT_TIME_PERIOD',CONCAT(p2,'-',p3));
       
       END IF;
       
    UNTIL done END REPEAT;
    
    CLOSE periods;
    
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_insert_user` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_insert_user` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_insert_user`()
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE puserid INT(20);
    DECLARE peffectivitydate DATE;
    DECLARE pdate DATE;
    
    DECLARE users CURSOR FOR
       SELECT p.`user_id`, p.`effectivity_date`, COUNT(tr.`date`) days, DATEDIFF(CURDATE(),p.`effectivity_date`)+1 days_no
       FROM `partners` p
       JOIN `ww_time_record` tr ON tr.`user_id` = p.`user_id` AND tr.`date` BETWEEN p.`effectivity_date` AND CURDATE()
       WHERE IFNULL(p.`effectivity_date`,CURDATE()) BETWEEN (CURDATE() - INTERVAL 10 DAY) AND CURDATE()
             AND IFNULL(p.`resigned_date`,'0000-00-00')='0000-00-00'
       GROUP BY p.`user_id`
       HAVING days <> days_no;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    OPEN users;
    
    REPEAT	
       FETCH users INTO puserid, peffectivitydate;
       
       IF NOT done THEN
          SET rec = rec + 1;
          
          SET pdate = LAST_DAY(peffectivitydate + INTERVAL 1 MONTH);
          CALL sp_time_period_populate_user(peffectivitydate, pdate, puserid);
          
       END IF;
       
       UNTIL done END REPEAT;
       
       CLOSE users;
       
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_raw_populate` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_raw_populate` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_raw_populate`(IN FromDate DATE)
BEGIN
	DECLARE summarydone TINYINT(1) DEFAULT 0;
	DECLARE r_id INT(11);
	DECLARE u_id INT(11);
	
	DECLARE dtr CURSOR FOR
		SELECT raw_id,user_id
		FROM ww_time_record_raw		
		WHERE `date` = FromDate;
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET summarydone = 1;
	
	OPEN dtr;
	
	myLoop: LOOP
		FETCH dtr INTO r_id,u_id;
		
		IF summarydone THEN
		    CLOSE dtr;
		    LEAVE myLoop;
		END IF;
		
		UPDATE ww_time_record_raw SET last_processed = NOW() WHERE raw_id = r_id;		
		
	END LOOP;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_raw_process` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_raw_process` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_raw_process`(IN userid INT(11), IN dates DATE, IN checktime DATETIME)
BEGIN
    
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE shift_start TIME;
    DECLARE shift_end TIME;
    
    DECLARE NewTimeIn DATETIME;
    DECLARE NewTimeOut DATETIME;
    DECLARE NewDate DATE;
    DECLARE CurTimeIN DATETIME;
    DECLARE CurTimeOUT DATETIME;
    DECLARE CurShiftID INT(11) DEFAULT 0;
    DECLARE CurShift VARCHAR(32) DEFAULT '';
    
    DECLARE shift_datetime_start DATETIME;
    DECLARE shift_datetime_end DATETIME;
    DECLARE msg VARCHAR(64) DEFAULT '';
    
    
    -- [1] GET AND POPULATE THE NEEDED TIME RECORD
    IF (SELECT COUNT(*) FROM `ww_time_record` WHERE `user_id` = userid AND `date` = dates LIMIT 1) = 0 THEN
       -- better include partners employment date in the future
       CALL sp_time_period_populate_user(dates, dates + INTERVAL 2 DAY, userid);
    END IF;     
    
       
    -- [3] GET CURRENT ATTENDANCE RECORD
    SELECT tr.`record_id`, `time_start`, `time_end`, 
           IF(IFNULL(tr.`aux_shift_id`,0)=0, tr.`shift_id`, tr.`aux_shift_id`), IF(IFNULL(tr.`aux_shift_id`,0)=0, tr.`shift`, tr.`aux_shift`), 
           IFNULL(`time_in`, '0000-00-00 00:00:00'), IFNULL(`time_out`, '0000-00-00 00:00:00') 
    INTO rec, shift_start, shift_end, CurShiftID, CurShift, CurTimeIN, CurTimeOUT
    FROM `ww_time_record` tr
    JOIN `ww_time_shift` ts ON ts.`shift_id`=IF(tr.`aux_shift_id`=0, tr.`shift_id`, tr.`aux_shift_id`)
    WHERE tr.`user_id` = userid AND tr.`date` = dates LIMIT 1;
    
    
    SET @cur_date = DATE(checktime);
    SET @prv_date = @cur_date - INTERVAL 1 DAY;
    SET @nxt_date = IF(shift_start > shift_end, @cur_date + INTERVAL 1 DAY, @cur_date);
    SET shift_datetime_start = CONCAT(@cur_date,' ',shift_start);
    SET shift_datetime_end = CONCAT(@nxt_date,' ',shift_end);
    SET @restday = 0;
    
    
    -- [4] IF RESTDAY/OFF
    IF CurShift = 'RESTDAY' OR CurShift = 'OFF'  THEN
       SET @restday = 1;
    END IF;
    
    
    -- [5] VALIDATE AND UPDATE
    IF rec = 0 THEN
       INSERT INTO `ww_time_record` (`user_id`, `date`, `time_in`) 
       SELECT userid, dates, checktime
       ON DUPLICATE KEY UPDATE `time_in` = checktime, `modified_on`=NOW();
       SET msg = 'Insert 1N';
    ELSE
       BEGIN
       DECLARE prevrec INT(11) DEFAULT 0;
       DECLARE prevshift_start TIME;
       DECLARE prevshift_end TIME;
       DECLARE prevCurTimeIN DATETIME;
       DECLARE prevCurTimeOUT DATETIME;
       DECLARE prevCurShiftID INT(11) DEFAULT 0;
       DECLARE prevCurShift VARCHAR(32) DEFAULT '';
       DECLARE prevshift_datetime_start DATETIME;
       DECLARE prevshift_datetime_end DATETIME;
              
       SELECT tr.`record_id`, `time_start`, `time_end`, 
              IF(IFNULL(tr.`aux_shift_id`,0)=0, tr.`shift_id`, tr.`aux_shift_id`), IF(IFNULL(tr.`aux_shift_id`,0)=0, tr.`shift`, tr.`aux_shift`), 
              IFNULL(`time_in`, '0000-00-00 00:00:00'), IFNULL(`time_out`, '0000-00-00 00:00:00') 
       INTO prevrec, prevshift_start, prevshift_end, prevCurShiftID, prevCurShift, prevCurTimeIN, prevCurTimeOUT
       FROM `ww_time_record` tr
       JOIN `ww_time_shift` ts ON ts.`shift_id`=IF(tr.`aux_shift_id`=0, tr.`shift_id`, tr.`aux_shift_id`)
       WHERE tr.`user_id` = userid AND tr.`date` = @prv_date LIMIT 1;
       
       IF prevrec > 0 THEN
          SET prevshift_datetime_start = CONCAT(@prv_date,' ',prevshift_start);
          SET prevshift_datetime_end = CONCAT(IF(prevshift_start > prevshift_end, @cur_date, @prv_date),' ',prevshift_end);
       END IF;
       SET @bypass = 0;
          
       IF CurTimeIN = '0000-00-00 00:00:00' THEN  -- TIMEIN
          IF prevrec > 0 THEN
             IF prevCurTimeOUT = '0000-00-00 00:00:00' AND checktime <= (shift_datetime_start - INTERVAL 8 HOUR) AND
                (prevCurShift <> 'RESTDAY' AND prevCurShift <> 'OFF') AND (CurShift <> 'RESTDAY' AND CurShift <> 'OFF') THEN -- using 2hrs interval
                IF checktime = CurTimeIN THEN
                   SET msg = CONCAT(msg,'Update bypass Prev OUT');
                   SET @bypass = 1;
                ELSE
		   IF prevCurTimeIN <> '0000-00-00 00:00:00' THEN
                      SET msg = CONCAT(msg,'Update Prev OUT - ');
                      SET @bypass = 1;
                      UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                      WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;
                   ELSE
		      IF checktime < (prevshift_datetime_end + INTERVAL 8 HOUR) THEN
			      SET msg = CONCAT(msg,'Update Prev OUT - ');
			      SET @bypass = 1;
			      UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
			      WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;		      
		      END IF;                      
                   END IF;
                END IF;
             ELSEIF prevCurTimeOUT = '0000-00-00 00:00:00' AND (prevCurShift = 'RESTDAY' OR prevCurShift = 'OFF') THEN -- using 2hrs interval
		IF checktime < (shift_datetime_start - INTERVAL 16 HOUR) AND (CurShift <> 'RESTDAY' AND CurShift <> 'OFF') THEN -- using 24hrs interval from previous shift-start
			SET msg = CONCAT(msg,'Update Prev OUT - ');
			SET @bypass = 1;
			UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
			WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;	  		
		END IF;              
             ELSE
                IF (CurShift = 'RESTDAY' OR CurShift = 'OFF') AND (prevCurShift <> 'RESTDAY' OR prevCurShift <> 'OFF') THEN
                   IF checktime < (prevshift_datetime_end + INTERVAL 8 HOUR) THEN -- using 24hrs interval from previous shift-start
                      SET msg = CONCAT(msg,'Update RESTDAY - ');
                      SET @bypass = 1;
                      UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                      WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;
                   ELSE
                      SET msg = CONCAT(msg,'Update RESTDAY 2 - ');
                      SET @bypass = 1;
                      UPDATE `ww_time_record` SET `time_in` = checktime, `modified_on` = NOW()
                      WHERE `record_id` = rec AND `override` = 0 LIMIT 1;
                   END IF;
                ELSE
		   IF checktime < (prevshift_datetime_end + INTERVAL 8 HOUR) THEN
			SET msg = CONCAT(msg,'Update Prev OUT - ');
			SET @bypass = 1;
			UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
			WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;	  		   
		   END IF;
                END IF;
                IF prevCurTimeOUT <> '0000-00-00 00:00:00' THEN
                   IF prevCurTimeOUT = checktime THEN
                      SET msg = 'Update bypass Prev OUT';
                      SET @bypass = 1;
                   END IF;
                END IF;
             END IF;
          END IF;
          
          IF @bypass = 0 THEN
             IF checktime >= shift_datetime_end THEN
                SET msg = CONCAT(msg,'Update OUT - ');
                UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                WHERE `record_id` = rec AND `override` = 0 LIMIT 1;
             ELSE
                SET msg = CONCAT(msg,'Update IN - ');
                UPDATE `ww_time_record` SET `time_in` = checktime, `modified_on` = NOW()
                WHERE `record_id` = rec AND `override` = 0 LIMIT 1;
             END IF;
          END IF;
          
       ELSE  -- TIMEOUT
	  -- INSERT INTO `logtable` (`log`) VALUES (CONCAT(checktime,' ',shift_datetime_start - INTERVAL 8 HOUR));
          IF prevrec > 0 AND (prevCurShift <> 'RESTDAY' AND prevCurShift <> 'OFF') THEN -- using 2hrs interval
	     IF prevCurTimeIN <> '0000-00-00 00:00:00' AND prevCurTimeOUT = '0000-00-00 00:00:00' THEN
	        IF prevCurShift = 'RESTDAY' AND prevCurShift = 'OFF' THEN
			SET msg = CONCAT(msg,'Update OUT Prev OUT - ');
			SET @bypass = 1;
			UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
			WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;
		ELSEIF checktime < (shift_datetime_start - INTERVAL 8 HOUR) AND checktime > prevCurTimeIN THEN
			SET msg = CONCAT(msg,'Update OUT Prev OUT - ');
			SET @bypass = 1;
			UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
			WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;		
                END IF;
	     ELSE
	        IF checktime < (shift_datetime_start - INTERVAL 8 HOUR) AND checktime > prevCurTimeOUT THEN
		      SET msg = CONCAT(msg,'Update Prev OUT - ');
		      SET @bypass = 1;
		      UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
		      WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;		      
	        END IF;                 
             END IF;
          ELSEIF prevrec > 0 AND (prevCurShift = 'RESTDAY' OR prevCurShift = 'OFF') THEN
	     IF prevCurTimeIN <> '0000-00-00 00:00:00' AND prevCurTimeOUT = '0000-00-00 00:00:00' THEN
                SET msg = CONCAT(msg,'Update OUT Prev OUT - ');
                SET @bypass = 1;
                UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;
	     ELSE
	        IF checktime < (shift_datetime_start - INTERVAL 8 HOUR) THEN
		      SET msg = CONCAT(msg,'Update Prev OUT - ');
		      SET @bypass = 1;
		      UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
		      WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;		      
	        END IF;                 
             END IF;          
          END IF;
          
          IF @bypass = 0 THEN
             IF CurTimeIN = checktime THEN
                SET msg = 'Update bypass OUT';
                SET @bypass = 1;
             ELSE
                IF CurTimeIN > checktime AND checktime > (shift_datetime_start - INTERVAL 2 HOUR) THEN -- using 2hrs interval
                   SET msg = CONCAT(msg,'Update IN - ');
                   UPDATE `ww_time_record` SET `time_in` = checktime, `modified_on` = NOW()
                   WHERE `record_id` = rec AND `override` = 0 LIMIT 1;
		ELSE
		   IF shift_end = '00:00:00' THEN
		        SET @nxt_date = @cur_date + INTERVAL 1 DAY;
		        SET shift_datetime_end = CONCAT(@nxt_date,' ',shift_end);		   
		   END IF;
		   IF CurTimeOUT = '0000-00-00 00:00:00' THEN
                      SET msg = CONCAT(msg,'Update OUT Current - ');
                      UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                      WHERE `record_id` = rec AND `override` = 0 LIMIT 1;		   
                   ELSEIF CurTimeOUT < checktime AND checktime < (shift_datetime_end + INTERVAL 8 HOUR) THEN
                      SET msg = CONCAT(msg,'Update OUT Current - ');
                      UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                      WHERE `record_id` = rec AND `override` = 0 LIMIT 1;
                   END IF;
                END IF;
             END IF;
          END IF;
       END IF;
       
       -- HOW ABOUT WE ALTER TIMEIN THAT WAS SUPPOSED TO BE TIMEOUT
       -- MINUS MINUS 2 DAYS: NEXT
       
       -- [[
       -- SELECT prevrec, msg, @cur_date, @prv_date, @nxt_date, checktime, prevshift_datetime_start, prevshift_datetime_end, prevCurShiftID, prevCurShift, prevCurTimeIN, prevCurTimeOUT;
       -- ]]
       END;
    END IF;
    
    -- [[
    -- SELECT rec, msg, @cur_date, @prv_date, @nxt_date, checktime, shift_datetime_start, shift_datetime_end, CurShiftID, CurShift, CurTimeIN, CurTimeOUT;
    -- ]]
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_raw_process_2` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_raw_process_2` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_raw_process_2`(IN userid INT(11), IN dates DATE, IN checktime DATETIME)
BEGIN
       DECLARE shiftid INT(11) DEFAULT 0;
       DECLARE rec INT(11) DEFAULT 0;
       DECLARE shift_start TIME;
       DECLARE shift_end TIME;
       DECLARE NewCIn DATETIME;
       DECLARE NewCOut DATETIME;
       DECLARE NewTime TINYINT(1) DEFAULT 0;  --  1==In  2==Out
       DECLARE NewTimeIn DATE;
       DECLARE NewTimeOut DATE;
       DECLARE NewDate DATE;
       
       DECLARE MaxPreShift TIME;
       DECLARE MaxPostShift TIME;
       DECLARE MidPostShift TIME;
       DECLARE FirstHalfEnd TIME;   
       
       DECLARE auxshiftid INT;
       DECLARE shift_datetime_start DATETIME;
       DECLARE shift_datetime_end DATETIME;
       DECLARE prev_date DATE;
       DECLARE prev_datetime_in DATETIME;
       DECLARE prev_datetime_out DATETIME;
       DECLARE prev_shift_datetime_end DATETIME;
       DECLARE exist_timein DATETIME;
       DECLARE exist_timeout DATETIME;
       DECLARE shift_start_base DATETIME;
       DECLARE shift_end_base DATETIME;
       
       DECLARE time_in_notset DATETIME;
       DECLARE prev_time_in DATETIME;
       DECLARE prev_time_out DATETIME;
       DECLARE prev_shift_start TIME;
       DECLARE prev_shift_end TIME;
       
       -- [1] Check current shift on partner table
       if (select count(*) from ww_time_record where user_id = userid and `date` = dates) = 0 then
          call sp_time_period_populate_user(dates,dates,userid);
       end if;     
       
       -- just to check if there is already an override
       SELECT IF(IFNULL(aux_shift_id,0)=0,shift_id,aux_shift_id) INTO auxshiftid
       FROM `ww_time_record`
       WHERE `user_id`=userid AND `date`=dates LIMIT 1;
       
      
       
       -- and now is the time
       SELECT `time_start`, `time_end`, 
              IFNULL(tscc1.class_value,'') AS `max_preshift`, 
              IFNULL(tscc2.class_value,'') AS `max_postshift`, 
              IFNULL(tscc3.class_value,'') AS `mid_postshift`,
              IFNULL(tscc4.class_value,'') AS `firsthalfend` 
       INTO shift_start, shift_end, MaxPreShift, MaxPostShift, MidPostShift, FirstHalfEnd
       
       FROM `partners` p
       INNER JOIN `ww_users_profile` up ON up.`user_id`=p.`user_id`
       INNER JOIN `ww_time_shift` ts ON ts.`shift_id`=IF(auxshiftid=0,p.`shift_id`,auxshiftid)
       LEFT JOIN time_shift_class tscc1 ON tscc1.shift_id=ts.shift_id AND tscc1.company_id=up.company_id AND tscc1.class_code='MAX-PRESHIFT'
       LEFT JOIN time_shift_class tscc2 ON tscc2.shift_id=ts.shift_id AND tscc2.company_id=up.company_id AND tscc2.class_code='MAX-POSTSHIFT'
       LEFT JOIN time_shift_class tscc3 ON tscc3.shift_id=ts.shift_id AND tscc3.company_id=up.company_id AND tscc3.class_code='MID-POSTSHIFT'
       LEFT JOIN time_shift_class tscc4 ON tscc4.shift_id=ts.shift_id AND tscc4.company_id=up.company_id AND tscc4.class_code='FIRST-HALF-END'
       WHERE p.`user_id` = userid;
       
       
	   SET NewDate=DATE(checktime);
	   SET shift_datetime_start = CONCAT(NewDate,' ',shift_start);
	   SET shift_datetime_end = CONCAT(NewDate,' ',shift_end);
	   SET prev_date = DATE(checktime - INTERVAL 1 DAY);
	   SET shift_start_base = shift_datetime_start - INTERVAL 6 HOUR; -- maxpreshift
	   SET shift_end_base = shift_datetime_end + INTERVAL 10 HOUR; -- maxpostshift
	   SET NewTimeIn = NewDate;
	   SET NewTimeOut = NewDate;
	   SET prev_time_in = (SELECT time_in FROM ww_time_record WHERE user_id=userid AND DATE=prev_date);
	   
	   IF shift_start > shift_end THEN
		SET prev_shift_datetime_end = shift_datetime_end + INTERVAL 8 HOUR;
	   ELSE
		SET prev_shift_datetime_end = CONCAT(prev_date,' ',shift_end) + INTERVAL 8 HOUR;
	   END IF;
	   
	   SET @previous_timeout = '';
	      
	    -- Checking if the sched is nightshift or dayshift
		IF shift_start >= '00:00:00' AND shift_start <= '16:00:00' THEN
			IF TIME(checktime) >= '00:00:00' AND TIME(checktime) <= '06:00:00' THEN
				IF shift_start > shift_end THEN
					SET NewDate = NewDate - INTERVAL 1 DAY;
					SET NewTimeIn = NewDate;
					SET NewTimeOut = NewDate;
				END IF;
			ELSEIF shift_start > shift_end THEN
				SET shift_datetime_end = shift_datetime_end + INTERVAL 1 DAY;
				SET shift_end_base = shift_datetime_end + INTERVAL 8 HOUR;
				SET NewDate = shift_datetime_end - INTERVAL 1 DAY;
				SET NewTimeIn = NewDate;
				SET NewTimeOut = NewDate;
			END IF;
		ELSEIF TIME(checktime) >= '00:00:00' AND TIME(checktime) <= '08:00:00' THEN
				SET NewDate = NewDate - INTERVAL 1 DAY;
				SET NewTimeIn = NewDate;
				SET NewTimeOut = NewDate;	
		ELSEIF shift_start > shift_end THEN
				SET shift_datetime_end = shift_datetime_end + INTERVAL 1 DAY;
				SET shift_end_base = shift_datetime_end + INTERVAL 8 HOUR;
				SET NewDate = shift_datetime_end - INTERVAL 1 DAY;
				SET NewTimeIn = NewDate;
				SET NewTimeOut = NewDate;
		END IF;
		
		 -- [4] Checking for existence of previous record
		SELECT time_in,time_out,record_id, time_start, time_end INTO exist_timein,exist_timeout,rec,prev_shift_start,prev_shift_end
		FROM ww_time_record tr 
		JOIN ww_time_shift ts ON ts.`shift_id` = IF(tr.aux_shift_id=0,tr.`shift_id`,tr.aux_shift_id)
		WHERE tr.user_id=userid AND tr.date = prev_date;
		
		IF rec > 0 AND checktime != '0000-00-00 00:00:00' THEN
			IF (exist_timeout IS NULL OR exist_timeout = '' OR exist_timeout = '0000-00-00 00:00:00') THEN 
				
				IF (prev_shift_start > prev_shift_end) AND (exist_timein != '' OR exist_timein IS NOT NULL OR exist_timein = '0000-00-00 00:00:00') THEN
					SET prev_shift_datetime_end = CONCAT(NewDate,' ',prev_shift_end) + INTERVAL 8 HOUR;
					SET NewDate = prev_date;
				END IF;
				
				IF checktime <= prev_shift_datetime_end AND (prev_time_in IS NOT NULL OR checktime <= shift_start_base)
				THEN
					UPDATE ww_time_record tr 
					SET tr.time_out=checktime,`modified_on`=NOW()
					WHERE tr.user_id=userid AND tr.date= prev_date AND tr.override=0;
					
					SET @previous_timeout=checktime;
				SELECT 'Update 0';
				END IF;
				
			END IF;
			SET prev_time_out = exist_timeout;
		END IF;
		
		
		
		
	-- [4] Checking for existence of record
	-- exist_time_in is the time_in if there's already a record
	-- exist_time_out is the time_out if there's already a record
	
	SELECT `record_id`, `time_in`, `time_out` INTO rec, exist_timein, exist_timeout 
	FROM `time_record` 
	WHERE `user_id`=userid AND `date`=NewDate 
	LIMIT 1;
	
	IF rec > 0 AND checktime != '0000-00-00 00:00:00' THEN
		IF (exist_timein IS NULL OR exist_timein = '' OR exist_timein = '0000-00-00 00:00:00') THEN
			-- UPDATE ww_time_record SET time_in=checktime WHERE user_id=userid AND DATE=NewTimeIn;
			IF checktime >= shift_start_base AND checktime <= shift_end_base THEN
				UPDATE ww_time_record SET time_in=checktime,`modified_on`=NOW() 
				WHERE user_id=userid AND `date`=NewTimeIn AND override=0;				
				SELECT 'Update 1',NewTimeIn,checktime;
			ELSEIF (checktime < shift_datetime_start AND checktime < shift_datetime_end) AND 
				(prev_time_out IS NOT NULL AND checktime != prev_time_out AND prev_time_out != '0000-00-00 00:00:00') THEN
				UPDATE ww_time_record SET time_in=checktime,`modified_on`=NOW() 
				WHERE user_id=userid AND `date`=NewTimeIn AND override=0;	
				SELECT 'Update 2';
			END IF;									
		ELSEIF checktime != exist_timein OR checktime != exist_timeout THEN
			IF exist_timein > checktime THEN
				IF checktime >= shift_start_base AND checktime <= shift_end_base THEN
					UPDATE ww_time_record SET time_out=IF(time_in>checktime,time_in,time_out), time_in=checktime,`modified_on`=NOW() 
					WHERE user_id=userid AND `date`=NewTimeIn AND override=0;
				SELECT 'Update 3';
				END IF;					  
			END IF;
						
			IF exist_timeout IS NULL OR exist_timeout = '' OR exist_timeout = '0000-00-00 00:00:00' THEN
				IF checktime < shift_end_base THEN
					SET @current_timein='';
					SELECT `time_in` INTO @current_timein
					FROM `time_record` 
					WHERE `user_id`=userid AND `date`=NewTimeOut LIMIT 1;
					
					IF @current_timein IS NULL OR @current_timein = '' THEN
						UPDATE ww_time_record 
						SET time_in=checktime, `modified_on`=NOW() 
						WHERE user_id=userid AND `date`=NewTimeOut AND override=0 LIMIT 1;
					ELSE
						UPDATE ww_time_record 
						SET time_out=IF(time_in=checktime, time_out, IF(time_in>checktime,time_out,checktime)), `modified_on`=NOW() 
						WHERE user_id=userid AND `date`=NewTimeOut AND override=0 LIMIT 1;
					END IF;
				SELECT 'Update 4',checktime,shift_end_base,exist_timein,exist_timeout,NewTimeOut;
				END IF;
			ELSEIF exist_timeout < checktime THEN
				UPDATE ww_time_record SET time_out=IF(time_in=checktime, time_out, checktime),`modified_on`=NOW() 
				WHERE user_id=userid AND `date`=NewTimeOut AND override=0;
				SELECT 'Update 5';
			END IF;
		END IF;
		IF exist_timein IS NOT NULL AND (shift_start IS NULL OR shift_start = '00:00:00') THEN 
			UPDATE ww_time_record SET time_out=IF(time_in=checktime, time_out, checktime),`modified_on`=NOW()
			WHERE user_id=userid AND `date`=NewDate;
				SELECT 'Update 6', NewDate;
		END IF;
		IF exist_timein IS NULL AND exist_timeout IS NULL AND prev_time_in IS NOT NULL AND prev_time_in IS NOT NULL THEN 
			IF @previous_timeout = '' THEN
				UPDATE ww_time_record SET time_in=checktime,`modified_on`=NOW()
				WHERE user_id=userid AND `date`=NewDate;
			SELECT 'Update 7',NewDate,checktime;
			END IF;
		END IF;
	ELSE 
		INSERT INTO ww_time_record (`user_id`,`date`,`time_in`) VALUES (userid,NewDate,checktime);
		IF checktime = prev_time_out AND prev_time_out IS NOT NULL THEN 
			UPDATE ww_time_record SET time_in=NULL,`modified_on`=NOW() 
			WHERE user_id=userid AND `date`=NewTimeIn AND override=0;
				SELECT 'Insert 1';
		END IF;
		
	END IF;
	
			
	-- SELECT rec,checktime,prev_time_out, prev_shift_datetime_end, NewDate,shift_start,shift_end,shift_datetime_start,shift_datetime_end,prev_date,prev_shift_datetime_end,shift_start_base,shift_end_base, exist_timein,exist_timeout,NewTimeIn,NewTimeOut,prev_time_in,prev_time_out;
 
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_raw_process_new` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_raw_process_new` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_raw_process_new`(IN userid INT(11), IN dates DATE, IN checktime DATETIME)
BEGIN
    
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE shift_start TIME;
    DECLARE shift_end TIME;
    
    DECLARE NewTimeIn DATETIME;
    DECLARE NewTimeOut DATETIME;
    DECLARE NewDate DATE;
    DECLARE CurTimeIN DATETIME;
    DECLARE CurTimeOUT DATETIME;
    DECLARE CurShiftID INT(11) DEFAULT 0;
    DECLARE CurShift VARCHAR(32) DEFAULT '';
    
    DECLARE shift_datetime_start DATETIME;
    DECLARE shift_datetime_end DATETIME;
    DECLARE msg VARCHAR(64) DEFAULT '';
    
    
    -- [1] GET AND POPULATE THE NEEDED TIME RECORD
    IF (SELECT COUNT(*) FROM `ww_time_record` WHERE `user_id` = userid AND `date` = dates LIMIT 1) = 0 THEN
       -- better include partners employment date in the future
       CALL sp_time_period_populate_user(dates, dates + INTERVAL 2 DAY, userid);
    END IF;     
    
       
    -- [3] GET CURRENT ATTENDANCE RECORD
    SELECT tr.`record_id`, `time_start`, `time_end`, 
           IF(IFNULL(tr.`aux_shift_id`,0)=0, tr.`shift_id`, tr.`aux_shift_id`), IF(IFNULL(tr.`aux_shift_id`,0)=0, tr.`shift`, tr.`aux_shift`), 
           IFNULL(`time_in`, '0000-00-00 00:00:00'), IFNULL(`time_out`, '0000-00-00 00:00:00') 
    INTO rec, shift_start, shift_end, CurShiftID, CurShift, CurTimeIN, CurTimeOUT
    FROM `ww_time_record` tr
    JOIN `ww_time_shift` ts ON ts.`shift_id`=IF(tr.`aux_shift_id`=0, tr.`shift_id`, tr.`aux_shift_id`)
    WHERE tr.`user_id` = userid AND tr.`date` = dates LIMIT 1;
    
    
    SET @cur_date = DATE(checktime);
    SET @prv_date = @cur_date - INTERVAL 1 DAY;
    SET @nxt_date = IF(shift_start > shift_end, @cur_date + INTERVAL 1 DAY, @cur_date);
    SET shift_datetime_start = CONCAT(@cur_date,' ',shift_start);
    SET shift_datetime_end = CONCAT(@nxt_date,' ',shift_end);
    SET @restday = 0;
    
    
    -- [4] IF RESTDAY/OFF
    IF CurShift = 'RESTDAY' OR CurShift = 'OFF'  THEN
       SET @restday = 1;
    END IF;
    
    
    -- [5] VALIDATE AND UPDATE
    IF rec = 0 THEN
       INSERT INTO `ww_time_record` (`user_id`, `date`, `time_in`) 
       SELECT userid, dates, checktime;
       SET msg = 'Insert 1N';
    ELSE
       BEGIN
       DECLARE prevrec INT(11) DEFAULT 0;
       DECLARE prevshift_start TIME;
       DECLARE prevshift_end TIME;
       DECLARE prevCurTimeIN DATETIME;
       DECLARE prevCurTimeOUT DATETIME;
       DECLARE prevCurShiftID INT(11) DEFAULT 0;
       DECLARE prevCurShift VARCHAR(32) DEFAULT '';
       DECLARE prevshift_datetime_start DATETIME;
       DECLARE prevshift_datetime_end DATETIME;
              
       SELECT tr.`record_id`, `time_start`, `time_end`, 
              IF(IFNULL(tr.`aux_shift_id`,0)=0, tr.`shift_id`, tr.`aux_shift_id`), IF(IFNULL(tr.`aux_shift_id`,0)=0, tr.`shift`, tr.`aux_shift`), 
              IFNULL(`time_in`, '0000-00-00 00:00:00'), IFNULL(`time_out`, '0000-00-00 00:00:00') 
       INTO prevrec, prevshift_start, prevshift_end, prevCurShiftID, prevCurShift, prevCurTimeIN, prevCurTimeOUT
       FROM `ww_time_record` tr
       JOIN `ww_time_shift` ts ON ts.`shift_id`=IF(tr.`aux_shift_id`=0, tr.`shift_id`, tr.`aux_shift_id`)
       WHERE tr.`user_id` = userid AND tr.`date` = @prv_date LIMIT 1;
       
       IF prevrec > 0 THEN
          SET prevshift_datetime_start = CONCAT(@prv_date,' ',prevshift_start);
          SET prevshift_datetime_end = CONCAT(IF(prevshift_start > prevshift_end, @cur_date, @prv_date),' ',prevshift_end);
       END IF;
       SET @bypass = 0;
          
       IF CurTimeIN = '0000-00-00 00:00:00' THEN  -- TIMEIN
          
          IF prevrec > 0 THEN
             IF prevCurTimeOUT = '0000-00-00 00:00:00' AND checktime < (shift_datetime_start - INTERVAL 2 HOUR) AND
                (prevCurShift <> 'RESTDAY' AND prevCurShift <> 'OFF') THEN -- using 2hrs interval
                IF checktime = CurTimeIN THEN
                   SET msg = CONCAT(msg,'Update bypass Prev OUT');
                   SET @bypass = 1;
                ELSE
                   SET msg = CONCAT(msg,'Update Prev OUT - ');
                   SET @bypass = 1;
                   UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                   WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;
                END IF;
             ELSE
                IF CurShift = 'RESTDAY' OR CurShift = 'OFF' THEN
                   IF checktime < (prevshift_datetime_start + INTERVAL 24 HOUR) THEN -- using 24hrs interval from previous shift-start
                      SET msg = CONCAT(msg,'Update RESTDAY - ');
                      SET @bypass = 1;
                      UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                      WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;
                   ELSE
                      SET msg = CONCAT(msg,'Update RESTDAY 2 - ');
                      SET @bypass = 1;
                      UPDATE `ww_time_record` SET `time_in` = checktime, `modified_on` = NOW()
                      WHERE `record_id` = rec AND `override` = 0 LIMIT 1;
                   END IF;
                END IF;
                IF prevCurTimeOUT <> '0000-00-00 00:00:00' THEN
                   IF prevCurTimeOUT = checktime THEN
                      SET msg = 'Update bypass Prev OUT';
                      SET @bypass = 1;
                   END IF;
                ELSE
                   IF prevCurShift = 'RESTDAY' OR prevCurShift = 'OFF' THEN
                      SET msg = CONCAT(msg,'Update RESTDAY 3 - ');
                      SET @bypass = 1;
                      UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                      WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;
                   END IF;
                END IF;
             END IF;
          END IF;
          
          IF @bypass = 0 THEN
             IF checktime >= shift_datetime_end THEN
                SET msg = CONCAT(msg,'Update OUT - ');
                UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                WHERE `record_id` = rec AND `override` = 0 LIMIT 1;
             ELSE
                SET msg = CONCAT(msg,'Update IN - ');
                UPDATE `ww_time_record` SET `time_in` = checktime, `modified_on` = NOW()
                WHERE `record_id` = rec AND `override` = 0 LIMIT 1;
             END IF;
          END IF;
          
       ELSE  -- TIMEOUT
          
          IF prevrec > 0 AND checktime < (shift_datetime_start - INTERVAL 2 HOUR) THEN -- using 2hrs interval
             SET msg = CONCAT(msg,'Update OUT Prev OUT - ');
             SET @bypass = 1;
             UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
             WHERE `record_id` = prevrec AND `override` = 0 LIMIT 1;
          END IF;
          
          IF @bypass = 0 THEN
             IF CurTimeIN = checktime THEN
                SET msg = 'Update bypass OUT';
                SET @bypass = 1;
             ELSE
                SET msg = CONCAT(msg,'Update OUT Current - ');
                UPDATE `ww_time_record` SET `time_out` = checktime, `modified_on` = NOW()
                WHERE `record_id` = rec AND `override` = 0 LIMIT 1;
             END IF;
          END IF;
       END IF;
       
       -- HOW ABOUT WE ALTER TIMEIN THAT WAS SUPPOSED TO BE TIMEOUT
       -- MINUS MINUS 2 DAYS: NEXT
       
       -- [[
       SELECT prevrec, msg, @cur_date, @prv_date, @nxt_date, checktime, prevshift_datetime_start, prevshift_datetime_end, prevCurShiftID, prevCurShift, prevCurTimeIN, prevCurTimeOUT;
       -- ]]
       END;
    END IF;
    
    -- [[
    SELECT rec, msg, @cur_date, @prv_date, @nxt_date, checktime, shift_datetime_start, shift_datetime_end, CurShiftID, CurShift, CurTimeIN, CurTimeOUT;
    -- ]]
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_raw_reupload` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_raw_reupload` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_raw_reupload`(IN userid INT(11),IN dates DATE)
BEGIN
     
     /* Revisions
        2017-05-16 : Time-record update if there is an existing time-record-raw
     */
     
     DECLARE dates_pre DATE;
     DECLARE dates_nex DATE; 
     
     -- [1] get date range but do not include manual override by the timekeeper
     SELECT `date` INTO dates_pre 
     FROM `ww_time_record` WHERE `user_id` = userid AND `override` = 0 AND `date` = dates - INTERVAL 1 DAY LIMIT 1;
     
     SELECT `date` INTO dates_nex 
     FROM `ww_time_record` WHERE `user_id` = userid AND `override` = 0 AND `date` = dates + INTERVAL 1 DAY LIMIT 1;
     
     
     -- [2] reset in-out
     UPDATE `ww_time_record` SET time_in = NULL, time_out = NULL
     WHERE `date` IN (dates,dates_pre,dates_nex) AND `user_id` = userid AND `override` = 0;
     
     
     -- [3] redo re-process
     UPDATE `ww_time_record_raw` trr SET trr.`last_processed`=NOW()
     WHERE trr.`date` IN (dates,dates_pre,dates_nex) AND trr.`user_id` = userid;
     
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_reminder` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_reminder` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_reminder`()
BEGIN
    
    DECLARE done TINYINT(1) DEFAULT 0;
    DECLARE userid INT(11);
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE forms CURSOR FOR
       SELECT iar.`user_id`
       FROM report_time_iar iar
       JOIN `ww_time_period` tp ON tp.`deleted`=0 AND CURDATE() BETWEEN tp.`date_from` AND tp.`date_to`
       JOIN `ww_users` u ON u.`user_id`=iar.`user_id` AND u.`active`=1 AND u.`deleted`=0
       JOIN `ww_partners` p ON p.`user_id`=u.`user_id` AND p.`employment_type_id`<>9
       WHERE iar.`date` BETWEEN tp.`date_from` AND tp.`date_to` AND iar.`company_id`=tp.`company_id` -- AND iar.user_id=65
       GROUP BY 1;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
	OPEN forms;
	REPEAT
	   FETCH forms INTO userid;
	   IF NOT done THEN
          SET rec = rec + 1;
          CALL sp_time_record_reminder_user(userid);
	   END IF;
	UNTIL done END REPEAT;
    CLOSE forms;
	   
	SELECT rec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_reminder_user` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_reminder_user` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_reminder_user`(IN userid INT(11))
BEGIN
    
    DECLARE done TINYINT(1) DEFAULT 0;
    
    DECLARE formsid INT(11);
    DECLARE fullname VARCHAR(128);
    DECLARE dateid DATE;
    DECLARE paydate DATE;
    DECLARE cutoff DATE;
    DECLARE shift VARCHAR(32);
    DECLARE timefrom DATETIME;
    DECLARE timeto DATETIME;
    DECLARE particulars VARCHAR(64);
    DECLARE datefrom DATE;
    DECLARE dateto DATE;
    DECLARE records INT(11) DEFAULT 0;
    
    DECLARE forms_user CURSOR FOR
       SELECT tp.`payroll_date`, tp.`cutoff`, tp.`date_from`, tp.`date_to`, 
              iar.`date`, iar.`shift`, iar.`time_from`, iar.`time_to`, iar.`particulars`
       FROM `report_time_iar` iar
       JOIN `ww_time_period` tp ON tp.`deleted`=0 AND CURDATE() BETWEEN tp.`date_from` AND tp.`date_to`
       JOIN `ww_partners` p ON p.`user_id` = iar.`user_id` AND p.`employment_type_id` <> 9
       WHERE iar.`date` BETWEEN tp.`date_from` AND tp.`date_to` AND 
             iar.`date` <= CURDATE() - INTERVAL 1 DAY AND
             IF(iar.`particulars` IN ('LATE','UNDERTIME'), iar.`date` = CURDATE() - INTERVAL 1 DAY, 1) AND
             iar.`particulars` <> 'LWOP' AND
             iar.`company_id`=tp.`company_id` AND 
             iar.`user_id`=userid
             GROUP BY iar.date
       ORDER BY 1,2;
    
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
        
    SET @emailto = '';
    SET @username = '';
    SET @emailsubject = '';
    SET @emailbody = '';
    SET @tbody = '';
    SET @bcc = '';
    SET @url = '';
    SET @pdate = '';
    SET @cdate = '';
    SET @pfrom = '';
    SET @pto = '';      
    
    -- template 
    SELECT `subject`,`body` INTO @emailsubject, @emailbody
    FROM `ww_system_template`
    WHERE `code`='TIME-RECORD-REMINDER' AND deleted=0 LIMIT 1;
    
    
    IF @emailsubject <> '' THEN
       
	   SELECT u.`email`, up.firstname INTO @emailto, @username
	   FROM `users` u, `users_profile` up
	   WHERE u.`user_id`=up.`user_id` AND u.`user_id`=userid LIMIT 1;
       
	   IF @emailto <> '' THEN
	      OPEN forms_user;
	      REPEAT
	         FETCH forms_user INTO paydate, cutoff, datefrom, dateto, dateid, shift, timefrom, timeto, particulars;
	         IF NOT done THEN
	            SET records = records + 1;
	            
	            SET @pdate = paydate;
	            SET @cdate = cutoff;
	            SET @pfrom = datefrom;
	            SET @pto   = dateto;
	            
                    SET @tbody = CONCAT(@tbody,'<tr>');
                    SET @tbody = CONCAT(@tbody,'<td>',dateid,'</td>');	
                    SET @tbody = CONCAT(@tbody,'<td>',shift,'</td>');	
                    SET @tbody = CONCAT(@tbody,'<td>',IFNULL(timefrom,'&nbsp;'),'</td>');	
                    SET @tbody = CONCAT(@tbody,'<td>',IFNULL(timeto,'&nbsp;'),'</td>');	
                    SET @tbody = CONCAT(@tbody,'<td style="text-align:left">',particulars,'</td>');	
                    SET @tbody = CONCAT(@tbody,'</tr>');
	         END IF;
	      UNTIL done END REPEAT;
          CLOSE forms_user;
          
          IF @tbody <> '' THEN
             -- {{link}}
             SET @url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
	     IF RIGHT(TRIM(@url),1) <> '/' THEN
	         SET @url = CONCAT(TRIM(@url),'/');
	     END IF;
	         
             SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='form_application' LIMIT 1);
             SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
          
             SET @emailbody = REPLACE(@emailbody, '{{alias}}', @username);
             SET @emailbody = REPLACE(@emailbody, '{{table_body}}', @tbody);
             SET @emailbody = REPLACE(@emailbody, '{{payrolldate}}', DATE_FORMAT(@pdate,'%M %e, %Y - %W'));
             SET @emailbody = REPLACE(@emailbody, '{{cutoff}}', DATE_FORMAT(@cdate,'%M %e, %Y - %W'));
             SET @emailbody = REPLACE(@emailbody, '{{datefrom}}', DATE_FORMAT(@pfrom,'%b-%e'));
             SET @emailbody = REPLACE(@emailbody, '{{dateto}}', DATE_FORMAT(@pto,'%b-%e'));
             
             SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
             SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
             SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
             SET @urgent = '';
             SET @cut_off = '';
             
             SELECT cutoff, 'URGENT!!! ' INTO @cut_off, @urgent
             FROM ww_time_period tp, users_profile up
             WHERE tp.deleted=0 AND tp.company_id = up.company_id AND up.`user_id`=userid AND 
                   CURDATE() BETWEEN (cutoff - INTERVAL 2 DAY) AND cutoff LIMIT 1;
             
             IF TRIM(@urgent) <> '' THEN
                SET @emailsubject = CONCAT(@urgent, @emailsubject, ' CUT-OFF is ', DATE_FORMAT(@cut_off,'%M %e %W'));
             END IF;
	   
          
             INSERT INTO `ww_system_email_queue` (`to`,`subject`,`body`,`bcc`)
             SELECT @emailto,@emailsubject,@emailbody,@bcc;
             
             -- SELECT @emailto, @emailbody, records;
          ELSE
             SELECT 'no record';
          END IF;
       ELSE
          SELECT 'no recipient';
       END IF;
    
    ELSE
       SELECT 'template';
    END IF;
	
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_sms_reminder` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_sms_reminder` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_sms_reminder`(IN companyid INT(11), IN dateid DATE)
BEGIN
    
    INSERT INTO `ww_system_sms_queue` (`to`,`subject`,`body`)
    SELECT 
       REPLACE(REPLACE(TRIM(pp.`key_value`),'-',''),'+',''), 
       IF(IFNULL(`nickname`,'')='',`firstname`,`nickname`),
       REPLACE(
       REPLACE(
       REPLACE(`body`, 
          '{{alias}}', IF(IFNULL(`nickname`,'')='',`firstname`,`nickname`)), 
          '{{particular}}', iar.`particulars`),
          '{{date}}', DATE_FORMAT(iar.`date`,'%b-%e %a'))particular
    FROM `report_time_iar` iar
    JOIN `users_profile` up ON up.`user_id`=iar.`user_id` 
    JOIN `users` u ON u.user_id=up.user_id AND u.active=1
    LEFT JOIN `ww_system_template` st ON st.`code`='SMS-TIME-REMINDER'
    LEFT JOIN `ww_partners_personal` pp ON pp.`key`='mobile' AND pp.`partner_id`=up.`partner_id`
    WHERE iar.`particulars`<>'LWOP' AND 
          IF(dateid=0,iar.`date`=(CURDATE()-INTERVAL 1 DAY),iar.`date`=dateid) AND
          REPLACE(TRIM(pp.`key_value`),'-','')<>'' AND pp.`sequence`=1 AND
          IF(companyid=0,1,up.company_id=companyid);
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_sms_reminder_all` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_sms_reminder_all` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_sms_reminder_all`()
BEGIN
    DECLARE pdone TINYINT(11) DEFAULT 0;
    DECLARE prec INT(11) DEFAULT 0;
    
    DECLARE recordid INT;
    DECLARE periodid INT;
    DECLARE datefrom DATE;
    DECLARE dateto DATE;
    DECLARE cutoff DATE; 
    DECLARE companyid INT;
    
    
    -- STEP 1:
    -- SCAN ALL DATES;
    -- PUT THE RESULT ONTO A TEMPORARY TABLE (CURSOR)
    -- 
     
    DECLARE periods CURSOR FOR
       SELECT tp.`period_id`, tp.`date_from`, tp.`date_to`, tp.`cutoff`, tp.`company_id`
       FROM `ww_time_period` tp
       WHERE tp.`closed`=0 AND tp.`deleted`=0 AND 
             CURDATE() BETWEEN tp.`date_from` AND IF(tp.`cutoff` > tp.`date_to`, tp.`cutoff`, tp.`date_to`)
             -- AND tp.`company_id`=5
             ;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET pdone = 1;
 
 
    -- START TRANSACTION;
        
    OPEN periods;
    
    REPEAT
       FETCH periods INTO periodid, datefrom, dateto, cutoff, companyid;
       
       IF NOT pdone THEN
           SET prec = prec + 1;
           
           -- execute sms sending
           CALL `sp_time_record_sms_reminder`(companyid, 0);
           
       END IF;
       
    UNTIL pdone END REPEAT;
    
    CLOSE periods;
    
    SELECT prec;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_record_tardiness_process` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_record_tardiness_process` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_record_tardiness_process`(IN pdate DATE)
BEGIN
    
    DECLARE time_record_tardiness_process TINYINT(1) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    
    DECLARE nuserid INT(11);
    DECLARE cidnum VARCHAR(16);
    DECLARE ninstance DECIMAL(5,2);
    DECLARE ntotalmin DECIMAL(5,2);
    
    -- [1]
    DECLARE tardiness_process CURSOR FOR
    SELECT p.`user_id`, p.`id_number`, COUNT(trs.`date`) instances, SUM(trs.late) total_minutes 
    FROM `ww_partners` p
    JOIN `ww_time_record_summary` trs ON trs.`deleted`=0 AND trs.`user_id`=p.`user_id` AND trs.late>0
    JOIN `ww_partners_employment_status` pes ON pes.`deleted`=0 AND pes.`active`=1 AND pes.`employment_status_id`=p.`status_id`
    WHERE p.`deleted`=0 AND 
          YEAR(trs.`date`)=YEAR(pdate) AND 
          MONTH(trs.`date`)=MONTH(pdate) AND 
          p.`employment_type_id`<>9
    GROUP BY p.`user_id`;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET time_record_tardiness_process = 1;
    
    -- [2]
    OPEN tardiness_process;
    
    REPEAT
       FETCH tardiness_process INTO nuserid, cidnum, ninstance, ntotalmin;
       
       IF NOT time_record_tardiness_process THEN
          SET rec = rec + 1;
          
          -- [1]
          INSERT INTO `ww_time_record_tardiness` (`period_year`,`period_month`,`user_id`,`id_number`,`instances`,`total_minutes`)
          SELECT YEAR(pdate), MONTH(pdate), nuserid, cidnum, ninstance, ntotalmin 
          ON DUPLICATE KEY UPDATE 
             `instances`     = VALUES(`instances`),
             `total_minutes` = VALUES(`total_minutes`),
             `modified_on`   = NOW();
          
          -- [2]
          INSERT INTO `ww_time_record_tardiness_detail` (`period_year`,`period_month`,`user_id`,`date`,`late`)
          SELECT YEAR(pdate), MONTH(pdate), `user_id`, `date`, `late`
          FROM `ww_time_record_summary`
          WHERE `deleted` = 0 AND 
                `user_id` = nuserid AND `late` > 0 AND
                YEAR(`date`) = YEAR(pdate) AND MONTH(`date`) = MONTH(pdate)
          ON DUPLICATE KEY UPDATE
             `late` = VALUES(`late`),
             `modified_on` = NOW();
          
       END IF;
       
    UNTIL time_record_tardiness_process END REPEAT;
    
    CLOSE tardiness_process;
       
    SELECT rec;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_server_reminder` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_server_reminder` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_server_reminder`()
BEGIN
    DECLARE done TINYINT(11) DEFAULT 0;
    DECLARE rec INT(11) DEFAULT 0;
    DECLARE loc VARCHAR(64);
    DECLARE pc INT(11);
    DECLARE wr INT(11);
    DECLARE nr INT(11);
    
    DECLARE locations CURSOR FOR
       SELECT ul.`location`, 
       COUNT(p.`user_id`)partner_count, 
       SUM(IF(IFNULL(tr.`time_in`,tr.`aux_time_in`) IS NULL, 0, 1))with_record,
       SUM(IF(IFNULL(tr.`time_in`,tr.`aux_time_in`) IS NULL, 1, 0))no_record
       FROM `ww_users_location` ul
       JOIN `users_profile` up ON up.`location_id`=ul.`location_id`
       JOIN `partners` p ON p.`user_id`=up.`user_id` AND IFNULL(p.resigned_date,'0000-00-00')='0000-00-00'
       LEFT JOIN `time_record` tr ON tr.`user_id`=p.`user_id` AND tr.`date` = (CURDATE()-INTERVAL 1 DAY)
       WHERE ul.`deleted` = 0
       GROUP BY 1;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
    
    
    SET @perc = 0;
    SET @tbody = '';
    SET @tprop = '<td style="padding: 8px;vertical-align: top;border-top: 1px solid #dddddd;">';
    SET @system_fromaddress = (SELECT `value` FROM `ww_config` WHERE `key`='from_address' LIMIT  1);
        
    OPEN locations;
    
    REPEAT
       FETCH locations INTO loc, pc, wr, nr;
       
       SET @perc = 0;
       IF NOT done THEN
          SET @perc = (nr / pc) * 100;
          IF @perc > 50 THEN
             SET rec = rec + 1;
          END IF;
          SET @tbody = CONCAT(@tbody,'<tr>');
          SET @tbody = CONCAT(@tbody,@tprop,loc,'</td>');
          SET @tbody = CONCAT(@tbody,@tprop,pc,'</td>');
          SET @tbody = CONCAT(@tbody,@tprop,wr,'</td>');
          SET @tbody = CONCAT(@tbody,@tprop,nr,'</td>');
          SET @tbody = CONCAT(@tbody,@tprop,IF(@perc>50,'<b>',''),ROUND(@perc,0),'%',IF(@perc>50,'</b>',''),'</td>');
          SET @tbody = CONCAT(@tbody,'</tr>');
       END IF;
        
    UNTIL done END REPEAT;
    
    CLOSE locations;
    
    IF rec > 0 THEN
           
       -- retrieve the email template
       SET @emailto = @system_fromaddress;
       SET @emailcc = '';
       SET @emailbcc = (SELECT IFNULL(`value`,'') FROM `ww_config` WHERE `key`='email_tk_officer' LIMIT  1);
       SET @emailsubject = '';
       SET @emailbody = '';
       
       SELECT `subject`,`body` INTO @emailsubject, @emailbody
       FROM `ww_system_template` WHERE `code` = 'TIME-SERVER-REMINDER' LIMIT 1;
           
       IF @emailsubject <> '' THEN
          -- {{table_body}}
          SET @emailbody = REPLACE(@emailbody, '{{table_body}}', @tbody);
          
          -- {{link}}
          SET @url = (SELECT `value` FROM `ww_config` WHERE `key`='URL' LIMIT  1);
	      IF RIGHT(TRIM(@url),1) <> '/' THEN
	         SET @url = CONCAT(TRIM(@url),'/');
	      END IF;
	         
          -- SET @route = (SELECT `route` FROM `ww_modules` WHERE `mod_code`='form_application_manage' LIMIT 1);
          SET @system_title = (SELECT `value` FROM `ww_config` WHERE `key`='application_title' LIMIT  1);
          SET @emailbody = REPLACE(@emailbody, '{{system_url}}', @url);
          SET @emailbody = REPLACE(@emailbody, '{{system_route}}', CONCAT(@url,@route));
          SET @emailbody = REPLACE(@emailbody, '{{system_title}}', @system_title);
          
          -- {{insert to table}}
          INSERT INTO `ww_system_email_queue` (`to`,`cc`,`bcc`,`subject`,`body`)
          SELECT @emailto, @emailcc, @emailbcc, @emailsubject, @emailbody;
          
          -- SELECT @emailbody;
       END IF;
       
    END IF;
    
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_shift_class_company` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_shift_class_company` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_shift_class_company`(IN shiftid INT(11))
BEGIN
    
    INSERT INTO `ww_time_shift_class_company` 
    (`shift_id`, `company_id`, `class_id`, `class_value`, `employment_status_id`, `employment_type_id`, `partners_id`)  
    
    SELECT ts.`shift_id`, uc.`company_id`, tsc.`class_id`, tsc.`default_value`, 'ALL' `employment_status_id`, 'ALL' `employment_type_id`, 0 `partners_id`
    FROM `ww_time_shift_class` tsc
    JOIN `ww_users_company` uc ON uc.`deleted`=0
    JOIN `ww_time_shift` ts ON ts.`deleted`=0 AND ts.shift <> 'Restday' AND tsc.`class_id` IN (1,3,29,30)
    WHERE tsc.`default_value` IS NOT NULL AND ts.`shift_id`=shiftid
    
    ON DUPLICATE KEY UPDATE `deleted` = 0;
END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_shift_insert` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_shift_insert` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_shift_insert`(IN calendarid INT, IN weekno INT, IN shiftid INT)
BEGIN
       INSERT INTO `ww_time_shift_weekly_calendar` (`calendar_id`, `week_no`, `shift_id`)
       SELECT calendarid, weekno, shiftid
       ON DUPLICATE KEY UPDATE `shift_id`=shiftid;
       
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_time_shift_process` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_time_shift_process` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_time_shift_process`(IN shiftid INT(11))
BEGIN
       /* This will insert-update time_record
          last change: 2016-04-21 initial
                       2016-04-21 
       */
       DELETE FROM ww_time_shift_class_company
       WHERE shift_id=shiftid;
       
       INSERT INTO `ww_time_shift_class_company`
       (shift_id, company_id, class_id, class_value, employment_status_id, employment_type_id, partners_id)
       
       SELECT  ts.`shift_id`, tsati.`apply_to_id`, tsc.`class_id`, 
       
              CASE tsc.class_id 
                   WHEN 1 THEN  -- WORKING-HOURS
                        IF(ts.time_start < ts.time_end,
				-- dayshift
				HOUR(TIMEDIFF(time_end,ts.time_start)) - 1,
				-- nightshift
				TIMESTAMPDIFF(HOUR,CONCAT(DATE(NOW()) - INTERVAL 1 DAY,' ',ts.time_start),CONCAT(DATE(NOW()),' ',ts.time_end))-1)
		   WHEN 3 THEN -- GRACE-PERIOD-IN-MINUTES
                        tsc.`default_value`
                   WHEN 4 THEN -- HALFDAY TAGGING (IN HOURS)
                        TIME(CONCAT(DATE(DATE(NOW())),' ',ts.time_start) + INTERVAL 4 HOUR)
                   WHEN 6 THEN -- FIRST-HALF-END (IN HOURS)
                        TIME(CONCAT(DATE(DATE(NOW())),' ',ts.time_start) + INTERVAL 4 HOUR)
                   WHEN 9 THEN -- SECOND-HALF-GRACE-IN-MINUTES
                        0
                   WHEN 10 THEN -- MAX-PRESHIFT (IN TIME-FORMAT OR MINUS 2 HOURS FROM TIME-START)
                        TIME_FORMAT(CONCAT(CURDATE(),' ',ts.`time_start`) - INTERVAL 120 MINUTE, '%H:%i:%s')
                   WHEN 14 THEN -- MAX-POSTSHIFT (IN TIME-FORMAT OR PLUS 12 HOURS AND 59 MINUTES AFTER TIME-END)
                        TIME_FORMAT(CONCAT(CURDATE(),' ',ts.`time_end`) + INTERVAL 779 MINUTE, '%H:%i:%s')
                   /*WHEN 24 THEN -- FLEXIBLE-SHIFT: DEFAULT IS 0-NON FLEXI TAG
                        0*/
                   WHEN 28 THEN -- BREAK-IN-MINUTES: DEFAULT IS 60 MINUTES
                        60
                   WHEN 29 THEN  -- NIGHT-DIFF-START: DEFAULT IS 10PM
                        tsc.`default_value` 
                   WHEN 30 THEN  -- NIGHT-DIFF-END: DEFAULT IS 6AM
                        tsc.`default_value` 
                   ELSE ''
              END alt_value,
       
              'ALL', 'ALL', 'NONE'
              -- For checking: ts.`shift`, ts.`time_start`, ts.`time_end`, tsc.`default_value`, tsc.`class_code`
       FROM ww_time_shift_class tsc
       INNER JOIN ww_time_shift_apply_to_id tsati ON tsati.`apply_to` = 2
       INNER JOIN ww_time_shift ts ON ts.`deleted`=0 AND ts.`shift_id`=tsati.`shift_id`
       WHERE tsc.`deleted`=0 AND tsc.`class_id` <> 24
       AND ts.shift_id=shiftid
       ON DUPLICATE KEY UPDATE 
              `deleted`=VALUES(`deleted`);
       
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_truncate_payroll_table` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_truncate_payroll_table` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_truncate_payroll_table`()
BEGIN
	truncate ww_payroll_account;
	truncate ww_payroll_bonus;
	TRUNCATE ww_payroll_bonus_accrual;
	TRUNCATE ww_payroll_bonus_employee;
	TRUNCATE ww_payroll_closed_summary;
	TRUNCATE ww_payroll_closed_transaction;
	TRUNCATE ww_payroll_current_transaction;
	TRUNCATE ww_payroll_entry_batch;
	TRUNCATE ww_payroll_entry_batch_employee;
	TRUNCATE ww_payroll_entry_recurring;
	TRUNCATE ww_payroll_entry_recurring_employee;
	TRUNCATE ww_payroll_loan;
	TRUNCATE ww_payroll_location;
	TRUNCATE ww_payroll_partners_contribution;
	TRUNCATE ww_payroll_partners_loan;
	TRUNCATE ww_payroll_partners_loan_payment;
	TRUNCATE ww_payroll_period;
	TRUNCATE ww_payroll_period_apply_to;
    END */$$
DELIMITER ;

/* Procedure structure for procedure `sp_truncate_transactional_table` */

/*!50003 DROP PROCEDURE IF EXISTS  `sp_truncate_transactional_table` */;

DELIMITER $$

/*!50003 CREATE DEFINER=`emplopad`@`%` PROCEDURE `sp_truncate_transactional_table`()
BEGIN
	truncate `ww_partners_movement`;
	truncate `ww_partners_movement_action`;
    END */$$
DELIMITER ;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
